---
title: 【DX11地形篇】4-地形网格纹理
date: 2018-05-03 21:02:06
tags:
	- DirectX
	- Terrain
	- GameDev
	- Computer graphics
---

#### 参考教程

[Tutorial 3: Terrain Texturing](http://www.rastertek.com/dx11ter03.html)

#### 学习记录

&emsp;&emsp;本篇介绍地形网格的纹理贴图，基于上一篇代码，我们简单的使用 `TextureShaderClass` 来渲染网格，使用一个 `TextureManagerClass` 类管理项目中的纹理数据。框架如图：

![1](https://image.ibb.co/hUTBM7/image.png)

<!--more-->

&emsp;&emsp;这次我们将以 `TextureShaderClass` 来代替 `ColorShaderClass` 渲染网格，所以在 `ShaderManagerClass` 中新增 `TextureShaderClass` 的对象，同时添加它的 `Render` 接口。修改后的类声明如下：

```c++
////////////////////////////////////////////////////////////////////////////////
// Class name: ShaderManagerClass
////////////////////////////////////////////////////////////////////////////////
class ShaderManagerClass
{
public:
	ShaderManagerClass();
	ShaderManagerClass(const ShaderManagerClass&);
	~ShaderManagerClass();

	bool Initialize(ID3D11Device*, HWND);
	void Shutdown();

	bool RenderColorShader(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX);
	bool RenderFontShader(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*, XMFLOAT4);
	bool RenderTextureShader(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*);

private:
	ColorShaderClass* m_ColorShader;
	FontShaderClass* m_FontShader;
	TextureShaderClass* m_TextureShader;
};
```

&emsp;&emsp;其次，我们修改 `TerrainClass` ，为顶点增加 `uv` 属性，并且在初始化顶点数据的时候初始化：

```c++
struct VertexType
{
	XMFLOAT3 position;
	XMFLOAT2 texcoord;
};

struct HeightMapType {
	float x, y, z;
};

struct ModelType {
	float x, y, z;
	float tu, tv;
};

// Load the 3D terrain model with the height map terrain data.
// We will be creating 2 triangles for each of the four points in a quad.
for(j=0; j<(m_terrainHeight-1); j++)
{
	for(i=0; i<(m_terrainWidth-1); i++)
	{
		// Get the indexes to the four points of the quad.
		index1 = (m_terrainWidth * j) + i;          // Upper left.
		index2 = (m_terrainWidth * j) + (i+1);      // Upper right.
		index3 = (m_terrainWidth * (j+1)) + i;      // Bottom left.
		index4 = (m_terrainWidth * (j+1)) + (i+1);  // Bottom right.

		// Now create two triangles for that quad.
		// Triangle 1 - Upper left.
		m_terrainModel[index].x = m_heightMap[index1].x;
		m_terrainModel[index].y = m_heightMap[index1].y;
		m_terrainModel[index].z = m_heightMap[index1].z;
		m_terrainModel[index].tu = 0.0f;
		m_terrainModel[index].tv = 0.0f;
		index++;

		// Triangle 1 - Upper right.
		m_terrainModel[index].x = m_heightMap[index2].x;
		m_terrainModel[index].y = m_heightMap[index2].y;
		m_terrainModel[index].z = m_heightMap[index2].z;
		m_terrainModel[index].tu = 1.0f;
		m_terrainModel[index].tv = 0.0f;
		index++;

		// Triangle 1 - Bottom left.
		m_terrainModel[index].x = m_heightMap[index3].x;
		m_terrainModel[index].y = m_heightMap[index3].y;
		m_terrainModel[index].z = m_heightMap[index3].z;
		m_terrainModel[index].tu = 0.0f;
		m_terrainModel[index].tv = 1.0f;
		index++;

		// Triangle 2 - Bottom left.
		m_terrainModel[index].x = m_heightMap[index3].x;
		m_terrainModel[index].y = m_heightMap[index3].y;
		m_terrainModel[index].z = m_heightMap[index3].z;
		m_terrainModel[index].tu = 0.0f;
		m_terrainModel[index].tv = 1.0f;
		index++;

		// Triangle 2 - Upper right.
		m_terrainModel[index].x = m_heightMap[index2].x;
		m_terrainModel[index].y = m_heightMap[index2].y;
		m_terrainModel[index].z = m_heightMap[index2].z;
		m_terrainModel[index].tu = 1.0f;
		m_terrainModel[index].tv = 0.0f;
		index++;

		// Triangle 2 - Bottom right.
		m_terrainModel[index].x = m_heightMap[index4].x;
		m_terrainModel[index].y = m_heightMap[index4].y;
		m_terrainModel[index].z = m_heightMap[index4].z;
		m_terrainModel[index].tu = 1.0f;
		m_terrainModel[index].tv = 1.0f;
		index++;
	}
}
```

&emsp;&emsp;之后，我们需要一个 `TextureManagerClass` 类来管理我们的纹理，其声明如下：

```c++
////////////////////////////////////////////////////////////////////////////////
// Class name: TextureManagerClass
////////////////////////////////////////////////////////////////////////////////
class TextureManagerClass
{
public:
	TextureManagerClass();
	TextureManagerClass(const TextureManagerClass&);
	~TextureManagerClass();

	bool Initialize(int);
	void Shutdown();

	bool LoadTexture(ID3D11Device*, ID3D11DeviceContext*, char*, int);

	ID3D11ShaderResourceView* GetTexture(int);

private:
	TextureClass* m_TextureArray;
	int m_textureCount;
};
```

&emsp;&emsp;最后，我们替换 `ZoneClass` 中的渲染方法为纹理渲染：

```c++
// Render the terrain grid using the texture shader.
m_Terrain->Render(Direct3D->GetDeviceContext());
result = ShaderManager->RenderTextureShader(Direct3D->GetDeviceContext(), m_Terrain->GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix , TextureManager->GetTexture(0));
```

&emsp;&emsp;最终效果如下：

![2](https://image.ibb.co/ijpt17/image.png)

&emsp;&emsp;源代码：[DX11TerrainTutorial-TerrainTexturing](https://github.com/KsGin/DX11TerrainTutorial/tree/master/DX11TerrainTutorial-TerrainTexturing)