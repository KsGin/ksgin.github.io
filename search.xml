<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Find-and-Replace-Pattern]]></title>
    <url>%2F2018%2F09%2F04%2FFind-and-Replace-Pattern%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#890 Find and Replace Pattern 题目描述&emsp;&emsp;You have a list of words and a pattern, and you want to know which words in words matches the pattern. &emsp;&emsp;A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. &emsp;&emsp;(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) &emsp;&emsp;Return a list of the words in words that match the given pattern. &emsp;&emsp;You may return the answer in any order. Example 1: 12345Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;Output: [&quot;mee&quot;,&quot;aqq&quot;]Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;. &quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,since a and b map to the same letter. Note: 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 解题思路&emsp;&emsp;判断字符串是否满足 pattern 只需要判断每个字母相对于前边的字母是否相等的规律与 pattern 能否一致就可以了。 解题代码123456789101112131415161718192021class Solution &#123;public: vector&lt;string&gt; findAndReplacePattern(vector&lt;string&gt; &amp;words, string pattern) &#123; vector&lt;string&gt; res(0); bool isPattern; for (auto &amp;word : words) &#123; isPattern = true; for (int i = 1; i &lt; pattern.size(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if ((word[i] == word[j]) ^ (pattern[i] == pattern[j])) &#123; isPattern = false; break; &#125; &#125; if (!isPattern) break; &#125; if (isPattern) res.push_back(word); &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Top-K-Frequent-Words]]></title>
    <url>%2F2018%2F09%2F03%2FTop-K-Frequent-Words%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#692 Top K Frequent Words 题目描述&emsp;&emsp;Given a non-empty list of words, return the k most frequent elements. &emsp;&emsp;Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: 1234Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2Output: [&quot;i&quot;, &quot;love&quot;]Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words. Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order. Example 2: 1234Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters. Follow up: Try to solve it in O(n log k) time and O(n) extra space. 解题思路&emsp;&emsp;经典题型，使用字典保存字符串与次数键值对，然后使用有序序列统计即可。 解题代码1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) &#123; unordered_map&lt;string, int&gt; mp; for(auto word:words) mp[word]++; set&lt;pair&lt;int, string&gt;&gt; mySet; for(auto item:mp) &#123; mySet.insert(make_pair(0-item.second, item.first)); //let the most frequent become the smallest &#125; auto it=mySet.begin(); vector&lt;string&gt; res; for(int i=0; i&lt;k; i++) &#123; res.push_back((*it).second); it++; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++学习笔记】1-开坑]]></title>
    <url>%2F2018%2F08%2F21%2F%E3%80%90C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%911-%E5%BC%80%E5%9D%91%2F</url>
    <content type="text"><![CDATA[开坑&emsp;&emsp;记录自己学习 《 Inside The C++ Object Model 》，《 More Effective C++ 》，《 STL 源码剖析 》等书籍的笔记，不定期更新。]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary-Gap]]></title>
    <url>%2F2018%2F07%2F19%2FBinary-Gap%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#868 Binary Gap 题目描述&emsp;&emsp;Given a positive integer N, find and return the longest distance between two consecutive 1’s in the binary representation of N. &emsp;&emsp;If there aren’t two consecutive 1’s, return 0. Example 1: 12345678Input: 22Output: 2Explanation: 22 in binary is 0b10110.In the binary representation of 22, there are three ones, and two consecutive pairs of 1&apos;s.The first consecutive pair of 1&apos;s have distance 2.The second consecutive pair of 1&apos;s have distance 1.The answer is the largest of these two distances, which is 2. Example 2: 1234Input: 5Output: 2Explanation: 5 in binary is 0b101. Example 3: 1234Input: 6Output: 1Explanation: 6 in binary is 0b110. Example 4: 12345Input: 8Output: 0Explanation: 8 in binary is 0b1000.There aren&apos;t any consecutive pairs of 1&apos;s in the binary representation of 8, so we return 0. Note: 1 &lt;= N &lt;= 10^9 解题思路&emsp;&emsp;题目要求找出给定值的二进制串中距离最远的两个 1 ，并返回其距离。可以化为二进制串然后遍历也可以直接像我这种使用移位并且计算。 解题代码123456789101112131415161718class Solution &#123;public: int binaryGap(int N) &#123; if (N == 0) return 0; int ret = -1; int cot = 0; while (N &gt; 0) &#123; if (N &amp; 1) &#123; ret = ret &gt; cot ? ret : cot; cot = 0; &#125; N = N &gt;&gt; 1; cot += ret &gt;= 0; &#125; return ret &gt; 0 ? ret : 0; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Transpose-Matrix]]></title>
    <url>%2F2018%2F07%2F14%2FTranspose-Matrix%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#867 Transpose Matrix 题目描述&emsp;&emsp;Given a matrix A, return the transpose of A. &emsp;&emsp;The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix. Example 1: 12Input: [[1,2,3],[4,5,6],[7,8,9]]Output: [[1,4,7],[2,5,8],[3,6,9]] Example 2: 12Input: [[1,2,3],[4,5,6]]Output: [[1,4],[2,5],[3,6]] Note: 1 &lt;= A.length &lt;= 1000 1 &lt;= A[0].length &lt;= 1000 解题思路&emsp;&emsp;题目要求实现矩阵的转置，不知道矩阵转置可以看 这里 解题代码1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt; &amp;A) &#123; if (A.empty()) return A; int row = A.size(), col = A[0].size(); vector&lt;vector&lt;int&gt;&gt; ret(col, vector&lt;int&gt;(row, 0)); for (int i = 0; i &lt; A.size(); ++i) &#123; for (int j = 0; j &lt; A[i].size(); ++j) &#123; ret[j][i] = A[i][j]; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[To-Lower-Case]]></title>
    <url>%2F2018%2F07%2F13%2FTo-Lower-Case%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#709 To Lower Case 题目描述&emsp;&emsp;Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. 解题思路&emsp;&emsp;实现 ToLowerCase() 方法。 解题代码1234567891011class Solution &#123;public: string toLowerCase(string str) &#123; for (auto &amp;c : str) &#123; if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') &#123; c += 32; &#125; &#125; return str; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number-of-Lines-To-Write-String]]></title>
    <url>%2F2018%2F07%2F07%2FNumber-of-Lines-To-Write-String%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#806 Number of Lines To Write String 题目描述&emsp;&emsp;We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of ‘a’, widths[1] is the width of ‘b’, …, and widths[25] is the width of ‘z’. &emsp;&emsp;Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2. 12345678Example :Input: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;abcdefghijklmnopqrstuvwxyz&quot;Output: [3, 60]Explanation: All letters have the same length of 10. To write all 26 letters,we need two full lines and one line with 60 units. 1234567891011Example :Input: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;bbbcccdddaaa&quot;Output: [2, 4]Explanation: All letters except &apos;a&apos; have the same length of 10, and &quot;bbbcccdddaa&quot; will cover 9 * 10 + 2 * 4 = 98 units.For the last &apos;a&apos;, it is written on the second line becausethere is only 2 units left in the first line.So the answer is 2 lines, plus 4 units in the second line. Note: The length of S will be in the range [1, 1000]. S will only contain lowercase letters. widths is an array of length 26. widths[i] will be in the range of [2, 10]. 解题思路&emsp;&emsp;直接遍历给定字符串，按照题目要求就可以了。 解题代码123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; numberOfLines(vector&lt;int&gt; &amp;widths, string S) &#123; vector&lt;int&gt; ret(2, 0); if (S.empty()) return ret; for (auto &amp;c : S) &#123; int w = widths[c - 'a']; if (ret[1] + w &gt; 100) &#123; ++ret[0]; ret[1] = w; &#125; else &#123; ret[1] += w; &#125; &#125; if (ret[1] != 0) ++ret[0]; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Score-After-Flipping-Matrix]]></title>
    <url>%2F2018%2F07%2F07%2FScore-After-Flipping-Matrix%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#861 Score After Flipping Matrix 题目描述&emsp;&emsp;We have a two dimensional matrix A where each value is 0 or 1. &emsp;&emsp;A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. &emsp;&emsp;After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. &emsp;&emsp;Return the highest possible score. Example 1: 12345Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]Output: 39Explanation:Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Note: 1 &lt;= A.length &lt;= 20 1 &lt;= A[0].length &lt;= 20 A[i][j] is 0 or 1. 解题思路&emsp;&emsp;贪心算法，我们知道二进制串中越高位的占的比重越大，所以我们可以直接从高到底来判断是否进行 toggling 操作。 &emsp;&emsp;首先为行，行中每个数字的权重不一样，从高往低，所以在行中我们只需要对第一位进行判断（即数组第一个数字），当他为0的时候我们要将他变为1 就需要 toggling ，这样可以使这一行数字的二进制串最大。 &emsp;&emsp;列中每一列的权重一样，所以我们需要判断这一列中1的个数和0的个数，当0的个数大于1的个数时我们进行 toggling 操作。 解题代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int matrixScore(vector&lt;vector&lt;int&gt;&gt; &amp;A) &#123; if (A.empty()) return 0; for (int i = 0; i &lt; A.size(); ++i) &#123; int flag = 0; for (int j = 0; j &lt; A[i].size(); ++j) &#123; if (A[i][0] == 0 || flag) &#123; A[i][j] = A[i][j] == 1 ? 0 : 1; flag = 1; &#125; &#125; &#125; for (int i = 1; i &lt; A[0].size(); ++i) &#123; int sum = 0; for (int j = 0; j &lt; A.size(); ++j) &#123; sum += A[j][i]; &#125; if (sum * 2 &lt; A.size()) &#123; for (int j = 0; j &lt; A.size(); ++j) &#123; A[j][i] = A[j][i] == 1 ? 0 : 1; &#125; &#125; &#125; int ret = 0; for (int i = 0; i &lt; A.size(); ++i) &#123; for (int j = 0; j &lt; A[i].size(); ++j) &#123; ret += A[i][j] * pow(2, A[i].size() - 1 - j); &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[All-Paths-From-Source-to-Target]]></title>
    <url>%2F2018%2F06%2F30%2FAll-Paths-From-Source-to-Target%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#797 All Paths From Source to Target 题目描述&emsp;&emsp;Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order. &emsp;&emsp;The graph is given as follows: the nodes are 0, 1, …, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists. 123456789Example:Input: [[1,2], [3], [3], []] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:0---&gt;1| |v v2---&gt;3There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3. Note: The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path. 解题思路&emsp;&emsp;唯一需要注意的是题目所给的值是当前节点所能到达的下一个节点位置，然后用 DFS 求解就是。 解题代码1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt; &amp;graph) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; tmp; helper(graph , ret , tmp , 0); return ret; &#125; void helper(vector&lt;vector&lt;int&gt;&gt; &amp;graph, vector&lt;vector&lt;int&gt;&gt; &amp;ret, vector&lt;int&gt; tout, int start) &#123; tout.push_back(start); if (tout.back() == graph.size() - 1) &#123; ret.push_back(tout); return; &#125; for (auto it : graph[start]) &#123; helper(graph, ret, tout, it); &#125; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary-Tree-Pruning]]></title>
    <url>%2F2018%2F06%2F27%2FBinary-Tree-Pruning%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#814 Binary Tree Pruning 题目描述&emsp;&emsp;We are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1. &emsp;&emsp;Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. &emsp;&emsp;(Recall that the subtree of a node X is X, plus every node that is a descendant of X.) 1234567Example 1:Input: [1,null,0,0,1]Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property &quot;every subtree not containing a 1&quot;.The diagram on the right represents the answer. 123Example 2:Input: [1,0,1,0,0,0,1]Output: [1,null,1,null,1] 123Example 3:Input: [1,1,0,1,1,0,1,0]Output: [1,1,0,1,1,null,1] Note: The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1. 解题思路&emsp;&emsp;题目要求去除值都为 0 的子树，照做就可以了。 解题代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; int getSubTreeValueSum(TreeNode *root) &#123; if (!root) return 0; else return root-&gt;val + getSubTreeValueSum(root-&gt;left) + getSubTreeValueSum(root-&gt;right); &#125;public: TreeNode *pruneTree(TreeNode *root) &#123; if (!root) return root; if (!getSubTreeValueSum(root-&gt;left)) &#123; root-&gt;left = nullptr; &#125; if (!getSubTreeValueSum(root-&gt;right)) &#123; root-&gt;right = nullptr; &#125; pruneTree(root-&gt;left); pruneTree(root-&gt;right); return root; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flipping-an-Image]]></title>
    <url>%2F2018%2F06%2F26%2FFlipping-an-Image%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#832 Flipping an Image 题目描述&emsp;&emsp;Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. &emsp;&emsp;To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. &emsp;&emsp;To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: 1234Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: 1234Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 解题思路&emsp;&emsp;按照题目要求先 reverse 每一行，再取反即可 解题代码12345678910111213class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt; &amp;A) &#123; if (A.empty()) return A; vector&lt;vector&lt;int&gt;&gt; ret(A.size(), vector&lt;int&gt;(A[0].size(), 0)); for (int i = 0; i &lt; A.size(); ++i) &#123; for (int j = A[i].size() - 1; j &gt;= 0; --j) &#123; ret[i][A[i].size() - j - 1] = !A[i][j]; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Peak-Index-in-a-Mountain-Array]]></title>
    <url>%2F2018%2F06%2F25%2FPeak-Index-in-a-Mountain-Array%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#852 Peak Index in a Mountain Array 题目描述&emsp;&emsp;Let’s call an array A a mountain if the following properties hold: A.length &gt;= 3 There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1] &emsp;&emsp;Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]. Example 1: 12Input: [0,1,0]Output: 1 Example 2: 12Input: [0,2,1,0]Output: 1 Note: 3 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^6 A is a mountain, as defined above. 解题思路&emsp;&emsp;直接遍历。。。 解题代码12345678910class Solution &#123;public: int peakIndexInMountainArray(vector&lt;int&gt;&amp; A) &#123; if (A.size() &lt; 3) return 0; for (int i = 1; i &lt; A.size(); ++i) &#123; if (A[i] &lt; A[i-1]) return i-1; &#125; return 0; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Max-Increase-to-Keep-City-Skyline]]></title>
    <url>%2F2018%2F06%2F24%2FMax-Increase-to-Keep-City-Skyline%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#807 Max Increase to Keep City Skyline 题目描述&emsp;&emsp;In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. &emsp;&emsp;At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. &emsp;&emsp;What is the maximum total sum that the height of the buildings can be increased? 12345678910111213141516171819Example:Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]Output: 35Explanation: The grid is:[ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ]The skyline viewed from top or bottom is: [9, 4, 8, 7]The skyline viewed from left or right is: [8, 7, 9, 3]The grid after increasing the height of buildings without affecting skylines is:gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] Notes: 1 &lt; grid.length = grid[0].length &lt;= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism. 解题思路&emsp;&emsp;直接先遍历找到每一行每一列的最大值，然后 grid[i][j] 所能增加的高度就是行最高和列最高中较小的一个减去 grid[i][j] 当前值，遍历求和即可。 解题代码1234567891011121314151617181920212223242526class Solution &#123;public: int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123; if (grid.empty()) return 0; vector&lt;int&gt; rowMax(grid.size(), 0), colMax(grid[0].size(), 0); for (int i = 0; i &lt; grid.size(); ++i) &#123; for (int j = 0; j &lt; grid[i].size(); ++j) &#123; rowMax[i] = rowMax[i] &gt; grid[i][j] ? rowMax[i] : grid[i][j]; colMax[j] = colMax[j] &gt; grid[i][j] ? colMax[j] : grid[i][j]; &#125; &#125; int ret = 0; for (int i = 0; i &lt; grid.size(); ++i) &#123; for (int j = 0; j &lt; grid[i].size(); ++j) &#123; int minMax = rowMax[i] &lt; colMax[j] ? rowMax[i] : colMax[j]; int increase = minMax - grid[i][j]; ret += increase &gt; 0 ? increase : 0; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unique-Binary-Search-Trees]]></title>
    <url>%2F2018%2F05%2F26%2FUnique-Binary-Search-Trees%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#96 Unique Binary Search Trees 题目描述&emsp;&emsp;Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 12345678910Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路&emsp;&emsp;卡特兰数 + DP 求解。 解题代码12345678910111213141516class Solution &#123;public: int numTrees(int n) &#123; if (n &lt;= 0) return 0; vector&lt;int&gt; res(n + 1, 0); res[0] = 1; res[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; res[i] += res[j] * res[i - j - 1]; &#125; &#125; return res[n]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valid-Triangle-Number]]></title>
    <url>%2F2018%2F05%2F25%2FValid-Triangle-Number%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#611 Valid Triangle Number 题目描述&emsp;&emsp;Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. Example 1: 1234567Input: [2,2,3,4]Output: 3Explanation:Valid combinations are: 2,3,4 (using the first 2)2,3,4 (using the second 2)2,2,3 Note: The length of the given array won’t exceed 1000. The integers in the given array are in the range of [0, 1000]. 解题思路&emsp;&emsp;emmmm判断三条边能否构成三角形的计算应该不需要解释了，我们无脑的使用三层循环就可以 AC ，不过时间复杂度比较高。 解题代码1234567891011121314151617class Solution &#123;public: int triangleNumber(vector&lt;int&gt; &amp;nums) &#123; int res = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; int n1 = nums[i]; for (int j = i + 1; j &lt; nums.size(); ++j) &#123; int n2 = nums[j]; for (int k = j + 1; k &lt; nums.size(); ++k) &#123; int n3 = nums[k]; res += !(n1 + n2 &lt;= n3 || n2 + n3 &lt;= n1 || n1 + n3 &lt;= n2); &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Second-Minimum-Node-In-A-Binary-Tree]]></title>
    <url>%2F2018%2F05%2F21%2FSecond-Minimum-Node-In-A-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#671 Second Minimum Node In A Binary Tree 题目描述&emsp;&emsp;Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly twoor zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. &emsp;&emsp;Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. &emsp;&emsp;If no such second minimum value exists, output -1 instead. Example 1: 123456789Input: 2 / \ 2 5 / \ 5 7Output: 5Explanation: The smallest value is 2, the second smallest value is 5. Example 2: 1234567Input: 2 / \ 2 2Output: -1Explanation: The smallest value is 2, but there isn&apos;t any second smallest value. 解题思路&emsp;&emsp;题目要求得到二叉树中第二小的节点值 (Second Minimum Node) ，遍历就可以了。 解题代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; int fmin = INT_MAX; int smin = INT_MAX;public: int findSecondMinimumValue(TreeNode* root) &#123; if (!root) return smin; int val = root-&gt;val; if (val &lt; fmin) &#123; smin = fmin; fmin = val; &#125; else if (val &gt; fmin &amp;&amp; val &lt; smin)&#123; smin = val; &#125; findSecondMinimumValue(root-&gt;left); findSecondMinimumValue(root-&gt;right); return smin == INT_MAX ? -1 : smin; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】17-扰动云]]></title>
    <url>%2F2018%2F05%2F20%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%9117-%E6%89%B0%E5%8A%A8%E4%BA%91%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 12: Perturbed Clouds 学习记录&emsp;&emsp;这篇文章种我们介绍另一种渲染云层得方法，使用扰动纹理（Perturb Texture）实现，本篇代码基于上一篇，无新增类。 &emsp;&emsp;上一篇中我们使用了两张纹理来渲染云层，这篇中我们依然使用两张，但是一张为云层纹理，一张为扰动纹理，我们此时需要更改 SkyPlane.ps 来使用 scale , translation , brightless 来进行计算纹理坐标 。此时的 SkyPlane.vs 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455////////////////////////////////////////////////////////////////////////////////// Filename: skyplane.ps/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////Texture2D cloudTexture : register(t0);Texture2D perturbTexture : register(t1);SamplerState SampleType;cbuffer SkyBuffer&#123; float translation; float scale; float brightness; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 SkyPlanePixelShader(PixelInputType input) : SV_TARGET&#123; float4 perturbValue; float4 cloudColor; // Translate the texture coordinate sampling location by the translation value. input.tex.x = input.tex.x + translation; // Sample the texture value from the perturb texture using the translated texture coordinates. perturbValue = perturbTexture.Sample(SampleType, input.tex); // Multiply the perturb value by the perturb scale. perturbValue = perturbValue * scale; // Add the texture coordinates as well as the translation value to get the perturbed texture coordinate sampling location. perturbValue.xy = perturbValue.xy + input.tex.xy + translation; // Now sample the color from the cloud texture using the perturbed sampling coordinates. cloudColor = cloudTexture.Sample(SampleType, perturbValue.xy); // Reduce the color cloud by the brightness value. cloudColor = cloudColor * brightness; return cloudColor;&#125; &emsp;&emsp;主要的内容就是在这里，SkyPlaneShaderClass 的更改仅仅是支持新的 Shader ，其声明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465////////////////////////////////////////////////////////////////////////////////// Filename: skyplaneshaderclass.h////////////////////////////////////////////////////////////////////////////////#ifndef _SKYPLANESHADERCLASS_H_#define _SKYPLANESHADERCLASS_H_//////////////// INCLUDES ////////////////#include &lt;d3d11.h&gt;#include &lt;DirectXMath.h&gt;#include &lt;d3dx11async.h&gt;#include &lt;fstream&gt;using namespace std;using namespace DirectX;////////////////////////////////////////////////////////////////////////////////// Class name: SkyPlaneShaderClass////////////////////////////////////////////////////////////////////////////////class SkyPlaneShaderClass&#123;private: struct MatrixBufferType &#123; XMMATRIX world; XMMATRIX view; XMMATRIX projection; &#125;; struct SkyBufferType &#123; float translation; float scale; float brightness; float padding; &#125;;public: SkyPlaneShaderClass(); SkyPlaneShaderClass(const SkyPlaneShaderClass&amp;); ~SkyPlaneShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, float, float, float);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, float, float, float); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_skyBuffer;&#125;;#endif &emsp;&emsp;在我们的 SkyPlaneClass 中，我们更改之前的多个 Translation 变量为 Translation ，Brightless 和 Scale 以及更改其对应的 Get 方法，其声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576////////////////////////////////////////////////////////////////////////////////// Filename: skyplaneclass.h////////////////////////////////////////////////////////////////////////////////#ifndef _SKYPLANECLASS_H_#define _SKYPLANECLASS_H_//////////////// INCLUDES ////////////////#include &lt;d3d11.h&gt;#include &lt;d3dx10math.h&gt;///////////////////////// MY CLASS INCLUDES /////////////////////////#include "textureclass.h"#include &lt;DirectXMath.h&gt;////////////////////////////////////////////////////////////////////////////////// Class name: SkyPlaneClass////////////////////////////////////////////////////////////////////////////////class SkyPlaneClass&#123;private: struct SkyPlaneType &#123; float x, y, z; float tu, tv; &#125;; struct VertexType &#123; DirectX::XMFLOAT3 position; DirectX::XMFLOAT2 texture; &#125;;public: SkyPlaneClass(); SkyPlaneClass(const SkyPlaneClass&amp;); ~SkyPlaneClass(); bool Initialize(ID3D11Device* , ID3D11DeviceContext*, CHAR*, CHAR*); void Shutdown(); void Render(ID3D11DeviceContext*); void Frame(); int GetIndexCount(); ID3D11ShaderResourceView* GetCloudTexture(); ID3D11ShaderResourceView* GetPerturbTexture(); float GetScale(); float GetBrightness(); float GetTranslation();private: bool InitializeSkyPlane(int, float, float, float, int); void ShutdownSkyPlane(); bool InitializeBuffers(ID3D11Device*, int); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); bool LoadTextures(ID3D11Device*,ID3D11DeviceContext*, CHAR*, CHAR*); void ReleaseTextures();private: SkyPlaneType* m_skyPlane; int m_vertexCount, m_indexCount; ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; TextureClass *m_cloudTexture, *m_perturbTexture; float m_scale, m_brightness, m_translation;&#125;;#endif &emsp;&emsp;最后我们修改 ShaderManagerClass 和 ZoneClass 对应部分，最终效果如下： &emsp;&emsp;源代码：DX11TerrainTutorial-PerturbedClouds]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】16-位图云]]></title>
    <url>%2F2018%2F05%2F19%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%9116-%E4%BD%8D%E5%9B%BE%E4%BA%91%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 11: Bitmap Clouds 学习记录&emsp;&emsp;这篇文章种我们介绍云的实现，本篇代码基于上一篇，新增 SkyPlaneClass 和 SkyPlaneShaderClass 。 &emsp;&emsp;我们实现云效果的原理则是一个弧面模型，然后使用云的贴图即可，在 SkyPlaneClass 种我们负责弧面模型的创建等，其声明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677////////////////////////////////////////////////////////////////////////////////// Filename: skyplaneclass.h////////////////////////////////////////////////////////////////////////////////#ifndef _SKYPLANECLASS_H_#define _SKYPLANECLASS_H_//////////////// INCLUDES ////////////////#include &lt;d3d11.h&gt;#include &lt;d3dx10math.h&gt;///////////////////////// MY CLASS INCLUDES /////////////////////////#include "textureclass.h"#include &lt;DirectXMath.h&gt;////////////////////////////////////////////////////////////////////////////////// Class name: SkyPlaneClass////////////////////////////////////////////////////////////////////////////////class SkyPlaneClass&#123;private: struct SkyPlaneType &#123; float x, y, z; float tu, tv; &#125;; struct VertexType &#123; DirectX::XMFLOAT3 position; DirectX::XMFLOAT2 texture; &#125;;public: SkyPlaneClass(); SkyPlaneClass(const SkyPlaneClass&amp;); ~SkyPlaneClass(); bool Initialize(ID3D11Device* , ID3D11DeviceContext*, CHAR*, CHAR*); void Shutdown(); void Render(ID3D11DeviceContext*); void Frame(); int GetIndexCount(); ID3D11ShaderResourceView* GetCloudTexture1(); ID3D11ShaderResourceView* GetCloudTexture2(); float GetBrightness(); float GetTranslation(int);private: bool InitializeSkyPlane(int, float, float, float, int); void ShutdownSkyPlane(); bool InitializeBuffers(ID3D11Device*, int); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); bool LoadTextures(ID3D11Device*,ID3D11DeviceContext*, CHAR*, CHAR*); void ReleaseTextures();private: SkyPlaneType* m_skyPlane; int m_vertexCount, m_indexCount; ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; TextureClass *m_CloudTexture1, *m_CloudTexture2; float m_brightness; float m_translationSpeed[4]; float m_textureTranslation[4];&#125;;#endif &emsp;&emsp;比起其他模型类其实差不多，我们使用 m_translationSpeed 等数据控制云的移动，在 skyplane.ps 中实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263////////////////////////////////////////////////////////////////////////////////// Filename: skyplane.ps/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////Texture2D cloudTexture1 : register(t0);Texture2D cloudTexture2 : register(t1);SamplerState SampleType;cbuffer SkyBuffer&#123; float firstTranslationX; float firstTranslationZ; float secondTranslationX; float secondTranslationZ; float brightness; float3 padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 SkyPlanePixelShader(PixelInputType input) : SV_TARGET&#123; float2 sampleLocation; float4 textureColor1; float4 textureColor2; float4 finalColor; // Translate the position where we sample the pixel from using the first texture translation values. sampleLocation.x = input.tex.x + firstTranslationX; sampleLocation.y = input.tex.y + firstTranslationZ; // Sample the pixel color from the first cloud texture using the sampler at this texture coordinate location. textureColor1 = cloudTexture1.Sample(SampleType, sampleLocation); // Translate the position where we sample the pixel from using the second texture translation values. sampleLocation.x = input.tex.x + secondTranslationX; sampleLocation.y = input.tex.y + secondTranslationZ; // Sample the pixel color from the second cloud texture using the sampler at this texture coordinate location. textureColor2 = cloudTexture2.Sample(SampleType, sampleLocation); // Combine the two cloud textures evenly. finalColor = lerp(textureColor1, textureColor2, 0.5f); // Reduce brightness of the combined cloud textures by the input brightness value. finalColor = finalColor * brightness; return finalColor;&#125; &emsp;&emsp;而 SkyPlaneShaderClass 则是和其他 shader 类相同负责 skyplane 着色器的编译等，其声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869////////////////////////////////////////////////////////////////////////////////// Filename: skyplaneshaderclass.h////////////////////////////////////////////////////////////////////////////////#ifndef _SKYPLANESHADERCLASS_H_#define _SKYPLANESHADERCLASS_H_//////////////// INCLUDES ////////////////#include &lt;d3d11.h&gt;#include &lt;DirectXMath.h&gt;#include &lt;d3dx11async.h&gt;#include &lt;fstream&gt;using namespace std;using namespace DirectX;////////////////////////////////////////////////////////////////////////////////// Class name: SkyPlaneShaderClass////////////////////////////////////////////////////////////////////////////////class SkyPlaneShaderClass&#123;private: struct MatrixBufferType &#123; XMMATRIX world; XMMATRIX view; XMMATRIX projection; &#125;; struct SkyBufferType &#123; float firstTranslationX; float firstTranslationZ; float secondTranslationX; float secondTranslationZ; float brightness; XMFLOAT3 padding; &#125;;public: SkyPlaneShaderClass(); SkyPlaneShaderClass(const SkyPlaneShaderClass&amp;); ~SkyPlaneShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, float, float, float, float, float);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, float, float, float, float, float); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_skyBuffer;&#125;;#endif &emsp;&emsp;最后我们在 ShaderManagerClass 中创建 SkyPlaneShaderClass 的对象以及添加对应的渲染方法，在 Zone 中负责 SkyPlane 对象的初始化等等，最后在 Render 里渲染。需要开启透明和关闭背面剔除，因为我们在弧面的内侧。&emsp;&emsp;最终效果如下： &emsp;&emsp;源代码：DX11TerrainTutorial-BitmapClouds]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】15-基于距离的法线贴图]]></title>
    <url>%2F2018%2F05%2F15%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%9115-%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 14: Distance Normal Mapping 学习记录&emsp;&emsp;本篇文章中我们介绍基于观察点（摄像机）距离不同进行不同法线贴图的技术，本篇代码基于上一篇，仅有少量改动，无新增类。 &emsp;&emsp;对于我们所渲染的大场景而言，近处我们需要更多的细节，而远处则可以稍微小一些，太多细节的反射对于我们而言没什么意义。 &emsp;&emsp;首先我们需要修改 Terrain.vs 和 Terrain.ps ，我们的每个顶点将携带两个纹理坐标，并且使用不同的纹理，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196////////////////////////////////////////////////////////////////////////////////// Filename: terrain.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL; float3 color : COLOR; float2 tex2 : TEXCOORD1;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL; float4 color : COLOR; float2 tex2 : TEXCOORD1; float4 depthPosition : TEXCOORD2;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType TerrainVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); // Calculate the tangent vector against the world matrix only and then normalize the final value. output.tangent = mul(input.tangent, (float3x3)worldMatrix); output.tangent = normalize(output.tangent); // Calculate the binormal vector against the world matrix only and then normalize the final value. output.binormal = mul(input.binormal, (float3x3)worldMatrix); output.binormal = normalize(output.binormal); output.color = float4(input.color , 1.0f); // Store the position value in a second input value for depth value calculations. output.depthPosition = output.position; return output;&#125;////////////////////////////////////////////////////////////////////////////////// Filename: terrain.ps/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////Texture2D diffuseTexture1 : register(t0);Texture2D normalTexture1 : register(t1);Texture2D normalTexture2 : register(t2);Texture2D normalTexture3 : register(t3);SamplerState SampleType : register(s0);//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer&#123; float4 diffuseColor; float3 lightDirection; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL; float4 color : COLOR; float2 tex2 : TEXCOORD1; float4 depthPosition : TEXCOORD2;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 TerrainPixelShader(PixelInputType input) : SV_TARGET&#123; float slope; float3 lightDir; float4 textureColor1; float4 textureColor2; float4 bumpMap; float3 bumpNormal; float lightIntensity; float4 material1; float4 material2; float blendAmount; float4 color; float depthValue; // Calculate the slope of this point. slope = 1.0f - input.normal.y; // Get the depth value of the pixel by dividing the Z pixel depth by the homogeneous W coordinate. depthValue = input.depthPosition.z / input.depthPosition.w; // Invert the light direction for calculations. lightDir = -lightDirection; // Setup the first material. textureColor1 = diffuseTexture1.Sample(SampleType, input.tex); // Select the normal map for the first material based on the distance. if(depthValue &gt; 0.998f) &#123; bumpMap = normalTexture3.Sample(SampleType, input.tex2); &#125; else &#123; bumpMap = normalTexture1.Sample(SampleType, input.tex); &#125; bumpMap = (bumpMap * 2.0f) - 1.0f; bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal); bumpNormal = normalize(bumpNormal); lightIntensity = saturate(dot(bumpNormal, lightDir)); material1 = saturate(textureColor1 * lightIntensity); // Setup the second material. textureColor2 = float4(1.0f, 1.0f, 1.0f, 1.0f); // Snow color. bumpMap = normalTexture2.Sample(SampleType, input.tex); bumpMap = (bumpMap * 2.0f) - 1.0f; bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal); bumpNormal = normalize(bumpNormal); lightIntensity = saturate(dot(bumpNormal, lightDir)); material2 = saturate(textureColor2 * lightIntensity); // Determine which material to use based on slope. if(slope &lt; 0.2) &#123; blendAmount = slope / 0.2f; color = lerp(material2, material1, blendAmount); &#125; if(slope &gt;= 0.2) &#123; color = material1; &#125; return color;&#125; &emsp;&emsp;之后，我们需要修改我们的 TerrainClass ，为其新增第二个纹理坐标的初始化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171bool TerrainClass::BuildTerrainModel() &#123; int i, j, index, index1, index2, index3, index4; float quadsCovered, incrementSize, tu2Left, tu2Right, tv2Bottom, tv2Top; // Calculate the number of vertices in the 3D terrain model. m_vertexCount = (m_terrainHeight - 1) * (m_terrainWidth - 1) * 6; // Create the 3D terrain model array. m_terrainModel = new ModelType[m_vertexCount]; if(!m_terrainModel) &#123; return false; &#125; // Setup the increment size for the second set of textures. // This is a fixed 33x33 vertex array per cell so there will be 32 rows of quads in a cell. quadsCovered = 32.0f; incrementSize = 1.0f / quadsCovered; // Initialize the texture increments. tu2Left = 0.0f; tu2Right = incrementSize; tv2Top = 0.0f; tv2Bottom = incrementSize; // Initialize the index into the height map array. index = 0; // Load the 3D terrain model with the height map terrain data. // We will be creating 2 triangles for each of the four points in a quad. for(j=0; j&lt;(m_terrainHeight-1); j++) &#123; for(i=0; i&lt;(m_terrainWidth-1); i++) &#123; // Get the indexes to the four points of the quad. index1 = (m_terrainWidth * j) + i; // Upper left. index2 = (m_terrainWidth * j) + (i+1); // Upper right. index3 = (m_terrainWidth * (j+1)) + i; // Bottom left. index4 = (m_terrainWidth * (j+1)) + (i+1); // Bottom right. // Now create two triangles for that quad. // Triangle 1 - Upper left. m_terrainModel[index].x = m_heightMap[index1].x; m_terrainModel[index].y = m_heightMap[index1].y; m_terrainModel[index].z = m_heightMap[index1].z; m_terrainModel[index].tu = 0.0f; m_terrainModel[index].tv = 0.0f; m_terrainModel[index].nx = m_heightMap[index1].nx; m_terrainModel[index].ny = m_heightMap[index1].ny; m_terrainModel[index].nz = m_heightMap[index1].nz; m_terrainModel[index].r = m_heightMap[index1].r; m_terrainModel[index].g = m_heightMap[index1].g; m_terrainModel[index].b = m_heightMap[index1].b; m_terrainModel[index].tu2 = tu2Left; m_terrainModel[index].tv2 = tv2Top; index++; // Triangle 1 - Upper right. m_terrainModel[index].x = m_heightMap[index2].x; m_terrainModel[index].y = m_heightMap[index2].y; m_terrainModel[index].z = m_heightMap[index2].z; m_terrainModel[index].tu = 1.0f; m_terrainModel[index].tv = 0.0f; m_terrainModel[index].nx = m_heightMap[index2].nx; m_terrainModel[index].ny = m_heightMap[index2].ny; m_terrainModel[index].nz = m_heightMap[index2].nz; m_terrainModel[index].r = m_heightMap[index2].r; m_terrainModel[index].g = m_heightMap[index2].g; m_terrainModel[index].b = m_heightMap[index2].b; m_terrainModel[index].tu2 = tu2Right; m_terrainModel[index].tv2 = tv2Top; index++; // Triangle 1 - Bottom left. m_terrainModel[index].x = m_heightMap[index3].x; m_terrainModel[index].y = m_heightMap[index3].y; m_terrainModel[index].z = m_heightMap[index3].z; m_terrainModel[index].tu = 0.0f; m_terrainModel[index].tv = 1.0f; m_terrainModel[index].nx = m_heightMap[index3].nx; m_terrainModel[index].ny = m_heightMap[index3].ny; m_terrainModel[index].nz = m_heightMap[index3].nz; m_terrainModel[index].r = m_heightMap[index3].r; m_terrainModel[index].g = m_heightMap[index3].g; m_terrainModel[index].b = m_heightMap[index3].b; m_terrainModel[index].tu2 = tu2Left; m_terrainModel[index].tv2 = tv2Bottom; index++; // Triangle 2 - Bottom left. m_terrainModel[index].x = m_heightMap[index3].x; m_terrainModel[index].y = m_heightMap[index3].y; m_terrainModel[index].z = m_heightMap[index3].z; m_terrainModel[index].tu = 0.0f; m_terrainModel[index].tv = 1.0f; m_terrainModel[index].nx = m_heightMap[index3].nx; m_terrainModel[index].ny = m_heightMap[index3].ny; m_terrainModel[index].nz = m_heightMap[index3].nz; m_terrainModel[index].r = m_heightMap[index3].r; m_terrainModel[index].g = m_heightMap[index3].g; m_terrainModel[index].b = m_heightMap[index3].b; m_terrainModel[index].tu2 = tu2Left; m_terrainModel[index].tv2 = tv2Bottom; index++; // Triangle 2 - Upper right. m_terrainModel[index].x = m_heightMap[index2].x; m_terrainModel[index].y = m_heightMap[index2].y; m_terrainModel[index].z = m_heightMap[index2].z; m_terrainModel[index].tu = 1.0f; m_terrainModel[index].tv = 0.0f; m_terrainModel[index].nx = m_heightMap[index2].nx; m_terrainModel[index].ny = m_heightMap[index2].ny; m_terrainModel[index].nz = m_heightMap[index2].nz; m_terrainModel[index].r = m_heightMap[index2].r; m_terrainModel[index].g = m_heightMap[index2].g; m_terrainModel[index].b = m_heightMap[index2].b; m_terrainModel[index].tu2 = tu2Right; m_terrainModel[index].tv2 = tv2Top; index++; // Triangle 2 - Bottom right. m_terrainModel[index].x = m_heightMap[index4].x; m_terrainModel[index].y = m_heightMap[index4].y; m_terrainModel[index].z = m_heightMap[index4].z; m_terrainModel[index].tu = 1.0f; m_terrainModel[index].tv = 1.0f; m_terrainModel[index].nx = m_heightMap[index4].nx; m_terrainModel[index].ny = m_heightMap[index4].ny; m_terrainModel[index].nz = m_heightMap[index4].nz; m_terrainModel[index].r = m_heightMap[index4].r; m_terrainModel[index].g = m_heightMap[index4].g; m_terrainModel[index].b = m_heightMap[index4].b; m_terrainModel[index].tu2 = tu2Right; m_terrainModel[index].tv2 = tv2Bottom; index++; // Increment the second tu texture coords. tu2Left += incrementSize; tu2Right += incrementSize; // Reset the second tu texture coordinate increments. if(tu2Right &gt; 1.0f) &#123; tu2Left = 0.0f; tu2Right = incrementSize; &#125; &#125; // Increment the second tv texture coords. tv2Top += incrementSize; tv2Bottom += incrementSize; // Reset the second tu texture coordinate increments. if(tv2Bottom &gt; 1.0f) &#123; tv2Top = 0.0f; tv2Bottom = incrementSize; &#125; &#125; return true;&#125; &emsp;&emsp;最后，修改 TerrainCellClass 以支持新的顶线属性，以及 TerrainShaderClass 支持新的顶点属性以及多一张纹理输入。 &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11TerrainTutorial-DistanceNormalMapping]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】14-程序纹理映射]]></title>
    <url>%2F2018%2F05%2F13%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%9114-%E7%A8%8B%E5%BA%8F%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 13: Procedural Terrain Texturing 学习记录&emsp;&emsp;这篇文章中我们介绍 Procedural terrain texturing ，本篇代码基于上一篇，仅有少量改动。 &emsp;&emsp;原教程中对于这篇描述如下： &emsp;&emsp;Procedural parameters are usually calculated in our shaders based on input textures or the terrain data itself. One of the most popular parameters is to use the height of the pixel being rendered and apply a texture using different height bands. In this way you can specify the ground texture to be below a certain height, then a rock texture for anything above that height, and finally a snow texture for anything in the final height range. Although this works the results are not entirely realistic. &emsp;&emsp;A more useful procedural parameter to use for determining which texture to apply is the use the slope of the current pixel. The slope can be easily calculated (one minus the Y normal) and has the properties of reflecting real world growth and deposition patterns. For example in this tutorial we use the slope to determine where the rock gets exposed, and everything less than that slope is covered with snow. This represents a real world pattern where anything with too much slope the snow will never accumulate on. Likewise this can be extended to growth patterns, erosion patterns, and so forth. &emsp;&emsp;其实就是选择性的对纹理进行贴图，我们这篇中的场景为雪山，在这里我们使用当前斜率来计算是否使用混合或者直接使用雪的纹理（当山体坡度大的时候没有积雪所以使用雪的纹理与地面纹理混合）。 &emsp;&emsp;主要修改 terrain.ps，使其支持三个纹理并且使用其法线判断混合或者覆盖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495////////////////////////////////////////////////////////////////////////////////// Filename: terrain.ps/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////Texture2D diffuseTexture1 : register(t0);Texture2D normalTexture1 : register(t1);Texture2D normalTexture2 : register(t2);SamplerState SampleType : register(s0);//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer&#123; float4 diffuseColor; float3 lightDirection; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL; float4 color : COLOR;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 TerrainPixelShader(PixelInputType input) : SV_TARGET&#123; float slope; float3 lightDir; float4 textureColor1; float4 textureColor2; float4 bumpMap; float3 bumpNormal; float lightIntensity; float4 material1; float4 material2; float blendAmount; float4 color; // Calculate the slope of this point. slope = 1.0f - input.normal.y; // Invert the light direction for calculations. lightDir = -lightDirection; // Setup the first material. textureColor1 = diffuseTexture1.Sample(SampleType, input.tex); bumpMap = normalTexture1.Sample(SampleType, input.tex); bumpMap = (bumpMap * 2.0f) - 1.0f; bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal); bumpNormal = normalize(bumpNormal); lightIntensity = saturate(dot(bumpNormal, lightDir)); material1 = saturate(textureColor1 * lightIntensity); // Setup the second material. textureColor2 = float4(1.0f, 1.0f, 1.0f, 1.0f); // Snow color. bumpMap = normalTexture2.Sample(SampleType, input.tex); bumpMap = (bumpMap * 2.0f) - 1.0f; bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal); bumpNormal = normalize(bumpNormal); lightIntensity = saturate(dot(bumpNormal, lightDir)); material2 = saturate(textureColor2 * lightIntensity); // Determine which material to use based on slope. if(slope &lt; 0.2) &#123; blendAmount = slope / 0.2f; color = lerp(material2, material1, blendAmount); &#125; if(slope &gt;= 0.2) &#123; color = material1; &#125; return color;&#125; &emsp;&emsp;其他的修改则只是为了支持新的 terrain.ps ，我们修改 TerrainShaderClass 使其支持三张纹理的渲染，同时修改 ShaderManagerClass 的对应函数。最后在 AoolicationClass 里读入新的纹理，读入的代码如下： 1234567891011121314151617181920// Load texture 0CHAR rock01d[] = "./data/rock01d.tga";result = m_TextureManager-&gt;LoadTexture(m_Direct3D-&gt;GetDevice(), m_Direct3D-&gt;GetDeviceContext(), rock01d , 0);if (!result) &#123; return false;&#125;// Load texture 1CHAR rock01n[] = "./data/rock01n.tga";result = m_TextureManager-&gt;LoadTexture(m_Direct3D-&gt;GetDevice(), m_Direct3D-&gt;GetDeviceContext(), rock01n , 1);if (!result) &#123; return false;&#125;// Load texture 2CHAR snow01n[] = "./data/snow01n.tga";result = m_TextureManager-&gt;LoadTexture(m_Direct3D-&gt;GetDevice(), m_Direct3D-&gt;GetDeviceContext(), snow01n , 2);if (!result) &#123; return false;&#125; &emsp;&emsp;最后，调用新的渲染方法： 12// Render the cell buffers using the terrain shader.result = ShaderManager-&gt;RenderTerrainShader(Direct3D-&gt;GetDeviceContext(), m_Terrain-&gt;GetCellIndexCount(i), worldMatrix, viewMatrix,projectionMatrix, TextureManager-&gt;GetTexture(0), TextureManager-&gt;GetTexture(1), TextureManager-&gt;GetTexture(2),m_Light-&gt;GetDirection(), m_Light-&gt;GetDiffuseColor()); &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11TerrainTutorial-ProceduralTerrainTexturing]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】13-小地图]]></title>
    <url>%2F2018%2F05%2F11%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%9113-%E5%B0%8F%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 12: Terrain Mini-Maps 学习记录&emsp;&emsp;这篇文章中我们介绍小地图的实现，我们将在右上角显示一个小地图并且在地图上实时显示我们摄像机的当前位置，本篇代码基于上一篇，新增 MiniMapClass ，并且使用了 BitmapClass 。 &emsp;&emsp;小地图的核心内容只是简单的渲染一个二维的纹理贴图在显示区右上角，然后计算使用当前摄像机的 x , z 坐标来渲染代表摄像机的小点。其类声明如下： 123456789101112131415161718192021222324252627282930313233343536////////////////////////////////////////////////////////////////////////////////// Filename: minimapclass.h////////////////////////////////////////////////////////////////////////////////#ifndef _MINIMAPCLASS_H_#define _MINIMAPCLASS_H_///////////////////////// MY CLASS INCLUDES /////////////////////////#include "bitmapclass.h"#include "shadermanagerclass.h"////////////////////////////////////////////////////////////////////////////////// Class name: MiniMapClass////////////////////////////////////////////////////////////////////////////////class MiniMapClass&#123;public: MiniMapClass(); MiniMapClass(const MiniMapClass&amp;); ~MiniMapClass(); bool Initialize(ID3D11Device*, ID3D11DeviceContext*, int, int, float, float); void Shutdown(); bool Render(ID3D11DeviceContext*, ShaderManagerClass*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX); void PositionUpdate(float, float);private: int m_mapLocationX, m_mapLocationY, m_pointLocationX, m_pointLocationY; float m_mapSizeX, m_mapSizeY, m_terrainWidth, m_terrainHeight; BitmapClass *m_MiniMapBitmap, *m_PointBitmap;&#125;;#endif &emsp;&emsp;可以看到我们要渲染的其实就是两个 BitmapClass 的对象，具体渲染在 Render 方法里： 1234567891011121314151617181920212223242526272829303132333435363738bool MiniMapClass::Render(ID3D11DeviceContext* deviceContext, ShaderManagerClass* ShaderManager, XMMATRIX worldMatrix, XMMATRIX viewMatrix, XMMATRIX orthoMatrix)&#123; bool result; // Put the mini-map bitmap vertex and index buffers on the graphics pipeline to prepare them for drawing. result = m_MiniMapBitmap-&gt;Render(deviceContext, m_mapLocationX, m_mapLocationY); if(!result) &#123; return false; &#125; // Render the mini-map bitmap using the texture shader. result = ShaderManager-&gt;RenderTextureShader(deviceContext, m_MiniMapBitmap-&gt;GetIndexCount(), worldMatrix, viewMatrix, orthoMatrix, m_MiniMapBitmap-&gt;GetTexture()); if(!result) &#123; return false; &#125; // Put the point bitmap vertex and index buffers on the graphics pipeline to prepare them for drawing. result = m_PointBitmap-&gt;Render(deviceContext, m_pointLocationX, m_pointLocationY); if(!result) &#123; return false; &#125; // Render the point bitmap using the texture shader. result = ShaderManager-&gt;RenderTextureShader(deviceContext, m_PointBitmap-&gt;GetIndexCount(), worldMatrix, viewMatrix, orthoMatrix, m_PointBitmap-&gt;GetTexture()); if(!result) &#123; return false; &#125; return true;&#125; &emsp;&emsp;在 PositionUpdate 方法里，我们根据实时的摄像机 x , z 坐标来计算我们的 point 在小地图上的位置： 12345678910111213141516171819202122232425262728293031323334353637383940void MiniMapClass::PositionUpdate(float positionX, float positionZ)&#123; float percentX, percentY; // Ensure the point does not leave the minimap borders even if the camera goes past the terrain borders. if(positionX &lt; 0) &#123; positionX = 0; &#125; if(positionZ &lt; 0) &#123; positionZ = 0; &#125; if(positionX &gt; m_terrainWidth) &#123; positionX = m_terrainWidth; &#125; if(positionZ &gt; m_terrainHeight) &#123; positionZ = m_terrainHeight; &#125; // Calculate the position of the camera on the minimap in terms of percentage. percentX = positionX / m_terrainWidth; percentY = 1.0f - (positionZ / m_terrainHeight); // Determine the pixel location of the point on the mini-map. m_pointLocationX = (m_mapLocationX + 2) + (int)(percentX * m_mapSizeX); m_pointLocationY = (m_mapLocationY + 2) + (int)(percentY * m_mapSizeY); // Subtract one from the location to center the point on the mini-map according to the 3x3 point pixel image size. m_pointLocationX = m_pointLocationX - 1; m_pointLocationY = m_pointLocationY - 1; return;&#125; &emsp;&emsp;最后，我们在 UserInterfaceClass 里新增 MiniMapClass 类的对象，并实现对其的渲染： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class UserInterfaceClass&#123;public: UserInterfaceClass(); UserInterfaceClass(const UserInterfaceClass&amp;); ~UserInterfaceClass(); bool Initialize(D3DClass*, int, int); void Shutdown(); bool Frame(ID3D11DeviceContext*, int, float, float, float, float, float, float); bool Render(D3DClass*, ShaderManagerClass*, XMMATRIX, XMMATRIX, XMMATRIX); bool UpdateRenderCounts(ID3D11DeviceContext*, int, int, int);private: bool UpdateFpsString(ID3D11DeviceContext*, int); bool UpdatePositionStrings(ID3D11DeviceContext*, float, float, float, float, float, float);private: FontClass* m_Font1; TextClass *m_FpsString, *m_VideoStrings, *m_PositionStrings , *m_RenderCountStrings; MiniMapClass* m_MiniMap; int m_previousFps; int m_previousPosition[6];&#125;;bool UserInterfaceClass::Render(D3DClass* Direct3D, ShaderManagerClass* ShaderManager, XMMATRIX worldMatrix, XMMATRIX viewMatrix, XMMATRIX orthoMatrix)&#123; int i; bool result; // Turn off the Z buffer and enable alpha blending to begin 2D rendering. Direct3D-&gt;TurnZBufferOff(); Direct3D-&gt;EnableAlphaBlending(); // Render the fps string. m_FpsString-&gt;Render(Direct3D-&gt;GetDeviceContext(), ShaderManager, worldMatrix, viewMatrix, orthoMatrix, m_Font1-&gt;GetTexture()); // Render the video card strings. m_VideoStrings[0].Render(Direct3D-&gt;GetDeviceContext(), ShaderManager, worldMatrix, viewMatrix, orthoMatrix, m_Font1-&gt;GetTexture()); m_VideoStrings[1].Render(Direct3D-&gt;GetDeviceContext(), ShaderManager, worldMatrix, viewMatrix, orthoMatrix, m_Font1-&gt;GetTexture()); // Render the position and rotation strings. for(i=0; i&lt;6; i++) &#123; m_PositionStrings[i].Render(Direct3D-&gt;GetDeviceContext(), ShaderManager, worldMatrix, viewMatrix, orthoMatrix, m_Font1-&gt;GetTexture()); &#125; // Render the render count strings. for(i=0; i&lt;3; i++) &#123; m_RenderCountStrings[i].Render(Direct3D-&gt;GetDeviceContext(), ShaderManager, worldMatrix, viewMatrix, orthoMatrix, m_Font1-&gt;GetTexture()); &#125; // Turn off alpha blending now that the text has been rendered. Direct3D-&gt;DisableAlphaBlending(); // Render the mini-map. result = m_MiniMap-&gt;Render(Direct3D-&gt;GetDeviceContext(), ShaderManager, worldMatrix, viewMatrix, orthoMatrix); if(!result) &#123; return false; &#125; // Turn the Z buffer back on now that the 2D rendering has completed. Direct3D-&gt;TurnZBufferOn(); return true;&#125; &emsp;&emsp;在 Frame 方法里我们调用 PositionUpdate 方法： 12345678910111213141516171819202122232425bool UserInterfaceClass::Frame(ID3D11DeviceContext* deviceContext, int fps, float posX, float posY, float posZ, float rotX, float rotY, float rotZ)&#123; bool result; // Update the fps string. result = UpdateFpsString(deviceContext, fps); if(!result) &#123; return false; &#125; // Update the position strings. result = UpdatePositionStrings(deviceContext, posX, posY, posZ, rotX, rotY, rotZ); if(!result) &#123; return false; &#125; // Update the mini-map position indicator. m_MiniMap-&gt;PositionUpdate(posX, posZ); return true;&#125; &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11TerrainTutorial-MiniMaps]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】12-基于地形高度的摄像机位移]]></title>
    <url>%2F2018%2F05%2F10%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%9112-%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%BD%A2%E9%AB%98%E5%BA%A6%E7%9A%84%E6%91%84%E5%83%8F%E6%9C%BA%E4%BD%8D%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 11: Height Based Movement 学习记录&emsp;&emsp;这篇文章中我们介绍基于地形高度的摄像机移动，本篇代码基于上一篇，修改很少。 &emsp;&emsp;在 TerrainClass 中，我们添加获得地形当前高度的接口 bool GetHeightAtPosition(float, float, float&amp;); ，传入 x , z 的值获得高度，其实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190bool TerrainClass::GetHeightAtPosition(float inputX, float inputZ, float&amp; height)&#123; int i, cellId, index; float vertex1[3], vertex2[3], vertex3[3]; bool foundHeight; float maxWidth, maxHeight, maxDepth, minWidth, minHeight, minDepth; // Loop through all of the terrain cells to find out which one the inputX and inputZ would be inside. cellId = -1; for(i=0; i&lt;m_cellCount; i++) &#123; // Get the current cell dimensions. m_TerrainCells[i].GetCellDimensions(maxWidth, maxHeight, maxDepth, minWidth, minHeight, minDepth); // Check to see if the positions are in this cell. if((inputX &lt; maxWidth) &amp;&amp; (inputX &gt; minWidth) &amp;&amp; (inputZ &lt; maxDepth) &amp;&amp; (inputZ &gt; minDepth)) &#123; cellId = i; i = m_cellCount; &#125; &#125; // If we didn't find a cell then the input position is off the terrain grid. if(cellId == -1) &#123; return false; &#125; // If this is the right cell then check all the triangles in this cell to see what the height of the triangle at this position is. for(i=0; i&lt;(m_TerrainCells[cellId].GetVertexCount() / 3); i++) &#123; index = i * 3; vertex1[0] = m_TerrainCells[cellId].m_vertexList[index].x; vertex1[1] = m_TerrainCells[cellId].m_vertexList[index].y; vertex1[2] = m_TerrainCells[cellId].m_vertexList[index].z; index++; vertex2[0] = m_TerrainCells[cellId].m_vertexList[index].x; vertex2[1] = m_TerrainCells[cellId].m_vertexList[index].y; vertex2[2] = m_TerrainCells[cellId].m_vertexList[index].z; index++; vertex3[0] = m_TerrainCells[cellId].m_vertexList[index].x; vertex3[1] = m_TerrainCells[cellId].m_vertexList[index].y; vertex3[2] = m_TerrainCells[cellId].m_vertexList[index].z; // Check to see if this is the polygon we are looking for. foundHeight = CheckHeightOfTriangle(inputX, inputZ, height, vertex1, vertex2, vertex3); if(foundHeight) &#123; return true; &#125; &#125; return false;&#125;bool TerrainClass::CheckHeightOfTriangle(float x, float z, float&amp; height, float v0[3], float v1[3], float v2[3])&#123; float startVector[3], directionVector[3], edge1[3], edge2[3], normal[3]; float Q[3], e1[3], e2[3], e3[3], edgeNormal[3], temp[3]; float magnitude, D, denominator, numerator, t, determinant; // Starting position of the ray that is being cast. startVector[0] = x; startVector[1] = 0.0f; startVector[2] = z; // The direction the ray is being cast. directionVector[0] = 0.0f; directionVector[1] = -1.0f; directionVector[2] = 0.0f; // Calculate the two edges from the three points given. edge1[0] = v1[0] - v0[0]; edge1[1] = v1[1] - v0[1]; edge1[2] = v1[2] - v0[2]; edge2[0] = v2[0] - v0[0]; edge2[1] = v2[1] - v0[1]; edge2[2] = v2[2] - v0[2]; // Calculate the normal of the triangle from the two edges. normal[0] = (edge1[1] * edge2[2]) - (edge1[2] * edge2[1]); normal[1] = (edge1[2] * edge2[0]) - (edge1[0] * edge2[2]); normal[2] = (edge1[0] * edge2[1]) - (edge1[1] * edge2[0]); magnitude = (float)sqrt((normal[0] * normal[0]) + (normal[1] * normal[1]) + (normal[2] * normal[2])); normal[0] = normal[0] / magnitude; normal[1] = normal[1] / magnitude; normal[2] = normal[2] / magnitude; // Find the distance from the origin to the plane. D = ((-normal[0] * v0[0]) + (-normal[1] * v0[1]) + (-normal[2] * v0[2])); // Get the denominator of the equation. denominator = ((normal[0] * directionVector[0]) + (normal[1] * directionVector[1]) + (normal[2] * directionVector[2])); // Make sure the result doesn't get too close to zero to prevent divide by zero. if(fabs(denominator) &lt; 0.0001f) &#123; return false; &#125; // Get the numerator of the equation. numerator = -1.0f * (((normal[0] * startVector[0]) + (normal[1] * startVector[1]) + (normal[2] * startVector[2])) + D); // Calculate where we intersect the triangle. t = numerator / denominator; // Find the intersection vector. Q[0] = startVector[0] + (directionVector[0] * t); Q[1] = startVector[1] + (directionVector[1] * t); Q[2] = startVector[2] + (directionVector[2] * t); // Find the three edges of the triangle. e1[0] = v1[0] - v0[0]; e1[1] = v1[1] - v0[1]; e1[2] = v1[2] - v0[2]; e2[0] = v2[0] - v1[0]; e2[1] = v2[1] - v1[1]; e2[2] = v2[2] - v1[2]; e3[0] = v0[0] - v2[0]; e3[1] = v0[1] - v2[1]; e3[2] = v0[2] - v2[2]; // Calculate the normal for the first edge. edgeNormal[0] = (e1[1] * normal[2]) - (e1[2] * normal[1]); edgeNormal[1] = (e1[2] * normal[0]) - (e1[0] * normal[2]); edgeNormal[2] = (e1[0] * normal[1]) - (e1[1] * normal[0]); // Calculate the determinant to see if it is on the inside, outside, or directly on the edge. temp[0] = Q[0] - v0[0]; temp[1] = Q[1] - v0[1]; temp[2] = Q[2] - v0[2]; determinant = ((edgeNormal[0] * temp[0]) + (edgeNormal[1] * temp[1]) + (edgeNormal[2] * temp[2])); // Check if it is outside. if(determinant &gt; 0.001f) &#123; return false; &#125; // Calculate the normal for the second edge. edgeNormal[0] = (e2[1] * normal[2]) - (e2[2] * normal[1]); edgeNormal[1] = (e2[2] * normal[0]) - (e2[0] * normal[2]); edgeNormal[2] = (e2[0] * normal[1]) - (e2[1] * normal[0]); // Calculate the determinant to see if it is on the inside, outside, or directly on the edge. temp[0] = Q[0] - v1[0]; temp[1] = Q[1] - v1[1]; temp[2] = Q[2] - v1[2]; determinant = ((edgeNormal[0] * temp[0]) + (edgeNormal[1] * temp[1]) + (edgeNormal[2] * temp[2])); // Check if it is outside. if (determinant &gt; 0.001f) &#123; return false; &#125; // Calculate the normal for the third edge. edgeNormal[0] = (e3[1] * normal[2]) - (e3[2] * normal[1]); edgeNormal[1] = (e3[2] * normal[0]) - (e3[0] * normal[2]); edgeNormal[2] = (e3[0] * normal[1]) - (e3[1] * normal[0]); // Calculate the determinant to see if it is on the inside, outside, or directly on the edge. temp[0] = Q[0] - v2[0]; temp[1] = Q[1] - v2[1]; temp[2] = Q[2] - v2[2]; determinant = ((edgeNormal[0] * temp[0]) + (edgeNormal[1] * temp[1]) + (edgeNormal[2] * temp[2])); // Check if it is outside. if(determinant &gt; 0.001f) &#123; return false; &#125; // Now we have our height. height = Q[1]; return true;&#125; &emsp;&emsp;最后我们在 ZoneClass 里，每一帧设置摄像机的位置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool ZoneClass::Frame(D3DClass* Direct3D, InputClass* Input, ShaderManagerClass* ShaderManager , TextureManagerClass* TextureManager, float frameTime, int fps)&#123; bool result; float posX, posY, posZ, rotX, rotY, rotZ , height; bool foundHeight; static float prevHeight = 0; // Do the frame input processing. HandleMovementInput(Input, frameTime); // Get the view point position/rotation. m_Position-&gt;GetPosition(posX, posY, posZ); m_Position-&gt;GetRotation(rotX, rotY, rotZ); // Do the frame processing for the user interface. result = m_UserInterface-&gt;Frame(Direct3D-&gt;GetDeviceContext(), fps, posX, posY, posZ, rotX, rotY, rotZ); if(!result) &#123; return false; &#125; // Do the terrain frame processing. m_Terrain-&gt;Frame(); // If the height is locked to the terrain then position the camera on top of it. if(m_heightLocked) &#123; posY -= prevHeight; // Get the height of the triangle that is directly underneath the given camera position. foundHeight = m_Terrain-&gt;GetHeightAtPosition(posX, posZ, height); if(foundHeight) &#123; // If there was a triangle under the camera then position the camera just above it by three meters. m_Position-&gt;SetPosition(posX, height + posY, posZ); m_Camera-&gt;SetPosition(posX, height + posY, posZ); prevHeight = height; &#125; &#125; // Render the graphics. result = Render(Direct3D, ShaderManager , TextureManager); if(!result) &#123; return false; &#125; return true;&#125; &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11TerrainTutorial-HeightBasedMovement]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】11-基于Cell的裁剪]]></title>
    <url>%2F2018%2F05%2F09%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%9111-%E5%9F%BA%E4%BA%8ECell%E7%9A%84%E8%A3%81%E5%89%AA%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 10: Terrain Cell Culling 学习记录&emsp;&emsp;这篇文章中我们介绍基于 Cell 的裁剪，本篇会使用到我们之前介绍的裁剪技术：【DirectX】21-视锥裁剪 。代码修改幅度并不大。 &emsp;&emsp;首先来看我们的裁剪类，我们既然使用立方体 Cell ，那么自然使用包围盒裁剪，裁剪类声明如下： 123456789101112131415161718192021222324////////////////////////////////////////////////////////////////////////////////// Class name: FrustumClass////////////////////////////////////////////////////////////////////////////////class FrustumClass&#123;public: FrustumClass(); FrustumClass(const FrustumClass&amp;); ~FrustumClass(); void Initialize(float); void ConstructFrustum(XMMATRIX, XMMATRIX); bool CheckPoint(float, float, float); bool CheckCube(float, float, float, float); bool CheckSphere(float, float, float, float); bool CheckRectangle(float, float, float, float, float, float); bool CheckRectangle2(float, float, float, float, float, float);private: float m_screenDepth; float m_planes[6][4];&#125;; &emsp;&emsp;在 TerrainClass 中我们新增多个变量以及方法，主要是增加了对裁剪/渲染的数量进行封装以及裁剪的执行，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101////////////////////////////////////////////////////////////////////////////////// Class name: TerrainClass////////////////////////////////////////////////////////////////////////////////class TerrainClass&#123;private: struct VertexType &#123; XMFLOAT3 position; XMFLOAT2 texcoord; XMFLOAT3 normal; XMFLOAT3 tangent; XMFLOAT3 binormal; XMFLOAT3 color; &#125;; struct HeightMapType &#123; float x, y, z; float nx, ny, nz; float r, g, b; &#125;; struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; float tx, ty, tz; float bx, by, bz; float r, g, b; &#125;; struct VectorType &#123; float x, y, z; &#125;; struct TempVertexType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;;public: TerrainClass(); TerrainClass(const TerrainClass&amp;); ~TerrainClass(); bool Initialize(ID3D11Device* , char*); void Shutdown(); bool Render(ID3D11DeviceContext*); int GetIndexCount(); void Frame(); bool RenderCell(ID3D11DeviceContext*, int, FrustumClass*); void RenderCellLines(ID3D11DeviceContext*, int); int GetCellIndexCount(int); int GetCellLinesIndexCount(int); int GetCellCount(); int GetRenderCount(); int GetCellsDrawn(); int GetCellsCulled();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); void CalculateTerrainVectors(); void CalculateTangentBinormal(TempVertexType, TempVertexType, TempVertexType, VectorType&amp;, VectorType&amp;); bool LoadColorMap(); bool CalculateNormals(); bool LoadSetupFile(CHAR*); bool LoadBitmapHeightMap(); bool LoadRawHeightMap(); void ShutdownHeightMap(); void SetTerrainCoordinates(); bool BuildTerrainModel(); void ShutdownTerrainModel(); bool LoadTerrainCells(ID3D11Device*); void ShutdownTerrainCells();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount; int m_terrainHeight , m_terrainWidth; float m_heightScale; LPSTR m_terrainFilename; LPSTR m_colorMapFilename; HeightMapType* m_heightMap; ModelType* m_terrainModel; TerrainCellClass* m_TerrainCells; int m_cellCount, m_renderCount, m_cellsDrawn, m_cellsCulled;&#125;; &emsp;&emsp;在 RenderCell 函数中，调用裁剪类的方法进行裁剪计算，我们将只渲染能看到的部分 Cell： 123456789101112131415161718192021222324252627282930bool TerrainClass::RenderCell(ID3D11DeviceContext* deviceContext, int cellId, FrustumClass* Frustum)&#123; float maxWidth, maxHeight, maxDepth, minWidth, minHeight, minDepth; bool result; // Get the dimensions of the terrain cell. m_TerrainCells[cellId].GetCellDimensions(maxWidth, maxHeight, maxDepth, minWidth, minHeight, minDepth); // Check if the cell is visible. If it is not visible then just return and don't render it. result = Frustum-&gt;CheckRectangle2(maxWidth, maxHeight, maxDepth, minWidth, minHeight, minDepth); if(!result) &#123; // Increment the number of cells that were culled. m_cellsCulled++; return false; &#125; // If it is visible then render it. m_TerrainCells[cellId].Render(deviceContext); // Add the polygons in the cell to the render count. m_renderCount += (m_TerrainCells[cellId].GetVertexCount() / 3); // Increment the number of cells that were actually drawn. m_cellsDrawn++; return true;&#125; &emsp;&emsp;在 ZoneClass 中我们正常的渲染即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110bool ZoneClass::Render(D3DClass* Direct3D, ShaderManagerClass* ShaderManager , TextureManagerClass* TextureManager)&#123; XMMATRIX worldMatrix, viewMatrix, projectionMatrix, baseViewMatrix, orthoMatrix; bool result; XMFLOAT3 cameraPosition; // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Get the world, view, and projection matrices from the camera and d3d objects. Direct3D-&gt;GetWorldMatrix(worldMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); Direct3D-&gt;GetProjectionMatrix(projectionMatrix); m_Camera-&gt;GetBaseViewMatrix(baseViewMatrix); Direct3D-&gt;GetOrthoMatrix(orthoMatrix); // Get the position of the camera. cameraPosition = m_Camera-&gt;GetPosition(); // Construct the frustum. m_Frustum-&gt;ConstructFrustum(projectionMatrix, viewMatrix); // Clear the buffers to begin the scene. Direct3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); // Turn off back face culling and turn off the Z buffer. Direct3D-&gt;TurnOffCulling(); Direct3D-&gt;TurnZBufferOff(); // Translate the sky dome to be centered around the camera position. worldMatrix = XMMatrixTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z); // Render the sky dome using the sky dome shader. m_SkyDome-&gt;Render(Direct3D-&gt;GetDeviceContext()); result = ShaderManager-&gt;RenderSkydomeShader(Direct3D-&gt;GetDeviceContext(), m_SkyDome-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_SkyDome-&gt;GetApexColor(), m_SkyDome-&gt;GetCenterColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. Direct3D-&gt;GetWorldMatrix(worldMatrix); // Turn the Z buffer back and back face culling on. Direct3D-&gt;TurnZBufferOn(); Direct3D-&gt;TurnOnCulling(); if (m_wireFrame) &#123; Direct3D-&gt;EnableWireframe(); &#125; // Render the terrain cells (and cell lines if needed). for(auto i=0; i&lt;m_Terrain-&gt;GetCellCount(); i++) &#123; // Render each terrain cell if it is visible only. result = m_Terrain-&gt;RenderCell(Direct3D-&gt;GetDeviceContext(), i, m_Frustum); if(result) &#123; // Render the cell buffers using the terrain shader. result = ShaderManager-&gt;RenderTerrainShader(Direct3D-&gt;GetDeviceContext(), m_Terrain-&gt;GetCellIndexCount(i), worldMatrix, viewMatrix, projectionMatrix, TextureManager-&gt;GetTexture(0), TextureManager-&gt;GetTexture(1), m_Light-&gt;GetDirection(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // If needed then render the bounding box around this terrain cell using the color shader. if(m_cellLines) &#123; m_Terrain-&gt;RenderCellLines(Direct3D-&gt;GetDeviceContext(), i); ShaderManager-&gt;RenderColorShader(Direct3D-&gt;GetDeviceContext(), m_Terrain-&gt;GetCellLinesIndexCount(i), worldMatrix, viewMatrix, projectionMatrix); if(!result) &#123; return false; &#125; &#125; &#125; &#125; if (m_wireFrame) &#123; Direct3D-&gt;DisableWireframe(); &#125; // Update the render counts in the UI. result = m_UserInterface-&gt;UpdateRenderCounts(Direct3D-&gt;GetDeviceContext(), m_Terrain-&gt;GetRenderCount(), m_Terrain-&gt;GetCellsDrawn(), m_Terrain-&gt;GetCellsCulled()); if(!result) &#123; return false; &#125; // Render the user interface. if(m_displayUI) &#123; result = m_UserInterface-&gt;Render(Direct3D, ShaderManager, worldMatrix, baseViewMatrix, orthoMatrix); if(!result) &#123; return false; &#125; &#125; // Present the rendered scene to the screen. Direct3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;最终效果： &emsp;&emsp;可以看我们新增的 UI 显示来了解裁剪情况 &emsp;&emsp;源代码：DX11TerrainTutorial-TerrainCellCulling]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】10-地形分块]]></title>
    <url>%2F2018%2F05%2F08%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%9110-%E5%9C%B0%E5%BD%A2%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 9: Terrain Cells 学习记录&emsp;&emsp;这篇文章中我们简单介绍对地形进行划分，完整的地形网格分为多块来进行管理，本篇新增类：TerrainCellClass 。 &emsp;&emsp;首先来看我们 TerrainCellClass 类的声明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586////////////////////////////////////////////////////////////////////////////////// Filename: terraincellclass.h////////////////////////////////////////////////////////////////////////////////#ifndef _TERRAINCELLCLASS_H_#define _TERRAINCELLCLASS_H_//////////////// INCLUDES ////////////////#include &lt;d3d11.h&gt;#include &lt;directxmath.h&gt;using namespace DirectX;////////////////////////////////////////////////////////////////////////////////// Class name: TerrainCellClass////////////////////////////////////////////////////////////////////////////////class TerrainCellClass&#123;private: struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; float tx, ty, tz; float bx, by, bz; float r, g, b; &#125;; struct VertexType &#123; XMFLOAT3 position; XMFLOAT2 texture; XMFLOAT3 normal; XMFLOAT3 tangent; XMFLOAT3 binormal; XMFLOAT3 color; &#125;; struct VectorType &#123; float x, y, z; &#125;; struct ColorVertexType &#123; XMFLOAT3 position; XMFLOAT4 color; &#125;;public: TerrainCellClass(); TerrainCellClass(const TerrainCellClass&amp;); ~TerrainCellClass(); bool Initialize(ID3D11Device*, void*, int, int, int, int, int); void Shutdown(); void Render(ID3D11DeviceContext*); void RenderLineBuffers(ID3D11DeviceContext*); int GetVertexCount(); int GetIndexCount(); int GetLineBuffersIndexCount(); void GetCellDimensions(float&amp;, float&amp;, float&amp;, float&amp;, float&amp;, float&amp;);private: bool InitializeBuffers(ID3D11Device*, int, int, int, int, int, ModelType*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); void CalculateCellDimensions(); bool BuildLineBuffers(ID3D11Device*); void ShutdownLineBuffers();public: VectorType* m_vertexList;private: int m_vertexCount, m_indexCount, m_lineIndexCount; ID3D11Buffer *m_vertexBuffer, *m_indexBuffer, *m_lineVertexBuffer, *m_lineIndexBuffer;; float m_maxWidth, m_maxHeight, m_maxDepth, m_minWidth, m_minHeight, m_minDepth; float m_positionX, m_positionY, m_positionZ;&#125;;#endif &emsp;&emsp;也是一个模型类，他使用 LINE 作为绘制图元来绘制，用我们传进来的 TerrainClass 的定点属性来生成顶点信息。其部分实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388bool TerrainCellClass::InitializeBuffers(ID3D11Device* device, int nodeIndexX, int nodeIndexY, int cellHeight, int cellWidth, int terrainWidth, ModelType* terrainModel)&#123; VertexType* vertices; unsigned long* indices; int i, j, modelIndex, index; D3D11_BUFFER_DESC vertexBufferDesc, indexBufferDesc; D3D11_SUBRESOURCE_DATA vertexData, indexData; HRESULT result; // Calculate the number of vertices in this terrain cell. m_vertexCount = (cellHeight - 1) * (cellWidth - 1) * 6; // Set the index count to the same as the vertex count. m_indexCount = m_vertexCount; // Create the vertex array. vertices = new VertexType[m_vertexCount]; if(!vertices) &#123; return false; &#125; // Create the index array. indices = new unsigned long[m_indexCount]; if(!indices) &#123; return false; &#125; // Setup the indexes into the terrain model data and the local vertex/index array. modelIndex = ((nodeIndexX * (cellWidth - 1)) + (nodeIndexY * (cellHeight - 1) * (terrainWidth - 1))) * 6; index = 0; // Load the vertex array and index array with data. for(j=0; j&lt;(cellHeight - 1); j++) &#123; for(i=0; i&lt;((cellWidth - 1) * 6); i++) &#123; vertices[index].position = XMFLOAT3(terrainModel[modelIndex].x, terrainModel[modelIndex].y, terrainModel[modelIndex].z); vertices[index].texture = XMFLOAT2(terrainModel[modelIndex].tu, terrainModel[modelIndex].tv); vertices[index].normal = XMFLOAT3(terrainModel[modelIndex].nx, terrainModel[modelIndex].ny, terrainModel[modelIndex].nz); vertices[index].tangent = XMFLOAT3(terrainModel[modelIndex].tx, terrainModel[modelIndex].ty, terrainModel[modelIndex].tz); vertices[index].binormal = XMFLOAT3(terrainModel[modelIndex].bx, terrainModel[modelIndex].by, terrainModel[modelIndex].bz); vertices[index].color = XMFLOAT3(terrainModel[modelIndex].r, terrainModel[modelIndex].g, terrainModel[modelIndex].b); indices[index] = index; modelIndex++; index++; &#125; modelIndex += (terrainWidth * 6) - (cellWidth * 6); &#125; // Set up the description of the static vertex buffer. vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT; vertexBufferDesc.ByteWidth = sizeof(VertexType) * m_vertexCount; vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; vertexBufferDesc.CPUAccessFlags = 0; vertexBufferDesc.MiscFlags = 0; vertexBufferDesc.StructureByteStride = 0; // Give the subresource structure a pointer to the vertex data. vertexData.pSysMem = vertices; vertexData.SysMemPitch = 0; vertexData.SysMemSlicePitch = 0; // Now create the vertex buffer. result = device-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;vertexData, &amp;m_vertexBuffer); if(FAILED(result)) &#123; return false; &#125; // Set up the description of the static index buffer. indexBufferDesc.Usage = D3D11_USAGE_DEFAULT; indexBufferDesc.ByteWidth = sizeof(unsigned long) * m_indexCount; indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER; indexBufferDesc.CPUAccessFlags = 0; indexBufferDesc.MiscFlags = 0; indexBufferDesc.StructureByteStride = 0; // Give the subresource structure a pointer to the index data. indexData.pSysMem = indices; indexData.SysMemPitch = 0; indexData.SysMemSlicePitch = 0; // Create the index buffer. result = device-&gt;CreateBuffer(&amp;indexBufferDesc, &amp;indexData, &amp;m_indexBuffer); if(FAILED(result)) &#123; return false; &#125; // Create a public vertex array that will be used for accessing vertex information about this cell. m_vertexList = new VectorType[m_vertexCount]; if(!m_vertexList) &#123; return false; &#125; // Keep a local copy of the vertex position data for this cell. for(i=0; i&lt;m_vertexCount; i++) &#123; m_vertexList[i].x = vertices[i].position.x; m_vertexList[i].y = vertices[i].position.y; m_vertexList[i].z = vertices[i].position.z; &#125; // Release the arrays now that the buffers have been created and loaded. delete [] vertices; vertices = 0; delete [] indices; indices = 0; return true;&#125;void TerrainCellClass::CalculateCellDimensions()&#123; int i; float width, height, depth; // Initialize the dimensions of the node. m_maxWidth = -1000000.0f; m_maxHeight = -1000000.0f; m_maxDepth = -1000000.0f; m_minWidth = 1000000.0f; m_minHeight = 1000000.0f; m_minDepth = 1000000.0f; for(i=0; i&lt;m_vertexCount; i++) &#123; width = m_vertexList[i].x; height = m_vertexList[i].y; depth = m_vertexList[i].z; // Check if the width exceeds the minimum or maximum. if(width &gt; m_maxWidth) &#123; m_maxWidth = width; &#125; if(width &lt; m_minWidth) &#123; m_minWidth = width; &#125; // Check if the height exceeds the minimum or maximum. if(height &gt; m_maxHeight) &#123; m_maxHeight = height; &#125; if(height &lt; m_minHeight) &#123; m_minHeight = height; &#125; // Check if the depth exceeds the minimum or maximum. if(depth &gt; m_maxDepth) &#123; m_maxDepth = depth; &#125; if(depth &lt; m_minDepth) &#123; m_minDepth = depth; &#125; &#125; // Calculate the center position of this cell. m_positionX = (m_maxWidth - m_minWidth) + m_minWidth; m_positionY = (m_maxHeight - m_minHeight) + m_minHeight; m_positionZ = (m_maxDepth - m_minDepth) + m_minDepth; return;&#125;bool TerrainCellClass::BuildLineBuffers(ID3D11Device* device)&#123; ColorVertexType* vertices; unsigned long* indices; D3D11_BUFFER_DESC vertexBufferDesc, indexBufferDesc; D3D11_SUBRESOURCE_DATA vertexData, indexData; HRESULT result; XMFLOAT4 lineColor; int index, vertexCount, indexCount; // Set the color of the lines to orange. lineColor = XMFLOAT4(1.0f, 0.5f, 0.0f, 1.0f); // Set the number of vertices in the vertex array. vertexCount = 24; // Set the number of indices in the index array. indexCount = vertexCount; // Create the vertex array. vertices = new ColorVertexType[vertexCount]; if(!vertices) &#123; return false; &#125; // Create the index array. indices = new unsigned long[indexCount]; if(!indices) &#123; return false; &#125; // Set up the description of the vertex buffer. vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT; vertexBufferDesc.ByteWidth = sizeof(ColorVertexType) * vertexCount; vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; vertexBufferDesc.CPUAccessFlags = 0; vertexBufferDesc.MiscFlags = 0; vertexBufferDesc.StructureByteStride = 0; // Give the subresource structure a pointer to the vertex data. vertexData.pSysMem = vertices; vertexData.SysMemPitch = 0; vertexData.SysMemSlicePitch = 0; // Set up the description of the index buffer. indexBufferDesc.Usage = D3D11_USAGE_DEFAULT; indexBufferDesc.ByteWidth = sizeof(unsigned long) * indexCount; indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER; indexBufferDesc.CPUAccessFlags = 0; indexBufferDesc.MiscFlags = 0; indexBufferDesc.StructureByteStride = 0; // Give the subresource structure a pointer to the index data. indexData.pSysMem = indices; indexData.SysMemPitch = 0; indexData.SysMemSlicePitch = 0; // Load the vertex and index array with data. index = 0; // 8 Horizontal lines. vertices[index].position = XMFLOAT3(m_minWidth, m_minHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_minHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_minHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_minHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_minHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_minHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_minHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_minHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_maxHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_maxHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_maxHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_maxHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_maxHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_maxHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_maxHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_maxHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; // 4 Verticle lines. vertices[index].position = XMFLOAT3(m_maxWidth, m_maxHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_minHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_maxHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_minHeight, m_maxDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_maxHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_maxWidth, m_minHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_maxHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; index++; vertices[index].position = XMFLOAT3(m_minWidth, m_minHeight, m_minDepth); vertices[index].color = lineColor; indices[index] = index; // Create the vertex buffer. result = device-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;vertexData, &amp;m_lineVertexBuffer); if(FAILED(result)) &#123; return false; &#125; // Create the index buffer. result = device-&gt;CreateBuffer(&amp;indexBufferDesc, &amp;indexData, &amp;m_lineIndexBuffer); if(FAILED(result)) &#123; return false; &#125; // Store the index count for rendering. m_lineIndexCount = indexCount; // Release the arrays now that the vertex and index buffers have been created and loaded. delete [] vertices; vertices = 0; delete [] indices; indices = 0; return true;&#125; &emsp;&emsp;在 TerrainClass 中我们使用 TerrainCellClass 类的对象数组，以及一些方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495////////////////////////////////////////////////////////////////////////////////// Class name: TerrainClass////////////////////////////////////////////////////////////////////////////////class TerrainClass&#123;private: struct VertexType &#123; XMFLOAT3 position; XMFLOAT2 texcoord; XMFLOAT3 normal; XMFLOAT3 tangent; XMFLOAT3 binormal; XMFLOAT3 color; &#125;; struct HeightMapType &#123; float x, y, z; float nx, ny, nz; float r, g, b; &#125;; struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; float tx, ty, tz; float bx, by, bz; float r, g, b; &#125;; struct VectorType &#123; float x, y, z; &#125;; struct TempVertexType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;;public: TerrainClass(); TerrainClass(const TerrainClass&amp;); ~TerrainClass(); bool Initialize(ID3D11Device* , char*); void Shutdown(); bool Render(ID3D11DeviceContext*); int GetIndexCount(); bool RenderCell(ID3D11DeviceContext*, int); void RenderCellLines(ID3D11DeviceContext*, int); int GetCellIndexCount(int); int GetCellLinesIndexCount(int); int GetCellCount();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); void CalculateTerrainVectors(); void CalculateTangentBinormal(TempVertexType, TempVertexType, TempVertexType, VectorType&amp;, VectorType&amp;); bool LoadColorMap(); bool CalculateNormals(); bool LoadSetupFile(CHAR*); bool LoadBitmapHeightMap(); bool LoadRawHeightMap(); void ShutdownHeightMap(); void SetTerrainCoordinates(); bool BuildTerrainModel(); void ShutdownTerrainModel(); bool LoadTerrainCells(ID3D11Device*); void ShutdownTerrainCells();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount; int m_terrainHeight , m_terrainWidth; float m_heightScale; LPSTR m_terrainFilename; LPSTR m_colorMapFilename; HeightMapType* m_heightMap; ModelType* m_terrainModel; TerrainCellClass* m_TerrainCells; int m_cellCount;&#125;; &emsp;&emsp;最后在渲染地形的时候，我们选择性的对 TerrainCell 进行渲染，最终效果如下： &emsp;&emsp;源代码：DX11TerrainTutorial-TerrainCells]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】9-16位高度图]]></title>
    <url>%2F2018%2F05%2F07%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%919-16%E4%BD%8D%E9%AB%98%E5%BA%A6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 8: RAW Height Maps 学习记录&emsp;&emsp;这篇文章中我们介绍使用16位高度图实现的较为精细的地形，本篇代码基于上一篇，无新增类。 &emsp;&emsp;这篇中我们仅仅修改了 TerrainClass 类和 Setup.txt 文件，在 TerrainClass 中我们使用新的 LoadRawHeightMap() 方法来代替之前的 LoadBitmapHeightMap() ，由于我们新的高度图是一张存储高度的图片，所以读取的话只为 y 轴赋值，方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768bool TerrainClass::LoadRawHeightMap()&#123; int error, i, j, index; FILE* filePtr; unsigned long long imageSize, count; unsigned short* rawImage; // Create the float array to hold the height map data. m_heightMap = new HeightMapType[m_terrainWidth * m_terrainHeight]; if (!m_heightMap) &#123; return false; &#125; // Open the 16 bit raw height map file for reading in binary. error = fopen_s(&amp;filePtr, m_terrainFilename, "rb"); if (error != 0) &#123; return false; &#125; // Calculate the size of the raw image data. imageSize = m_terrainHeight * m_terrainWidth; // Allocate memory for the raw image data. rawImage = new unsigned short[imageSize]; if(!rawImage) &#123; return false; &#125; // Read in the raw image data. count = fread(rawImage, sizeof(unsigned short), imageSize, filePtr); if(count != imageSize) &#123; return false; &#125; // Close the file. error = fclose(filePtr); if(error != 0) &#123; return false; &#125; // Copy the image data into the height map array. for(j=0; j&lt;m_terrainHeight; j++) &#123; for(i=0; i&lt;m_terrainWidth; i++) &#123; index = (m_terrainWidth * j) + i; // Store the height at this point in the height map array. m_heightMap[index].y = (float)rawImage[index]; &#125; &#125; // Release the bitmap image data. delete [] rawImage; rawImage = 0; // Release the terrain filename now that it has been read in. delete [] m_terrainFilename; m_terrainFilename = 0; return true;&#125; &emsp;&emsp;同时我们将修改 Setup.txt 文件，渲染一张更大的地图： 12345Terrain Filename: ./data/heightmap.r16Terrain Filename: ./data/colormap.bmpTerrain Height: 1025Terrain Width: 1025Terrain Scaling: 300.0 &emsp;&emsp;在 Initialize 方法里，使用 LoadRawHeightMap 代替 LoadBitmapHeightMap ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bool TerrainClass::Initialize(ID3D11Device* device , char* setupFileName)&#123; bool result; // Get the terrain filename , dimensions , and so forth from the setup file result = LoadSetupFile(setupFileName); if (!result) &#123; return false; &#125; // Initialize the terrain height map with the data from the raw file. result = LoadRawHeightMap(); if(!result) &#123; return false; &#125;// result = LoadBitmapHeightMap();// if (!result) &#123;// return false;// &#125; SetTerrainCoordinates(); // Calculate the normals for the terrain data. result = CalculateNormals(); if(!result) &#123; return false; &#125; // Load in the color map for the terrain. result = LoadColorMap(); if(!result) &#123; return false; &#125; result = BuildTerrainModel(); if (!result) &#123; return false; &#125; // We can now release the height map since it is no longer needed in memory once the 3D terrain model has been built. ShutdownHeightMap(); // Calculate the tangent and binormal for the terrain model. CalculateTerrainVectors(); // Load the rendering buffers with the terrain data. result = InitializeBuffers(device); if(!result) &#123; return false; &#125; ShutdownTerrainModel(); return true;&#125; &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11TerrainTutorial-RawHeightMaps]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】8-天空球]]></title>
    <url>%2F2018%2F05%2F06%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%918-%E5%A4%A9%E7%A9%BA%E7%90%83%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 7: Sky Domes 学习记录&emsp;&emsp;这篇文章中我们介绍天空的绘制，使用 SkyDome 实现。原理就是绘制球体，我们的场景都在球体里面，从场景的位置看向上方就可以看到球的内部面，所以需要我们关闭或者反转背面剔除，然后渲染球体。本篇代码基于上一篇，新增 SkydomeClass 和 SkydomeShaderClass 类。 &emsp;&emsp;SkyDomeClass 其实就是球体模型的类，类似于 TerrainClass ，它负责顶点索引信息的封装，声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445////////////////////////////////////////////////////////////////////////////////// Class name: SkyDomeClass////////////////////////////////////////////////////////////////////////////////class SkyDomeClass&#123;private: struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;; struct VertexType &#123; XMFLOAT3 position; &#125;;public: SkyDomeClass(); SkyDomeClass(const SkyDomeClass&amp;); ~SkyDomeClass(); bool Initialize(ID3D11Device*); void Shutdown(); void Render(ID3D11DeviceContext*); int GetIndexCount(); XMFLOAT4 GetApexColor(); XMFLOAT4 GetCenterColor();private: bool LoadSkyDomeModel(char*); void ReleaseSkyDomeModel(); bool InitializeBuffers(ID3D11Device*); void ReleaseBuffers(); void RenderBuffers(ID3D11DeviceContext*);private: ModelType* m_model; int m_vertexCount, m_indexCount; ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; XMFLOAT4 m_apexColor, m_centerColor;&#125;; &emsp;&emsp;其实现也是很简单，使用 LoadSkyDomeModel 加载模型文件，然后 InitializeBuffers 创建缓冲等等。 &emsp;&emsp;SkyDomeShaderClass 是简单的渲染类，声明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344////////////////////////////////////////////////////////////////////////////////// Class name: SkyDomeShaderClass////////////////////////////////////////////////////////////////////////////////class SkyDomeShaderClass&#123;private: struct MatrixBufferType &#123; XMMATRIX world; XMMATRIX view; XMMATRIX projection; &#125;; struct ColorBufferType &#123; XMFLOAT4 apexColor; XMFLOAT4 centerColor; &#125;;public: SkyDomeShaderClass(); SkyDomeShaderClass(const SkyDomeShaderClass&amp;); ~SkyDomeShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, XMFLOAT4, XMFLOAT4);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, XMMATRIX, XMMATRIX, XMMATRIX, XMFLOAT4, XMFLOAT4); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_colorBuffer;&#125;; &emsp;&emsp;其所对应的 skydome.vs 和 skydome.ps 中，其数据的传递和变换类似其他的着色器，着色的时候我们以顶点的高度为分量来计算颜色，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101////////////////////////////////////////////////////////////////////////////////// Filename: skydome.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float4 domePosition : TEXCOORD0;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType SkyDomeVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Send the unmodified position through to the pixel shader. output.domePosition = input.position; return output;&#125;////////////////////////////////////////////////////////////////////////////////// Filename: skydome.ps/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer ColorBuffer&#123; float4 apexColor; float4 centerColor;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float4 domePosition : TEXCOORD0;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 SkyDomePixelShader(PixelInputType input) : SV_TARGET&#123; float height; float4 outputColor; // Determine the position on the sky dome where this pixel is located. height = input.domePosition.y; // The value ranges from -1.0f to +1.0f so change it to only positive values. if(height &lt; 0.0) &#123; height = 0.0f; &#125; // Determine the gradient color by interpolating between the apex and center based on the height of the pixel in the sky dome. outputColor = lerp(centerColor, apexColor, height); return outputColor;&#125; &emsp;&emsp;最后我们在 ZoneClass 里添加 SkyDome 的对象，在 ShaderManagerClass 里添加 SkyDomeShaderClass 对象，并在渲染地形之前进行渲染（注意我们渲染的时候会关闭背面剔除和 Z-Buffer），部分渲染代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677bool ZoneClass::Render(D3DClass* Direct3D, ShaderManagerClass* ShaderManager , TextureManagerClass* TextureManager)&#123; XMMATRIX worldMatrix, viewMatrix, projectionMatrix, baseViewMatrix, orthoMatrix; bool result; XMFLOAT3 cameraPosition; // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Get the world, view, and projection matrices from the camera and d3d objects. Direct3D-&gt;GetWorldMatrix(worldMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); Direct3D-&gt;GetProjectionMatrix(projectionMatrix); m_Camera-&gt;GetBaseViewMatrix(baseViewMatrix); Direct3D-&gt;GetOrthoMatrix(orthoMatrix); // Get the position of the camera. cameraPosition = m_Camera-&gt;GetPosition(); // Clear the buffers to begin the scene. Direct3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); // Turn off back face culling and turn off the Z buffer. Direct3D-&gt;TurnOffCulling(); Direct3D-&gt;TurnZBufferOff(); // Translate the sky dome to be centered around the camera position. worldMatrix = XMMatrixTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z); // Render the sky dome using the sky dome shader. m_SkyDome-&gt;Render(Direct3D-&gt;GetDeviceContext()); result = ShaderManager-&gt;RenderSkydomeShader(Direct3D-&gt;GetDeviceContext(), m_SkyDome-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_SkyDome-&gt;GetApexColor(), m_SkyDome-&gt;GetCenterColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. Direct3D-&gt;GetWorldMatrix(worldMatrix); // Turn the Z buffer back and back face culling on. Direct3D-&gt;TurnZBufferOn(); Direct3D-&gt;TurnOnCulling(); if (m_wireFrame) &#123; Direct3D-&gt;EnableWireframe(); &#125; // Render the terrain grid using the texture shader. m_Terrain-&gt;Render(Direct3D-&gt;GetDeviceContext()); result = ShaderManager-&gt;RenderTerrainShader(Direct3D-&gt;GetDeviceContext(), m_Terrain-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, TextureManager-&gt;GetTexture(0), TextureManager-&gt;GetTexture(1), m_Light-&gt;GetDirection(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; if (m_wireFrame) &#123; Direct3D-&gt;DisableWireframe(); &#125; // Render the user interface. if(m_displayUI) &#123; result = m_UserInterface-&gt;Render(Direct3D, ShaderManager, worldMatrix, baseViewMatrix, orthoMatrix); if(!result) &#123; return false; &#125; &#125; // Present the rendered scene to the screen. Direct3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11TerrainTutorial-SkyDomes]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】7-颜色映射]]></title>
    <url>%2F2018%2F05%2F06%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%917-%E9%A2%9C%E8%89%B2%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 5: Color Mapped Terrain 学习记录&emsp;&emsp;这篇文章中我们主要介绍地形的颜色渲染，本篇没有新的类增加，主要修改内容在 TerrainClass 。 &emsp;&emsp;和地形纹理贴图不一样的是，我们使用纹理贴图的时候是基于地形的单个网格，而颜色映射则是对整个地形图的着色，和高度图类似。我们首先需要一张颜色的贴图（256 * 256），如下： &emsp;&emsp;我们将在 TerrainClass 中从这张图中读取出颜色数据，然后赋值给顶点，最后着色的时候使用网格的自身纹理和颜色贴图混合。部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180bool TerrainClass::LoadSetupFile(CHAR* filename) &#123; int stringLength; std::ifstream fin; char input; // Initialize the string that will hold the terrain file name. stringLength = 256; m_terrainFilename = new char[stringLength]; if(!m_terrainFilename) &#123; return false; &#125; // Initialize the string that will hold the terrain file name. m_colorMapFilename = new char[stringLength]; if(!m_colorMapFilename) &#123; return false; &#125; // Open the setup file. If it could not open the file then exit. fin.open(filename); if(fin.fail()) &#123; return false; &#125; // Read up to the terrain file name. fin.get(input); while(input != ':') &#123; fin.get(input); &#125; // Read in the terrain file name. fin &gt;&gt; m_terrainFilename; // Read up to the color map file name. fin.get(input); while(input != ':') &#123; fin.get(input); &#125; // Read in the color map file name. fin &gt;&gt; m_colorMapFilename; // Read up to the value of terrain height. fin.get(input); while(input != ':') &#123; fin.get(input); &#125; // Read in the terrain height. fin &gt;&gt; m_terrainHeight; // Read up to the value of terrain width. fin.get(input); while (input != ':') &#123; fin.get(input); &#125; // Read in the terrain width. fin &gt;&gt; m_terrainWidth; // Read up to the value of terrain height scaling. fin.get(input); while (input != ':') &#123; fin.get(input); &#125; // Read in the terrain height scaling. fin &gt;&gt; m_heightScale; // Close the setup file. fin.close(); return true;&#125;bool TerrainClass::LoadColorMap()&#123; int error, imageSize, i, j, k, index; FILE* filePtr; unsigned long long count; BITMAPFILEHEADER bitmapFileHeader; BITMAPINFOHEADER bitmapInfoHeader; unsigned char* bitmapImage; // Open the color map file in binary. error = fopen_s(&amp;filePtr, m_colorMapFilename, "rb"); if(error != 0) &#123; return false; &#125; // Read in the file header. count = fread(&amp;bitmapFileHeader, sizeof(BITMAPFILEHEADER), 1, filePtr); if(count != 1) &#123; return false; &#125; // Read in the bitmap info header. count = fread(&amp;bitmapInfoHeader, sizeof(BITMAPINFOHEADER), 1, filePtr); if(count != 1) &#123; return false; &#125; // Make sure the color map dimensions are the same as the terrain dimensions for easy 1 to 1 mapping. if((bitmapInfoHeader.biWidth != m_terrainWidth) || (bitmapInfoHeader.biHeight != m_terrainHeight)) &#123; return false; &#125; // Calculate the size of the bitmap image data. Since this is non-divide by 2 dimensions (eg. 257x257) need to add extra byte to each line. imageSize = m_terrainHeight * ((m_terrainWidth * 3) + 1); // Allocate memory for the bitmap image data. bitmapImage = new unsigned char[imageSize]; if(!bitmapImage) &#123; return false; &#125; // Move to the beginning of the bitmap data. fseek(filePtr, bitmapFileHeader.bfOffBits, SEEK_SET); // Read in the bitmap image data. count = fread(bitmapImage, 1, imageSize, filePtr); if(count != imageSize) &#123; return false; &#125; // Close the file. error = fclose(filePtr); if(error != 0) &#123; return false; &#125; // Initialize the position in the image data buffer. k=0; // Read the image data into the color map portion of the height map structure. for(j=0; j&lt;m_terrainHeight; j++) &#123; for(i=0; i&lt;m_terrainWidth; i++) &#123; // Bitmaps are upside down so load bottom to top into the array. index = (m_terrainWidth * (m_terrainHeight - 1 - j)) + i; m_heightMap[index].b = (float)bitmapImage[k] / 255.0f; m_heightMap[index].g = (float)bitmapImage[k + 1] / 255.0f; m_heightMap[index].r = (float)bitmapImage[k + 2] / 255.0f; k += 3; &#125; // Compensate for extra byte at end of each line in non-divide by 2 bitmaps (eg. 257x257). k++; &#125; // Release the bitmap image data. delete [] bitmapImage; bitmapImage = 0; // Release the color map filename now that is has been read in. delete [] m_colorMapFilename; m_colorMapFilename = 0; return true;&#125; &emsp;&emsp;之后我们修改 Terrain.vs 和 Terrain.ps ，新增 COLOR 属性，并且在 Terrain.ps 中混合 color 和 textureColor ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153////////////////////////////////////////////////////////////////////////////////// Filename: terrain.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL; float3 color : COLOR;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL; float4 color : COLOR;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType TerrainVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); // Calculate the tangent vector against the world matrix only and then normalize the final value. output.tangent = mul(input.tangent, (float3x3)worldMatrix); output.tangent = normalize(output.tangent); // Calculate the binormal vector against the world matrix only and then normalize the final value. output.binormal = mul(input.binormal, (float3x3)worldMatrix); output.binormal = normalize(output.binormal); output.color = float4(input.color , 1.0f); return output;&#125;////////////////////////////////////////////////////////////////////////////////// Filename: terrain.ps/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////Texture2D shaderTexture : register(t0);Texture2D normalTexture : register(t1);SamplerState SampleType : register(s0);//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer&#123; float4 diffuseColor; float3 lightDirection; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL; float4 color : COLOR;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 TerrainPixelShader(PixelInputType input) : SV_TARGET&#123; float4 textureColor; float3 lightDir; float4 bumpMap; float3 bumpNormal; float lightIntensity; float4 color; // Sample the pixel color from the texture using the sampler at this texture coordinate location. textureColor = shaderTexture.Sample(SampleType, input.tex); // Mix the textureColor and input color textureColor = textureColor * input.color * 2.2; // Invert the light direction for calculations. lightDir = -lightDirection; // Calculate the amount of light on this pixel using the normal map. bumpMap = normalTexture.Sample(SampleType, input.tex); bumpMap = (bumpMap * 2.0f) - 1.0f; bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal); bumpNormal = normalize(bumpNormal); lightIntensity = saturate(dot(bumpNormal, lightDir)); // Determine the final amount of diffuse color based on the diffuse color combined with the light intensity. color = saturate(diffuseColor * lightIntensity); // Multiply the texture pixel and the final diffuse color to get the final pixel color result. color = (color + 0.3) * textureColor; return color;&#125; &emsp;&emsp;记得修改着色器代码的时候同步更新对应渲染类的代码。 &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11TerrainTutorial-TerrainColorMap]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】6-网格法线贴图]]></title>
    <url>%2F2018%2F05%2F05%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%916-%E7%BD%91%E6%A0%BC%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 6: Terrain Normal Mapping 【DirectX】24-法线贴图 学习记录&emsp;&emsp;这篇文章中我们介绍地形网格的法线贴图，本篇代码基于上一篇，仅有少许的改动。 &emsp;&emsp;对地形的法线贴图和之前介绍的单独法线贴图并无区别，我们需要在 TerrainClass 中计算网格三角形的切线副切线，方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128void TerrainClass::CalculateTerrainVectors()&#123; int faceCount, i, index; TempVertexType vertex1, vertex2, vertex3; VectorType tangent, binormal; // Calculate the number of faces in the terrain model. faceCount = m_vertexCount / 3; // Initialize the index to the model data. index=0; // Go through all the faces and calculate the the tangent, binormal, and normal vectors. for(i=0; i&lt;faceCount; i++) &#123; // Get the three vertices for this face from the terrain model. vertex1.x = m_terrainModel[index].x; vertex1.y = m_terrainModel[index].y; vertex1.z = m_terrainModel[index].z; vertex1.tu = m_terrainModel[index].tu; vertex1.tv = m_terrainModel[index].tv; vertex1.nx = m_terrainModel[index].nx; vertex1.ny = m_terrainModel[index].ny; vertex1.nz = m_terrainModel[index].nz; index++; vertex2.x = m_terrainModel[index].x; vertex2.y = m_terrainModel[index].y; vertex2.z = m_terrainModel[index].z; vertex2.tu = m_terrainModel[index].tu; vertex2.tv = m_terrainModel[index].tv; vertex2.nx = m_terrainModel[index].nx; vertex2.ny = m_terrainModel[index].ny; vertex2.nz = m_terrainModel[index].nz; index++; vertex3.x = m_terrainModel[index].x; vertex3.y = m_terrainModel[index].y; vertex3.z = m_terrainModel[index].z; vertex3.tu = m_terrainModel[index].tu; vertex3.tv = m_terrainModel[index].tv; vertex3.nx = m_terrainModel[index].nx; vertex3.ny = m_terrainModel[index].ny; vertex3.nz = m_terrainModel[index].nz; index++; // Calculate the tangent and binormal of that face. CalculateTangentBinormal(vertex1, vertex2, vertex3, tangent, binormal); // Store the tangent and binormal for this face back in the model structure. m_terrainModel[index-1].tx = tangent.x; m_terrainModel[index-1].ty = tangent.y; m_terrainModel[index-1].tz = tangent.z; m_terrainModel[index-1].bx = binormal.x; m_terrainModel[index-1].by = binormal.y; m_terrainModel[index-1].bz = binormal.z; m_terrainModel[index-2].tx = tangent.x; m_terrainModel[index-2].ty = tangent.y; m_terrainModel[index-2].tz = tangent.z; m_terrainModel[index-2].bx = binormal.x; m_terrainModel[index-2].by = binormal.y; m_terrainModel[index-2].bz = binormal.z; m_terrainModel[index-3].tx = tangent.x; m_terrainModel[index-3].ty = tangent.y; m_terrainModel[index-3].tz = tangent.z; m_terrainModel[index-3].bx = binormal.x; m_terrainModel[index-3].by = binormal.y; m_terrainModel[index-3].bz = binormal.z; &#125; return;&#125;void TerrainClass::CalculateTangentBinormal(TempVertexType vertex1, TempVertexType vertex2, TempVertexType vertex3, VectorType&amp; tangent, VectorType&amp; binormal)&#123; float vector1[3], vector2[3]; float tuVector[2], tvVector[2]; float den; float length; // Calculate the two vectors for this face. vector1[0] = vertex2.x - vertex1.x; vector1[1] = vertex2.y - vertex1.y; vector1[2] = vertex2.z - vertex1.z; vector2[0] = vertex3.x - vertex1.x; vector2[1] = vertex3.y - vertex1.y; vector2[2] = vertex3.z - vertex1.z; // Calculate the tu and tv texture space vectors. tuVector[0] = vertex2.tu - vertex1.tu; tvVector[0] = vertex2.tv - vertex1.tv; tuVector[1] = vertex3.tu - vertex1.tu; tvVector[1] = vertex3.tv - vertex1.tv; // Calculate the denominator of the tangent/binormal equation. den = 1.0f / (tuVector[0] * tvVector[1] - tuVector[1] * tvVector[0]); // Calculate the cross products and multiply by the coefficient to get the tangent and binormal. tangent.x = (tvVector[1] * vector1[0] - tvVector[0] * vector2[0]) * den; tangent.y = (tvVector[1] * vector1[1] - tvVector[0] * vector2[1]) * den; tangent.z = (tvVector[1] * vector1[2] - tvVector[0] * vector2[2]) * den; binormal.x = (tuVector[0] * vector2[0] - tuVector[1] * vector1[0]) * den; binormal.y = (tuVector[0] * vector2[1] - tuVector[1] * vector1[1]) * den; binormal.z = (tuVector[0] * vector2[2] - tuVector[1] * vector1[2]) * den; // Calculate the length of the tangent. length = (float)sqrt((tangent.x * tangent.x) + (tangent.y * tangent.y) + (tangent.z * tangent.z)); // Normalize the tangent and then store it. tangent.x = tangent.x / length; tangent.y = tangent.y / length; tangent.z = tangent.z / length; // Calculate the length of the binormal. length = (float)sqrt((binormal.x * binormal.x) + (binormal.y * binormal.y) + (binormal.z * binormal.z)); // Normalize the binormal and then store it. binormal.x = binormal.x / length; binormal.y = binormal.y / length; binormal.z = binormal.z / length; return;&#125; &emsp;&emsp;TerrainClass 的整体声明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677////////////////////////////////////////////////////////////////////////////////// Class name: TerrainClass////////////////////////////////////////////////////////////////////////////////class TerrainClass&#123;private: struct VertexType &#123; XMFLOAT3 position; XMFLOAT2 texcoord; XMFLOAT3 normal; XMFLOAT3 tangent; XMFLOAT3 binormal; &#125;; struct HeightMapType &#123; float x, y, z; float nx, ny, nz; &#125;; struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; float tx, ty, tz; float bx, by, bz; &#125;; struct VectorType &#123; float x, y, z; &#125;; struct TempVertexType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;;public: TerrainClass(); TerrainClass(const TerrainClass&amp;); ~TerrainClass(); bool Initialize(ID3D11Device* , char*); void Shutdown(); bool Render(ID3D11DeviceContext*); int GetIndexCount();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); void CalculateTerrainVectors(); void CalculateTangentBinormal(TempVertexType, TempVertexType, TempVertexType, VectorType&amp;, VectorType&amp;); bool CalculateNormals(); bool LoadSetupFile(CHAR*); bool LoadBitmapHeightMap(); void ShutdownHeightMap(); void SetTerrainCoordinates(); bool BuildTerrainModel(); void ShutdownTerrainModel();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount; int m_terrainHeight , m_terrainWidth; float m_heightScale; LPSTR m_terrainFilename; HeightMapType* m_heightMap; ModelType* m_terrainModel;&#125;; &emsp;&emsp;之后我们需要一个从 LightShaderClass 修改而来的支持切线与副切线数据的 TerrainShaderClass ，声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445////////////////////////////////////////////////////////////////////////////////// Class name: TerrainShaderClass////////////////////////////////////////////////////////////////////////////////class TerrainShaderClass&#123;private: struct MatrixBufferType &#123; XMMATRIX world; XMMATRIX view; XMMATRIX projection; &#125;; struct LightBufferType &#123; XMFLOAT4 diffuseColor; XMFLOAT3 lightDirection; float padding; &#125;;public: TerrainShaderClass(); TerrainShaderClass(const TerrainShaderClass&amp;); ~TerrainShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*,ID3D11ShaderResourceView*, XMFLOAT3, XMFLOAT4);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*,ID3D11ShaderResourceView*, XMFLOAT3, XMFLOAT4); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_lightBuffer;&#125;; &emsp;&emsp;在 terrain.vs 和 terrain.ps 中使用切线副切线和法线贴图中的数据共同计算光照： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145////////////////////////////////////////////////////////////////////////////////// Filename: terrain.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType TerrainVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); // Calculate the tangent vector against the world matrix only and then normalize the final value. output.tangent = mul(input.tangent, (float3x3)worldMatrix); output.tangent = normalize(output.tangent); // Calculate the binormal vector against the world matrix only and then normalize the final value. output.binormal = mul(input.binormal, (float3x3)worldMatrix); output.binormal = normalize(output.binormal); return output;&#125;////////////////////////////////////////////////////////////////////////////////// Filename: terrain.ps/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////Texture2D shaderTexture : register(t0);Texture2D normalTexture : register(t1);SamplerState SampleType : register(s0);//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer&#123; float4 diffuseColor; float3 lightDirection; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 binormal : BINORMAL;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 TerrainPixelShader(PixelInputType input) : SV_TARGET&#123; float4 textureColor; float3 lightDir; float4 bumpMap; float3 bumpNormal; float lightIntensity; float4 color; // Sample the pixel color from the texture using the sampler at this texture coordinate location. textureColor = shaderTexture.Sample(SampleType, input.tex); // Invert the light direction for calculations. lightDir = -lightDirection; // Calculate the amount of light on this pixel using the normal map. bumpMap = normalTexture.Sample(SampleType, input.tex); bumpMap = (bumpMap * 2.0f) - 1.0f; bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal); bumpNormal = normalize(bumpNormal); lightIntensity = saturate(dot(bumpNormal, lightDir)); // Determine the final amount of diffuse color based on the diffuse color combined with the light intensity. color = saturate(diffuseColor * lightIntensity); // Multiply the texture pixel and the final diffuse color to get the final pixel color result. color = (color + 0.3) * textureColor; return color;&#125; &emsp;&emsp;最后在 ShaderManagerClass 中增加 TerrainShaderClass 的对象和在 ZoneClass 中使用 TerrainShaderClass 来渲染就可以了。 &emsp;&emsp;最终效果如下： &emsp;&emsp;贴近看的话可以看到效果： &emsp;&emsp;源代码：DX11TerrainTutorial-TerrainNormalMap &emsp;&emsp;这篇文章之前我修改了操作逻辑，如今可以使用鼠标来旋转视角，使用 Space 向上 ，Ctrl 向下。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】5-定向光照]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%915-%E5%AE%9A%E5%90%91%E5%85%89%E7%85%A7%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 4: Terrain Lighting 学习记录&emsp;&emsp;这篇文章中主要介绍对已经渲染的地形进行光照渲染（其实没什么新东西）。本篇代码基于上一篇，框架如下： &emsp;&emsp;为地形添加光照，我们主要是需要在 TerrainClass 中计算法线，然后使用 LightShaderClass 代替 TextureShaderClass 渲染就行了。在 TerrainClass 中，我们修改顶点及模型等结构体为其添加法线的变量，然后新增一个计算法线的方法。修改后的 TerrainClass 声明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162////////////////////////////////////////////////////////////////////////////////// Class name: TerrainClass////////////////////////////////////////////////////////////////////////////////class TerrainClass&#123;private: struct VertexType &#123; XMFLOAT3 position; XMFLOAT2 texcoord; XMFLOAT3 normal; &#125;; struct HeightMapType &#123; float x, y, z; float nx, ny, nz; &#125;; struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;; struct VectorType &#123; float x, y, z; &#125;;public: TerrainClass(); TerrainClass(const TerrainClass&amp;); ~TerrainClass(); bool Initialize(ID3D11Device* , char*); void Shutdown(); bool Render(ID3D11DeviceContext*); int GetIndexCount();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); bool CalculateNormals(); bool LoadSetupFile(CHAR*); bool LoadBitmapHeightMap(); void ShutdownHeightMap(); void SetTerrainCoordinates(); bool BuildTerrainModel(); void ShutdownTerrainModel();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount; int m_terrainHeight , m_terrainWidth; float m_heightScale; LPSTR m_terrainFilename; HeightMapType* m_heightMap; ModelType* m_terrainModel;&#125;; &emsp;&emsp;法线计算方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131bool TerrainClass::CalculateNormals()&#123; int i, j, index1, index2, index3, index; float vertex1[3], vertex2[3], vertex3[3], vector1[3], vector2[3], sum[3], length; VectorType* normals; // Create a temporary array to hold the face normal vectors. normals = new VectorType[(m_terrainHeight-1) * (m_terrainWidth-1)]; if(!normals) &#123; return false; &#125; // Go through all the faces in the mesh and calculate their normals. for(j=0; j&lt;(m_terrainHeight-1); j++) &#123; for(i=0; i&lt;(m_terrainWidth-1); i++) &#123; index1 = ((j+1) * m_terrainWidth) + i; // Bottom left vertex. index2 = ((j+1) * m_terrainWidth) + (i+1); // Bottom right vertex. index3 = (j * m_terrainWidth) + i; // Upper left vertex. // Get three vertices from the face. vertex1[0] = m_heightMap[index1].x; vertex1[1] = m_heightMap[index1].y; vertex1[2] = m_heightMap[index1].z; vertex2[0] = m_heightMap[index2].x; vertex2[1] = m_heightMap[index2].y; vertex2[2] = m_heightMap[index2].z; vertex3[0] = m_heightMap[index3].x; vertex3[1] = m_heightMap[index3].y; vertex3[2] = m_heightMap[index3].z; // Calculate the two vectors for this face. vector1[0] = vertex1[0] - vertex3[0]; vector1[1] = vertex1[1] - vertex3[1]; vector1[2] = vertex1[2] - vertex3[2]; vector2[0] = vertex3[0] - vertex2[0]; vector2[1] = vertex3[1] - vertex2[1]; vector2[2] = vertex3[2] - vertex2[2]; index = (j * (m_terrainWidth - 1)) + i; // Calculate the cross product of those two vectors to get the un-normalized value for this face normal. normals[index].x = (vector1[1] * vector2[2]) - (vector1[2] * vector2[1]); normals[index].y = (vector1[2] * vector2[0]) - (vector1[0] * vector2[2]); normals[index].z = (vector1[0] * vector2[1]) - (vector1[1] * vector2[0]); // Calculate the length. length = (float)sqrt((normals[index].x * normals[index].x) + (normals[index].y * normals[index].y) + (normals[index].z * normals[index].z)); // Normalize the final value for this face using the length. normals[index].x = (normals[index].x / length); normals[index].y = (normals[index].y / length); normals[index].z = (normals[index].z / length); &#125; &#125; // Now go through all the vertices and take a sum of the face normals that touch this vertex. for(j=0; j&lt;m_terrainHeight; j++) &#123; for(i=0; i&lt;m_terrainWidth; i++) &#123; // Initialize the sum. sum[0] = 0.0f; sum[1] = 0.0f; sum[2] = 0.0f; // Bottom left face. if(((i-1) &gt;= 0) &amp;&amp; ((j-1) &gt;= 0)) &#123; index = ((j-1) * (m_terrainWidth-1)) + (i-1); sum[0] += normals[index].x; sum[1] += normals[index].y; sum[2] += normals[index].z; &#125; // Bottom right face. if((i&lt;(m_terrainWidth-1)) &amp;&amp; ((j-1) &gt;= 0)) &#123; index = ((j - 1) * (m_terrainWidth - 1)) + i; sum[0] += normals[index].x; sum[1] += normals[index].y; sum[2] += normals[index].z; &#125; // Upper left face. if(((i-1) &gt;= 0) &amp;&amp; (j&lt;(m_terrainHeight-1))) &#123; index = (j * (m_terrainWidth-1)) + (i-1); sum[0] += normals[index].x; sum[1] += normals[index].y; sum[2] += normals[index].z; &#125; // Upper right face. if((i &lt; (m_terrainWidth-1)) &amp;&amp; (j &lt; (m_terrainHeight-1))) &#123; index = (j * (m_terrainWidth-1)) + i; sum[0] += normals[index].x; sum[1] += normals[index].y; sum[2] += normals[index].z; &#125; // Calculate the length of this normal. length = (float)sqrt((sum[0] * sum[0]) + (sum[1] * sum[1]) + (sum[2] * sum[2])); // Get an index to the vertex location in the height map array. index = (j * m_terrainWidth) + i; // Normalize the final shared normal for this vertex and store it in the height map array. m_heightMap[index].nx = (sum[0] / length); m_heightMap[index].ny = (sum[1] / length); m_heightMap[index].nz = (sum[2] / length); &#125; &#125; // Release the temporary normals. delete [] normals; normals = 0; return true;&#125; &emsp;&emsp;除此之外，我们在 ShaderManagerClass 里新增 LightShaderClass 的对象，以及在 ZoneClass 里新增 LightClass 的对象，然后修改渲染的方式就可以了。 &emsp;&emsp;最终效果如下： &emsp;&emsp;有光照的情况下我们的地形显得更加真实，源代码地址：DX11TerrainTutorial-TerrainLight]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】4-地形网格纹理]]></title>
    <url>%2F2018%2F05%2F03%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%914-%E5%9C%B0%E5%BD%A2%E7%BD%91%E6%A0%BC%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 3: Terrain Texturing 学习记录&emsp;&emsp;本篇介绍地形网格的纹理贴图，基于上一篇代码，我们简单的使用 TextureShaderClass 来渲染网格，使用一个 TextureManagerClass 类管理项目中的纹理数据。框架如图： &emsp;&emsp;这次我们将以 TextureShaderClass 来代替 ColorShaderClass 渲染网格，所以在 ShaderManagerClass 中新增 TextureShaderClass 的对象，同时添加它的 Render 接口。修改后的类声明如下： 12345678910111213141516171819202122////////////////////////////////////////////////////////////////////////////////// Class name: ShaderManagerClass////////////////////////////////////////////////////////////////////////////////class ShaderManagerClass&#123;public: ShaderManagerClass(); ShaderManagerClass(const ShaderManagerClass&amp;); ~ShaderManagerClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool RenderColorShader(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX); bool RenderFontShader(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*, XMFLOAT4); bool RenderTextureShader(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*);private: ColorShaderClass* m_ColorShader; FontShaderClass* m_FontShader; TextureShaderClass* m_TextureShader;&#125;; &emsp;&emsp;其次，我们修改 TerrainClass ，为顶点增加 uv 属性，并且在初始化顶点数据的时候初始化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677struct VertexType&#123; XMFLOAT3 position; XMFLOAT2 texcoord;&#125;;struct HeightMapType &#123; float x, y, z;&#125;;struct ModelType &#123; float x, y, z; float tu, tv;&#125;;// Load the 3D terrain model with the height map terrain data.// We will be creating 2 triangles for each of the four points in a quad.for(j=0; j&lt;(m_terrainHeight-1); j++)&#123; for(i=0; i&lt;(m_terrainWidth-1); i++) &#123; // Get the indexes to the four points of the quad. index1 = (m_terrainWidth * j) + i; // Upper left. index2 = (m_terrainWidth * j) + (i+1); // Upper right. index3 = (m_terrainWidth * (j+1)) + i; // Bottom left. index4 = (m_terrainWidth * (j+1)) + (i+1); // Bottom right. // Now create two triangles for that quad. // Triangle 1 - Upper left. m_terrainModel[index].x = m_heightMap[index1].x; m_terrainModel[index].y = m_heightMap[index1].y; m_terrainModel[index].z = m_heightMap[index1].z; m_terrainModel[index].tu = 0.0f; m_terrainModel[index].tv = 0.0f; index++; // Triangle 1 - Upper right. m_terrainModel[index].x = m_heightMap[index2].x; m_terrainModel[index].y = m_heightMap[index2].y; m_terrainModel[index].z = m_heightMap[index2].z; m_terrainModel[index].tu = 1.0f; m_terrainModel[index].tv = 0.0f; index++; // Triangle 1 - Bottom left. m_terrainModel[index].x = m_heightMap[index3].x; m_terrainModel[index].y = m_heightMap[index3].y; m_terrainModel[index].z = m_heightMap[index3].z; m_terrainModel[index].tu = 0.0f; m_terrainModel[index].tv = 1.0f; index++; // Triangle 2 - Bottom left. m_terrainModel[index].x = m_heightMap[index3].x; m_terrainModel[index].y = m_heightMap[index3].y; m_terrainModel[index].z = m_heightMap[index3].z; m_terrainModel[index].tu = 0.0f; m_terrainModel[index].tv = 1.0f; index++; // Triangle 2 - Upper right. m_terrainModel[index].x = m_heightMap[index2].x; m_terrainModel[index].y = m_heightMap[index2].y; m_terrainModel[index].z = m_heightMap[index2].z; m_terrainModel[index].tu = 1.0f; m_terrainModel[index].tv = 0.0f; index++; // Triangle 2 - Bottom right. m_terrainModel[index].x = m_heightMap[index4].x; m_terrainModel[index].y = m_heightMap[index4].y; m_terrainModel[index].z = m_heightMap[index4].z; m_terrainModel[index].tu = 1.0f; m_terrainModel[index].tv = 1.0f; index++; &#125;&#125; &emsp;&emsp;之后，我们需要一个 TextureManagerClass 类来管理我们的纹理，其声明如下： 123456789101112131415161718192021////////////////////////////////////////////////////////////////////////////////// Class name: TextureManagerClass////////////////////////////////////////////////////////////////////////////////class TextureManagerClass&#123;public: TextureManagerClass(); TextureManagerClass(const TextureManagerClass&amp;); ~TextureManagerClass(); bool Initialize(int); void Shutdown(); bool LoadTexture(ID3D11Device*, ID3D11DeviceContext*, char*, int); ID3D11ShaderResourceView* GetTexture(int);private: TextureClass* m_TextureArray; int m_textureCount;&#125;; &emsp;&emsp;最后，我们替换 ZoneClass 中的渲染方法为纹理渲染： 123// Render the terrain grid using the texture shader.m_Terrain-&gt;Render(Direct3D-&gt;GetDeviceContext());result = ShaderManager-&gt;RenderTextureShader(Direct3D-&gt;GetDeviceContext(), m_Terrain-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix , TextureManager-&gt;GetTexture(0)); &emsp;&emsp;最终效果如下： &emsp;&emsp;源代码：DX11TerrainTutorial-TerrainTexturing]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】3-高度图]]></title>
    <url>%2F2018%2F05%2F02%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%913-%E9%AB%98%E5%BA%A6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 2: Bitmap Height Maps 学习记录&emsp;&emsp;这篇文章中我们简单介绍使用高度图来实现非平面地形的绘制，本篇代码基于上一篇。 &emsp;&emsp;高度图其实就是一张单通道分量图（灰度图），每一个像素只有一个值。我们使用与我们地形网格等大小的高度图来表示我们地形中的高度。这篇文章中我们所使用的高度图如下： &emsp;&emsp;我们主要修改的也只是 TerrainClass 部分。首先来看其声明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253////////////////////////////////////////////////////////////////////////////////// Class name: TerrainClass////////////////////////////////////////////////////////////////////////////////class TerrainClass&#123;private: struct VertexType &#123; XMFLOAT3 position; XMFLOAT4 color; &#125;; struct HeightMapType &#123; float x, y, z; &#125;; struct ModelType &#123; float x, y, z; &#125;;public: TerrainClass(); TerrainClass(const TerrainClass&amp;); ~TerrainClass(); bool Initialize(ID3D11Device* , char*); void Shutdown(); bool Render(ID3D11DeviceContext*); int GetIndexCount();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); bool LoadSetupFile(CHAR*); bool LoadBitmapHeightMap(); void ShutdownHeightMap(); void SetTerrainCoordinates(); bool BuildTerrainModel(); void ShutdownTerrainModel();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount; int m_terrainHeight , m_terrainWidth; float m_heightScale; LPSTR m_terrainFilename; HeightMapType* m_heightMap; ModelType* m_terrainModel;&#125;; &emsp;&emsp;添加了多个方法以读取高度图相关信息，例如我们的 Setup.txt 文件和 HeightMap.bmp 文件，其实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293bool TerrainClass::LoadSetupFile(CHAR* filename) &#123; int stringLength; std::ifstream fin; char input; // Initialize the string that will hold the terrain file name. stringLength = 256; m_terrainFilename = new char[stringLength]; if(!m_terrainFilename) &#123; return false; &#125; // Open the setup file. If it could not open the file then exit. fin.open(filename); if(fin.fail()) &#123; return false; &#125; // Read up to the terrain file name. fin.get(input); while(input != ':') &#123; fin.get(input); &#125; // Read in the terrain file name. fin &gt;&gt; m_terrainFilename; // Read up to the value of terrain height. fin.get(input); while(input != ':') &#123; fin.get(input); &#125; // Read in the terrain height. fin &gt;&gt; m_terrainHeight; // Read up to the value of terrain width. fin.get(input); while (input != ':') &#123; fin.get(input); &#125; // Read in the terrain width. fin &gt;&gt; m_terrainWidth; // Read up to the value of terrain height scaling. fin.get(input); while (input != ':') &#123; fin.get(input); &#125; // Read in the terrain height scaling. fin &gt;&gt; m_heightScale; // Close the setup file. fin.close(); return true;&#125;bool TerrainClass::LoadBitmapHeightMap() &#123; int error, imageSize, i, j, k, index; FILE* filePtr; unsigned long long count; BITMAPFILEHEADER bitmapFileHeader; BITMAPINFOHEADER bitmapInfoHeader; unsigned char* bitmapImage; unsigned char height; // Start by creating the array structure to hold the height map data. m_heightMap = new HeightMapType[m_terrainWidth * m_terrainHeight]; if(!m_heightMap) &#123; return false; &#125; // Open the bitmap map file in binary. error = fopen_s(&amp;filePtr, m_terrainFilename, "rb"); if(error != 0) &#123; return false; &#125; // Read in the bitmap file header. count = fread(&amp;bitmapFileHeader, sizeof(BITMAPFILEHEADER), 1, filePtr); if(count != 1) &#123; return false; &#125; // Read in the bitmap info header. count = fread(&amp;bitmapInfoHeader, sizeof(BITMAPINFOHEADER), 1, filePtr); if(count != 1) &#123; return false; &#125; // Make sure the height map dimensions are the same as the terrain dimensions for easy 1 to 1 mapping. if((bitmapInfoHeader.biHeight != m_terrainHeight) || (bitmapInfoHeader.biWidth != m_terrainWidth)) &#123; return false; &#125; // Calculate the size of the bitmap image data. // Since we use non-divide by 2 dimensions (eg. 257x257) we need to add an extra byte to each line. imageSize = m_terrainHeight * ((m_terrainWidth * 3) + 1); // Allocate memory for the bitmap image data. bitmapImage = new unsigned char[imageSize]; if(!bitmapImage) &#123; return false; &#125; // Move to the beginning of the bitmap data. fseek(filePtr, bitmapFileHeader.bfOffBits, SEEK_SET); // Read in the bitmap image data. count = fread(bitmapImage, 1, imageSize, filePtr); if(count != imageSize) &#123; return false; &#125; // Close the file. error = fclose(filePtr); if(error != 0) &#123; return false; &#125; // Initialize the position in the image data buffer. k=0; // Read the image data into the height map array. for(j=0; j&lt;m_terrainHeight; j++) &#123; for(i=0; i&lt;m_terrainWidth; i++) &#123; // Bitmaps are upside down so load bottom to top into the height map array. index = (m_terrainWidth * (m_terrainHeight - 1 - j)) + i; // Get the grey scale pixel value from the bitmap image data at this location. height = bitmapImage[k]; // Store the pixel value as the height at this point in the height map array. m_heightMap[index].y = (float)height; // Increment the bitmap image data index. k+=3; &#125; // Compensate for the extra byte at end of each line in non-divide by 2 bitmaps (eg. 257x257). k++; &#125; // Release the bitmap image data now that the height map array has been loaded. delete [] bitmapImage; bitmapImage = 0; // Release the terrain filename now that is has been read in. delete [] m_terrainFilename; m_terrainFilename = 0; return true;&#125;void TerrainClass::ShutdownHeightMap() &#123; // Release the height map array. if(m_heightMap) &#123; delete [] m_heightMap; m_heightMap = 0; &#125; return;&#125;void TerrainClass::SetTerrainCoordinates() &#123; int i, j, index; // Loop through all the elements in the height map array and adjust their coordinates correctly. for(j=0; j&lt;m_terrainHeight; j++) &#123; for(i=0; i&lt;m_terrainWidth; i++) &#123; index = (m_terrainWidth * j) + i; // Set the X and Z coordinates. m_heightMap[index].x = (float)i; m_heightMap[index].z = -(float)j; // Move the terrain depth into the positive range. For example from (0, -256) to (256, 0). m_heightMap[index].z += (float)(m_terrainHeight - 1); // Scale the height. m_heightMap[index].y /= m_heightScale; &#125; &#125; return;&#125;bool TerrainClass::BuildTerrainModel() &#123; int i, j, index, index1, index2, index3, index4; // Calculate the number of vertices in the 3D terrain model. m_vertexCount = (m_terrainHeight - 1) * (m_terrainWidth - 1) * 6; // Create the 3D terrain model array. m_terrainModel = new ModelType[m_vertexCount]; if(!m_terrainModel) &#123; return false; &#125; // Initialize the index into the height map array. index = 0; // Load the 3D terrain model with the height map terrain data. // We will be creating 2 triangles for each of the four points in a quad. for(j=0; j&lt;(m_terrainHeight-1); j++) &#123; for(i=0; i&lt;(m_terrainWidth-1); i++) &#123; // Get the indexes to the four points of the quad. index1 = (m_terrainWidth * j) + i; // Upper left. index2 = (m_terrainWidth * j) + (i+1); // Upper right. index3 = (m_terrainWidth * (j+1)) + i; // Bottom left. index4 = (m_terrainWidth * (j+1)) + (i+1); // Bottom right. // Now create two triangles for that quad. // Triangle 1 - Upper left. m_terrainModel[index].x = m_heightMap[index1].x; m_terrainModel[index].y = m_heightMap[index1].y; m_terrainModel[index].z = m_heightMap[index1].z; index++; // Triangle 1 - Upper right. m_terrainModel[index].x = m_heightMap[index2].x; m_terrainModel[index].y = m_heightMap[index2].y; m_terrainModel[index].z = m_heightMap[index2].z; index++; // Triangle 1 - Bottom left. m_terrainModel[index].x = m_heightMap[index3].x; m_terrainModel[index].y = m_heightMap[index3].y; m_terrainModel[index].z = m_heightMap[index3].z; index++; // Triangle 2 - Bottom left. m_terrainModel[index].x = m_heightMap[index3].x; m_terrainModel[index].y = m_heightMap[index3].y; m_terrainModel[index].z = m_heightMap[index3].z; index++; // Triangle 2 - Upper right. m_terrainModel[index].x = m_heightMap[index2].x; m_terrainModel[index].y = m_heightMap[index2].y; m_terrainModel[index].z = m_heightMap[index2].z; index++; // Triangle 2 - Bottom right. m_terrainModel[index].x = m_heightMap[index4].x; m_terrainModel[index].y = m_heightMap[index4].y; m_terrainModel[index].z = m_heightMap[index4].z; index++; &#125; &#125; return true;&#125;void TerrainClass::ShutdownTerrainModel() &#123; // Release the terrain model data. if(m_terrainModel) &#123; delete [] m_terrainModel; m_terrainModel = 0; &#125; return;&#125; &emsp;&emsp;顶点的处理我们放在了 BuildTerrainModel 方法里，在 InitializeBuffers 方法里我们仅仅做一个赋值操作。 &emsp;&emsp;最后，我们将渲染图元改为三角形： 1deviceContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11TerrainTutorial-BitmapHeightMaps]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】2-地形网格]]></title>
    <url>%2F2018%2F05%2F01%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%912-%E5%9C%B0%E5%BD%A2%E7%BD%91%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 1: Grid and Camera Movement 学习记录&emsp;&emsp;本篇主要介绍对地形网格的绘制，代码基于上一篇内容。 &emsp;&emsp;既然说是地形网格，那么自然是以网格为主。我们之前在 ModelClass 中读取模型文件来创建模型数据，在 TerrainClass 中则是使用代码生成网格。首先来看我们 TerrainClass 的声明： 1234567891011121314151617181920212223242526272829303132////////////////////////////////////////////////////////////////////////////////// Class name: TerrainClass////////////////////////////////////////////////////////////////////////////////class TerrainClass&#123;private: struct VertexType &#123; XMFLOAT3 position; XMFLOAT4 color; &#125;;public: TerrainClass(); TerrainClass(const TerrainClass&amp;); ~TerrainClass(); bool Initialize(ID3D11Device*); void Shutdown(); bool Render(ID3D11DeviceContext*); int GetIndexCount();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*);private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount;&#125;; &emsp;&emsp;和 ModelClass 几乎相同。在它的 InitializeBuffers 方法中，我们使用代码生成顶点和索引数据，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170bool TerrainClass::InitializeBuffers(ID3D11Device* device)&#123; VertexType* vertices; unsigned long* indices; D3D11_BUFFER_DESC vertexBufferDesc, indexBufferDesc; D3D11_SUBRESOURCE_DATA vertexData, indexData; HRESULT result; int i, j, terrainWidth, terrainHeight, index; XMFLOAT4 color; float positionX, positionZ; // Set the height and width of the terrain grid. terrainHeight = 256; terrainWidth = 256; // Set the color of the terrain grid. color = XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f); // Calculate the number of vertices in the terrain. m_vertexCount = (terrainWidth - 1) * (terrainHeight - 1) * 8; // Set the index count to the same as the vertex count. m_indexCount = m_vertexCount; // Create the vertex array. vertices = new VertexType[m_vertexCount]; if(!vertices) &#123; return false; &#125; // Create the index array. indices = new unsigned long[m_indexCount]; if(!indices) &#123; return false; &#125; // Initialize the index into the vertex and index arrays. index = 0; // Load the vertex array and index array with data. for(j=0; j&lt;(terrainHeight-1); j++) &#123; for(i=0; i&lt;(terrainWidth-1); i++) &#123; // Line 1 - Upper left. positionX = (float)i; positionZ = (float)(j + 1); vertices[index].position = XMFLOAT3(positionX, 0.0f, positionZ); vertices[index].color = color; indices[index] = index; index++; // Line 1 - Upper right. positionX = (float)(i + 1); positionZ = (float)(j + 1); vertices[index].position = XMFLOAT3(positionX, 0.0f, positionZ); vertices[index].color = color; indices[index] = index; index++; // Line 2 - Upper right positionX = (float)(i + 1); positionZ = (float)(j + 1); vertices[index].position = XMFLOAT3(positionX, 0.0f, positionZ); vertices[index].color = color; indices[index] = index; index++; // Line 2 - Bottom right. positionX = (float)(i + 1); positionZ = (float)j; vertices[index].position = XMFLOAT3(positionX, 0.0f, positionZ); vertices[index].color = color; indices[index] = index; index++; // Line 3 - Bottom right. positionX = (float)(i + 1); positionZ = (float)j; vertices[index].position = XMFLOAT3(positionX, 0.0f, positionZ); vertices[index].color = color; indices[index] = index; index++; // Line 3 - Bottom left. positionX = (float)i; positionZ = (float)j; vertices[index].position = XMFLOAT3(positionX, 0.0f, positionZ); vertices[index].color = color; indices[index] = index; index++; // Line 4 - Bottom left. positionX = (float)i; positionZ = (float)j; vertices[index].position = XMFLOAT3(positionX, 0.0f, positionZ); vertices[index].color = color; indices[index] = index; index++; // Line 4 - Upper left. positionX = (float)i; positionZ = (float)(j + 1); vertices[index].position = XMFLOAT3(positionX, 0.0f, positionZ); vertices[index].color = color; indices[index] = index; index++; &#125; &#125; // Set up the description of the static vertex buffer. vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT; vertexBufferDesc.ByteWidth = sizeof(VertexType) * m_vertexCount; vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; vertexBufferDesc.CPUAccessFlags = 0; vertexBufferDesc.MiscFlags = 0; vertexBufferDesc.StructureByteStride = 0; // Give the subresource structure a pointer to the vertex data. vertexData.pSysMem = vertices; vertexData.SysMemPitch = 0; vertexData.SysMemSlicePitch = 0; // Now create the vertex buffer. result = device-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;vertexData, &amp;m_vertexBuffer); if(FAILED(result)) &#123; return false; &#125; // Set up the description of the static index buffer. indexBufferDesc.Usage = D3D11_USAGE_DEFAULT; indexBufferDesc.ByteWidth = sizeof(unsigned long) * m_indexCount; indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER; indexBufferDesc.CPUAccessFlags = 0; indexBufferDesc.MiscFlags = 0; indexBufferDesc.StructureByteStride = 0; // Give the subresource structure a pointer to the index data. indexData.pSysMem = indices; indexData.SysMemPitch = 0; indexData.SysMemSlicePitch = 0; // Create the index buffer. result = device-&gt;CreateBuffer(&amp;indexBufferDesc, &amp;indexData, &amp;m_indexBuffer); if(FAILED(result)) &#123; return false; &#125; // Release the arrays now that the buffers have been created and loaded. delete [] vertices; vertices = 0; delete [] indices; indices = 0; return true;&#125; &emsp;&emsp;可以看到我们是以四条线的方式来确定每一个四边形，所以在绘制图元类型的时候我们选用线绘制： 12// Set the type of primitive that should be rendered from this vertex buffer, in this case lines.deviceContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST); &emsp;&emsp;最终效果（高处往下看）： &emsp;&emsp;源代码：DX11TerrainTutorial-GridAndCameraMovement]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DX11地形篇】1-地形篇初始框架]]></title>
    <url>%2F2018%2F04%2F29%2F%E3%80%90DX11%E5%9C%B0%E5%BD%A2%E7%AF%87%E3%80%911-%E5%9C%B0%E5%BD%A2%E7%AF%87%E5%88%9D%E5%A7%8B%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 1: Grid and Camera Movement 学习记录&emsp;&emsp;这篇文章我们介绍使用 DX11 渲染场景地形的基本框架。如图示： &emsp;&emsp;这篇文章我们先来介绍我们的 ShaderManagerClass 类，这个类管理我们所有的 ShaderClass 。这个类的声明如下： 1234567891011121314151617181920////////////////////////////////////////////////////////////////////////////////// Class name: ShaderManagerClass////////////////////////////////////////////////////////////////////////////////class ShaderManagerClass&#123;public: ShaderManagerClass(); ShaderManagerClass(const ShaderManagerClass&amp;); ~ShaderManagerClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool RenderColorShader(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX); bool RenderFontShader(ID3D11DeviceContext*, int, XMMATRIX, XMMATRIX, XMMATRIX, ID3D11ShaderResourceView*, XMFLOAT4);private: ColorShaderClass* m_ColorShader; FontShaderClass* m_FontShader;&#125;; &emsp;&emsp;这个类中声明了我们所需要的 ShaderClass 对象，并提供相应 Render 函数。相比较之前我们框架的结构，当着色器程序变多的时候，很明显是这个会比较适合一些。它的实现也只是调用 ShaderClass 的方法而已。 &emsp;&emsp;除此之外，新增的还有 ZoneClass 类，其声明如下： 12345678910111213141516171819202122232425////////////////////////////////////////////////////////////////////////////////// Class name: ZoneClass////////////////////////////////////////////////////////////////////////////////class ZoneClass&#123;public: ZoneClass(); ZoneClass(const ZoneClass&amp;); ~ZoneClass(); bool Initialize(D3DClass*, HWND, int, int, float); void Shutdown(); bool Frame(D3DClass*, InputClass*, ShaderManagerClass*, float, int);private: void HandleMovementInput(InputClass*, float); bool Render(D3DClass*, ShaderManagerClass*);private: UserInterfaceClass* m_UserInterface; CameraClass* m_Camera; PositionClass* m_Position; TerrainClass* m_Terrain; bool m_displayUI;&#125;; &emsp;&emsp;这个类我们用来管理 UserInterfaceClass ，CameraClass，PositionClass，TerrainClass 等类，原教程中对其描述如下： &emsp;&emsp;The zone class is the main wrapper class for all of the terrain processing as well as anything that would be related to the terrain.&emsp;&emsp;Currently it will just move the camera around the terrain grid, but in future tutorials it will be expanded to handle sky, trees, foliage, and other objects related to the terrain.&emsp;&emsp;We will also try to keep this class fairly generic so that in future tutorials it can just read a text file and populate the zone without any need for code changes.&emsp;&emsp;For this tutorial the ZoneClass will handle all the camera movement, render the terrain grid, and display the user interface. &emsp;&emsp;CameraClass 和 PositionClass 我们都比较清楚。 &emsp;&emsp;TerrainClass 封装了地形的模型和渲染功能，类似于 ModelClass，在现在的基础框架下，它只有简单的网格数据，其声明如下： 1234567891011121314151617181920212223242526272829303132////////////////////////////////////////////////////////////////////////////////// Class name: TerrainClass////////////////////////////////////////////////////////////////////////////////class TerrainClass&#123;private: struct VertexType &#123; XMFLOAT3 position; XMFLOAT4 color; &#125;;public: TerrainClass(); TerrainClass(const TerrainClass&amp;); ~TerrainClass(); bool Initialize(ID3D11Device*); void Shutdown(); bool Render(ID3D11DeviceContext*); int GetIndexCount();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*);private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount;&#125;; &emsp;&emsp;UserInterfaceClass 则是简单的封装了对当前信息的输出，相当于我们玩游戏中的各种数据信息（类似于帧数，网络等等），声明如下： 1234567891011121314151617181920212223242526////////////////////////////////////////////////////////////////////////////////// Class name: UserInterfaceClass////////////////////////////////////////////////////////////////////////////////class UserInterfaceClass&#123;public: UserInterfaceClass(); UserInterfaceClass(const UserInterfaceClass&amp;); ~UserInterfaceClass(); bool Initialize(D3DClass*, int, int); void Shutdown(); bool Frame(ID3D11DeviceContext*, int, float, float, float, float, float, float); bool Render(D3DClass*, ShaderManagerClass*, XMMATRIX, XMMATRIX, XMMATRIX);private: bool UpdateFpsString(ID3D11DeviceContext*, int); bool UpdatePositionStrings(ID3D11DeviceContext*, float, float, float, float, float, float);private: FontClass* m_Font1; TextClass *m_FpsString, *m_VideoStrings, *m_PositionStrings; int m_previousFps; int m_previousPosition[6];&#125;; &emsp;&emsp;下篇文章中我们将具体介绍对于地形网格的绘制，着重于介绍 TerrainClass 类。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
        <tag>Terrain</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】47-延迟渲染]]></title>
    <url>%2F2018%2F04%2F27%2F%E3%80%90DirectX%E3%80%9147-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 50: Deferred Shading 《Real-Time Rendering 3rd》 《GPU-Programming-AndCgLanguage-Primer》 学习记录&emsp;&emsp;在计算机图形中，延迟渲染（Deferred Rendering），即延迟着色（Deferred Shading）是将着色计算延迟到深度测试之后进行处理的一种渲染方法。延迟着色技术最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开，能够在渲染拥有成百上千光源的场景的同时依然保持很高的帧率，给我们渲染拥有大量光源的场景提供了很多可能性。 &emsp;&emsp;这篇文章，我们简单介绍延迟渲染的实现。 &emsp;&emsp;延迟渲染的实现我们主要分为两步，第一步将所有物体绘制到屏幕缓冲（G-Buffer），第二部在深度测试后进行光照计算，对应于正向渲染（Forward Rendering）O（m*n）的复杂度场景，延迟渲染的复杂度仅仅为 O（m+n），因为它避免了对在深度测试中被丢弃的片元的渲染。 &emsp;&emsp;Deferred shading is the process of splitting up traditional rendering into a two stage system that is designed to improve efficiency in shaders that require complex lighting. &emsp;&emsp;In the first stage we render as usual by using a vertex and pixel shader.However the purpose of the pixel shader is entirely different.We no longer use the pixel shader to do lighting calculations and then output a color to the back buffer.We instead output information about that pixel (such as normals, texture color, and so forth) to a render to texture buffer.So now our pixel shader output from the first stage has become a 2D texture full of scene information that can be used as a texture input to the second stage. &emsp;&emsp;In the second stage we re-write all our traditional 3D shaders to now do 2D post processing using the render to texture outputs from the first stage.And because we are doing 2D post processing we have just a set number of pixels to run our lighting equations on instead of a massive scene full of thousands of complex 3D objects.Therefore it no longer matters if we have thousands of lights in our scene or how many polygons are in each object.We only perform lighting equations on the very final 2D output pixels. &emsp;&emsp;So deferred shading eliminates all sorts of calculations that would be required in the vertex and pixel shader for every single model in the scene.And all those complex calculations create output data that is usually discarded anyhow due to culling.So all those inefficiencies are now eliminated and our shading equations are now a fixed amount of processing regardless of scene size, number of lights, and so forth.This really opens the door so we can do more complex lighting as well as simplify and combine our shaders that already required 2D post processing. &emsp;&emsp;首先我们有一个 DeferredBufferClass 类来定义我们的 G-Buffer ，在这里我们 Buffer 中存储颜色和法线的信息，这个类由 RenderToTexture 修改而来，他如今有多个缓冲以用于将不同的属性（颜色，法线）来存储在不同位置，其声明如下： 1234567891011121314151617181920212223242526272829303132333435363738/////////////// DEFINES ///////////////const int BUFFER_COUNT = 2;//////////////// INCLUDES ////////////////#include &lt;D3D11.h&gt;#include &lt;D3DX10math.h&gt;////////////////////////////////////////////////////////////////////////////////// Class name: DeferredBuffersClass////////////////////////////////////////////////////////////////////////////////class DeferredBuffersClass&#123;public: DeferredBuffersClass(); DeferredBuffersClass(const DeferredBuffersClass&amp;); ~DeferredBuffersClass(); bool Initialize(ID3D11Device*, int, int, float, float); void Shutdown(); void SetRenderTargets(ID3D11DeviceContext*); void ClearRenderTargets(ID3D11DeviceContext*, float, float, float, float); ID3D11ShaderResourceView* GetShaderResourceView(int);private: int m_textureWidth, m_textureHeight; ID3D11Texture2D* m_renderTargetTextureArray[BUFFER_COUNT]; ID3D11RenderTargetView* m_renderTargetViewArray[BUFFER_COUNT]; ID3D11ShaderResourceView* m_shaderResourceViewArray[BUFFER_COUNT]; ID3D11Texture2D* m_depthStencilBuffer; ID3D11DepthStencilView* m_depthStencilView; D3D11_VIEWPORT m_viewport;&#125;; &emsp;&emsp;之后我们将使用 DeferredShaderClass 类来将场景渲染至我们的 G-Buffer ，首先来看我们的着色器，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108////////////////////////////////////////////////////////////////////////////////// Vertex Shader//////////////////////////////////////////////////////////////////////////////////////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType DeferredVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); return output;&#125;////////////////////////////////////////////////////////////////////////////////// Filename: deferred.ps//////////////////////////////////////////////////////////////////////////////////////////////// TEXTURES ////////////////Texture2D shaderTexture : register(t0);///////////////////// SAMPLE STATES /////////////////////SamplerState SampleTypeWrap : register(s0);//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL;&#125;;struct PixelOutputType&#123; float4 color : SV_Target0; float4 normal : SV_Target1;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////PixelOutputType DeferredPixelShader(PixelInputType input) : SV_TARGET&#123; PixelOutputType output; // Sample the color from the texture and store it for output to the render target. output.color = shaderTexture.Sample(SampleTypeWrap, input.tex); // Store the normal for output to the render target. output.normal = float4(input.normal, 1.0f); return output;&#125; &emsp;&emsp;顶点着色器和以往一样，像素着色器中，我们将渲染物体的颜色（color）和法线（normal）分别输出给不同的 TARGET 。 &emsp;&emsp;他们的 ShaderClass 相比较 TextureShaderClass 几乎没有做修改，如下： 12345678910111213141516171819202122232425262728293031323334353637////////////////////////////////////////////////////////////////////////////////// Class name: DeferredShaderClass////////////////////////////////////////////////////////////////////////////////class DeferredShaderClass&#123;private: struct MatrixBufferType &#123; D3DXMATRIX world; D3DXMATRIX view; D3DXMATRIX projection; &#125;;public: DeferredShaderClass(); DeferredShaderClass(const DeferredShaderClass&amp;); ~DeferredShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleStateWrap; ID3D11Buffer* m_matrixBuffer;&#125;; &emsp;&emsp;这样，在像素着色器阶段，我们并未做太多的运算，当渲染正常进行深度测试后，我们使用 G-Buffer 中的颜色纹理和法线纹理计算光照。这样我们计算的光照只有最终渲染的屏幕大小（width * height），当场景中存在大量物体的时候，延迟渲染显然比正向渲染快速的多。当然，由于需要存储 G-Buffer ，占用空间自然也多了一些。 &emsp;&emsp;最终渲染结果和普通渲染一个，我们所渲染的 cube 如下： &emsp;&emsp;源代码：DX11Tutorial-DeferredShading]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】46-鼠标拾取]]></title>
    <url>%2F2018%2F04%2F26%2F%E3%80%90DirectX%E3%80%9146-%E9%BC%A0%E6%A0%87%E6%8B%BE%E5%8F%96%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 47: Picking 学习记录&emsp;&emsp;这篇文章中我们主要介绍鼠标拾取（Picking），即鼠标点击选中物体的过程。本篇代码基于阴影映射代码，主要在 ApplicationClass 类中实现。 &emsp;&emsp;拾取过程一般分为两步，第一步为将鼠标从二维的屏幕坐标系转换为 3D 空间中的一个方向向量，然后使用此向量做与视野内可见 3D 物体的相交性测试，测试成功即可选中。 &emsp;&emsp;我们正常的渲染一个球体，如下： &emsp;&emsp;当我们获取到鼠标左键按下时，我们执行我们的变换以及相交测试，部分代码如下： 1234567891011121314151617// Check if the left mouse button has been pressed.if(m_Input-&gt;IsLeftMouseButtonDown() == true)&#123; // If they have clicked on the screen with the mouse then perform an intersection test. if(m_beginCheck == false) &#123; m_beginCheck = true; m_Input-&gt;GetMouseLocation(mouseX, mouseY); TestIntersection(mouseX, mouseY); &#125;&#125;// Check if the left mouse button has been released.if(m_Input-&gt;IsLeftMouseButtonDown() == false)&#123; m_beginCheck = false;&#125; &emsp;&emsp;在 TestIntersection 方法中，我们使用与我们之前从 3D 变换相反的操作将鼠标从二维屏幕坐标系变换至三维空间，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041float pointX, pointY;D3DXMATRIX projectionMatrix, viewMatrix, inverseViewMatrix, worldMatrix, translateMatrix, inverseWorldMatrix;D3DXVECTOR3 direction, origin, rayOrigin, rayDirection;bool intersect, result;// Move the mouse cursor coordinates into the -1 to +1 range.pointX = ((2.0f * (float)mouseX) / (float)m_screenWidth) - 1.0f;pointY = (((2.0f * (float)mouseY) / (float)m_screenHeight) - 1.0f) * -1.0f; // Adjust the points using the projection matrix to account for the aspect ratio of the viewport.m_D3D-&gt;GetProjectionMatrix(projectionMatrix);pointX = pointX / projectionMatrix._11;pointY = pointY / projectionMatrix._22;// Get the inverse of the view matrix.m_Camera-&gt;GetViewMatrix(viewMatrix);D3DXMatrixInverse(&amp;inverseViewMatrix, NULL, &amp;viewMatrix);// Calculate the direction of the picking ray in view space.direction.x = (pointX * inverseViewMatrix._11) + (pointY * inverseViewMatrix._21) + inverseViewMatrix._31;direction.y = (pointX * inverseViewMatrix._12) + (pointY * inverseViewMatrix._22) + inverseViewMatrix._32;direction.z = (pointX * inverseViewMatrix._13) + (pointY * inverseViewMatrix._23) + inverseViewMatrix._33;// Get the origin of the picking ray which is the position of the camera.origin = m_Camera-&gt;GetPosition();// Get the world matrix and translate to the location of the sphere.m_D3D-&gt;GetWorldMatrix(worldMatrix);D3DXMatrixTranslation(&amp;translateMatrix, -5.0f, 1.0f, 5.0f);D3DXMatrixMultiply(&amp;worldMatrix, &amp;worldMatrix, &amp;translateMatrix); // Now get the inverse of the translated world matrix.D3DXMatrixInverse(&amp;inverseWorldMatrix, NULL, &amp;worldMatrix);// Now transform the ray origin and the ray direction from view space to world space.D3DXVec3TransformCoord(&amp;rayOrigin, &amp;origin, &amp;inverseWorldMatrix);D3DXVec3TransformNormal(&amp;rayDirection, &amp;direction, &amp;inverseWorldMatrix);// Normalize the ray direction.D3DXVec3Normalize(&amp;rayDirection, &amp;rayDirection); &emsp;&emsp;最后，执行我们的射线球体相交判断方法： 1RaySphereIntersect(rayOrigin, rayDirection, 1.0f); &emsp;&emsp;方法如下： 123456789101112131415161718192021bool ApplicationClass::RaySphereIntersect(D3DXVECTOR3 rayOrigin, D3DXVECTOR3 rayDirection, float radius)&#123; float a, b, c, discriminant; // Calculate the a, b, and c coefficients. a = (rayDirection.x * rayDirection.x) + (rayDirection.y * rayDirection.y) + (rayDirection.z * rayDirection.z); b = ((rayDirection.x * rayOrigin.x) + (rayDirection.y * rayOrigin.y) + (rayDirection.z * rayOrigin.z)) * 2.0f; c = ((rayOrigin.x * rayOrigin.x) + (rayOrigin.y * rayOrigin.y) + (rayOrigin.z * rayOrigin.z)) - (radius * radius); // Find the discriminant. discriminant = (b * b) - (4 * a * c); // if discriminant is negative the picking ray missed the sphere, otherwise it intersected the sphere. if (discriminant &lt; 0.0f) &#123; return false; &#125; return true;&#125; &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11Tutorial-Picking]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图形学基础算法】四-Bresenham算法生成直线]]></title>
    <url>%2F2018%2F04%2F26%2F%E3%80%90%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9B-Bresenham%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90%E7%9B%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中我们介绍直线生成算法 Bresenham ，Bresenham 是直线生成中最常用的算法，采取加减和移位运算来实现。 &emsp;&emsp;Bresenham直线算法是用来描绘由两点所决定的直线的算法，它会算出一条线段在 n 维光栅上最接近的点。这个算法只会用到较为快速的整数加法、减法和位元移位，常用于绘制电脑画面中的直线。是计算机图形学中最先发展出来的算法。 &emsp;&emsp;其具体推算可以看这里： The Bresenham Line-Drawing Algorithm &emsp;&emsp;实现代码如下： 1234567891011121314151617181920212223242526272829303132void DrawLineBresenham(int x1, int y1, int x2, int y2, unsigned char r, unsigned char g, unsigned char b, Texture &amp;tex) &#123; tex.SetPixel(x1, y1, r, g, b); int dx = abs(x2 - x1); int dy = abs(y2 - y1); if (dx == 0 &amp;&amp; dy == 0) return; int flag = 0; if (dx &lt; dy) &#123; flag = 1; swap(x1, y1); swap(x2, y2); swap(dx, dy); &#125; int tx = (x2 - x1) &gt; 0 ? 1 : -1; int ty = (y2 - y1) &gt; 0 ? 1 : -1; int curx = x1; int cury = y1; int dS = 2 * dy; int dT = 2 * (dy - dx); int d = dS - dx; while (curx != x2) &#123; if (d &lt; 0) d += dS; else &#123; cury += ty; d += dT; &#125; if (flag) tex.SetPixel(cury, curx, r, g, b); else tex.SetPixel(curx, cury, r, g, b); curx += tx; &#125;&#125;]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
        <tag>Graphics Algorithm</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】45-渲染透明物体的阴影]]></title>
    <url>%2F2018%2F04%2F26%2F%E3%80%90DirectX%E3%80%9145-%E6%B8%B2%E6%9F%93%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 49: Shadow Mapping and Transparency 学习记录&emsp;&emsp;这篇文章中我们介绍对透明物体的阴影渲染，我们将渲染一棵树的阴影（树的叶子通常以带透明度的贴图而非实体模型呈现）。 &emsp;&emsp;当我们渲染一棵树的时候我们使用部分透明的贴图来绘制树叶，因为如果为单个树叶建模实在是太麻烦了。所以树叶一般情况下都只是一个矩形，如果我们不开启透明度，那么绘制的结果如下： &emsp;&emsp;开启了透明之后，渲染结果如下： &emsp;&emsp;树的渲染已经正常了，但是其阴影还是错误的样子。这是因为我们绘制深度图的时候是针对于模型，而透明度则是保存在纹理中的。所以要渲染正常的树阴影我们需要修改我们的深度图使其支持带纹理的深度映射。 &emsp;&emsp;首先我们修改 depth.vs 和 depth.ps ，使其支持纹理并且当纹理的不透明度低于某一个值时候我们不计算它的深度，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596////////////////////////////////////////////////////////////////////////////////// Filename: depth.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float4 depthPosition : TEXTURE0; float2 tex : TEXCOORD0;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType DepthVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the position value in a second input value for depth value calculations. output.depthPosition = output.position; output.tex = input.tex; return output;&#125;////////////////////////////////////////////////////////////////////////////////// Filename: depth.ps////////////////////////////////////////////////////////////////////////////////SamplerState samplerType : register(s0);Texture2D shaderTexture : register(t0);//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float4 depthPosition : TEXTURE0; float2 tex : TEXCOORD0;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 DepthPixelShader(PixelInputType input) : SV_TARGET&#123; float depthValue; float4 color; // Get the alpha value from the texture float alpha = shaderTexture.Sample(samplerType , input.tex).a; // discard render if the alpha less than 0.8 if(alpha &lt; 0.8) discard; // Get the depth value of the pixel by dividing the Z pixel depth by the homogeneous W coordinate. depthValue = input.depthPosition.z / input.depthPosition.w; color = float4(depthValue, depthValue, depthValue, 1.0f); return color;&#125; &emsp;&emsp;主要的改变就在这里，在 DepthShaderClass 里它只是修改为支持读取纹理，其声明如下： 12345678910111213141516171819202122232425262728293031323334353637////////////////////////////////////////////////////////////////////////////////// Class name: DepthShaderClass////////////////////////////////////////////////////////////////////////////////class DepthShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;;public: DepthShaderClass(); DepthShaderClass(const DepthShaderClass&amp;); ~DepthShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11SamplerState* m_sampleState;&#125;; &emsp;&emsp;在渲染深度图时，我们使用模型对应的纹理，部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163bool GraphicsClass::RenderSceneToTexture()&#123; DirectX::XMMATRIX worldMatrix, lightViewMatrix, lightOrthoMatrix; float posX, posY, posZ; bool result; // Turn on alpha blending m_D3D-&gt;TurnOnAlphaBlending(); // Set the render target to be the render to texture. m_RenderTexture-&gt;SetRenderTarget(m_D3D-&gt;GetDeviceContext()); // Clear the render to texture. m_RenderTexture-&gt;ClearRenderTarget(m_D3D-&gt;GetDeviceContext(), 0.0f, 0.0f, 0.0f, 1.0f); // Generate the light view matrix based on the light's position. m_Light-&gt;GenerateViewMatrix(); // Get the world matrix from the d3d object. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Get the view and orthographic matrices from the light object. m_Light-&gt;GetViewMatrix(lightViewMatrix); m_Light-&gt;GetOrthoMatrix(lightOrthoMatrix); // Setup the translation matrix for the cube model. worldMatrix *= DirectX::XMMatrixScaling(0.05f, 0.05f, 0.05f); // Render the cube model with the depth shader. m_TrunkModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_DepthShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_TrunkModel-&gt;GetIndexCount(), worldMatrix, lightViewMatrix, lightOrthoMatrix , m_TrunkModel-&gt;GetTexture()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Setup the translation matrix for the sphere model. worldMatrix *= DirectX::XMMatrixScaling(0.05f, 0.05f, 0.05f); // Render the sphere model with the depth shader. m_LeavesModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_DepthShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_LeavesModel-&gt;GetIndexCount(), worldMatrix, lightViewMatrix, lightOrthoMatrix , m_LeavesModel-&gt;GetTexture()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Setup the translation matrix for the ground model. m_GroundModel-&gt;GetPosition(posX, posY, posZ); worldMatrix *= DirectX::XMMatrixTranslation(posX, posY, posZ); // Render the ground model with the depth shader. m_GroundModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_DepthShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_GroundModel-&gt;GetIndexCount(), worldMatrix, lightViewMatrix, lightOrthoMatrix , m_GroundModel-&gt;GetTexture()); if(!result) &#123; return false; &#125; // Turn off alpha blending m_D3D-&gt;TurnOffAlphaBlending(); // Reset the render target back to the original back buffer and not the render to texture anymore. m_D3D-&gt;SetBackBufferRenderTarget(); // Reset the viewport back to the original. m_D3D-&gt;ResetViewport(); return true;&#125;bool GraphicsClass::Render()&#123; DirectX::XMMATRIX worldMatrix, viewMatrix, projectionMatrix; DirectX::XMMATRIX lightViewMatrix, lightOrthoMatrix; bool result; // First render the scene to a texture. result = RenderSceneToTexture(); if(!result) &#123; return false; &#125; // Clear the buffers to begin the scene. m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); // Turn on alpha blending m_D3D-&gt;TurnOnAlphaBlending(); // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Generate the light view matrix based on the light's position. m_Light-&gt;GenerateViewMatrix(); // Get the world, view, and projection matrices from the camera and d3d objects. m_Camera-&gt;GetViewMatrix(viewMatrix); m_D3D-&gt;GetWorldMatrix(worldMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); // Get the light's view and projection matrices from the light object. m_Light-&gt;GetViewMatrix(lightViewMatrix); m_Light-&gt;GetOrthoMatrix(lightOrthoMatrix); worldMatrix *= DirectX::XMMatrixScaling(0.05f, 0.05f, 0.05f); // Put the cube model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_TrunkModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the model using the shadow shader. result = m_ShadowShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_TrunkModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, lightOrthoMatrix, m_TrunkModel-&gt;GetTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); worldMatrix *= DirectX::XMMatrixScaling(0.05f, 0.05f, 0.05f); // Put the model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_LeavesModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_ShadowShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_LeavesModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, lightOrthoMatrix, m_LeavesModel-&gt;GetTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Render the ground model using the shadow shader. m_GroundModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_ShadowShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_GroundModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, lightOrthoMatrix, m_GroundModel-&gt;GetTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Turn off alpha blending m_D3D-&gt;TurnOffAlphaBlending(); // Present the rendered scene to the screen. m_D3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11Tutorial-ShadowMappingAndTransparency]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】44-定向光阴影映射]]></title>
    <url>%2F2018%2F04%2F25%2F%E3%80%90DirectX%E3%80%9144-%E5%AE%9A%E5%90%91%E5%85%89%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 48: Directional Shadow Maps 学习记录&emsp;&emsp;这篇文章中我们介绍对于定向光的阴影映射，本篇代码基于阴影映射篇，修改不多。 &emsp;&emsp;定向光（平行光）的阴影映射和之前不同之处在于它是基于正交投影而非透视投影的，也即是说它不会有近小远大的效果，我们将以正交投影来渲染深度图使得我们的阴影是正交投影化的。 &emsp;&emsp;首先我们修改 shadow.vs 和 shadow.ps ，现在我们不需要光的坐标而是使用定向光的方向计算，所以在 shadow.vs 里不再需要第二个缓冲，也不用进行多余的计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667////////////////////////////////////////////////////////////////////////////////// Filename: shadow.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix; matrix lightViewMatrix; matrix lightProjectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 lightViewPosition : TEXCOORD1;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType ShadowVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Calculate the position of the vertice as viewed by the light source. output.lightViewPosition = mul(input.position, worldMatrix); output.lightViewPosition = mul(output.lightViewPosition, lightViewMatrix); output.lightViewPosition = mul(output.lightViewPosition, lightProjectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); return output;&#125; &emsp;&emsp;在 shadow.ps 里我们基于传进来的光方向进行与法线的点乘： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110////////////////////////////////////////////////////////////////////////////////// Filename: shadow.ps//////////////////////////////////////////////////////////////////////////////////////////////// TEXTURES ////////////////Texture2D shaderTexture : register(t0);Texture2D depthMapTexture : register(t1);///////////////////// SAMPLE STATES /////////////////////SamplerState SampleTypeClamp : register(s0);SamplerState SampleTypeWrap : register(s1);//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer&#123; float4 ambientColor; float4 diffuseColor; float3 lightDirection; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 lightViewPosition : TEXCOORD1;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 ShadowPixelShader(PixelInputType input) : SV_TARGET&#123; float bias; float4 color; float2 projectTexCoord; float depthValue; float lightDepthValue; float lightIntensity; float4 textureColor; float3 lightDir; lightDir = -lightDirection; // Set the bias value for fixing the floating point precision issues. bias = 0.001f; // Set the default output color to the ambient light value for all pixels. color = ambientColor; // Calculate the projected texture coordinates. projectTexCoord.x = input.lightViewPosition.x / input.lightViewPosition.w / 2.0f + 0.5f; projectTexCoord.y = -input.lightViewPosition.y / input.lightViewPosition.w / 2.0f + 0.5f; // Determine if the projected coordinates are in the 0 to 1 range. If so then this pixel is in the view of the light. if((saturate(projectTexCoord.x) == projectTexCoord.x) &amp;&amp; (saturate(projectTexCoord.y) == projectTexCoord.y)) &#123; // Sample the shadow map depth value from the depth texture using the sampler at the projected texture coordinate location. depthValue = depthMapTexture.Sample(SampleTypeClamp, projectTexCoord).r; // Calculate the depth of the light. lightDepthValue = input.lightViewPosition.z / input.lightViewPosition.w; // Subtract the bias from the lightDepthValue. lightDepthValue = lightDepthValue - bias; // Compare the depth of the shadow map value and the depth of the light to determine whether to shadow or to light this pixel. // If the light is in front of the object then light the pixel, if not then shadow this pixel since an object (occluder) is casting a shadow on it. if(lightDepthValue &lt; depthValue) &#123; // Calculate the amount of light on this pixel. lightIntensity = saturate(dot(input.normal, lightDir)); if(lightIntensity &gt; 0.0f) &#123; // Determine the final diffuse color based on the diffuse color and the amount of light intensity. color += (diffuseColor * lightIntensity); // Saturate the final light color. color = saturate(color); &#125; &#125; &#125; else &#123; // If this is outside the area of shadow map range then draw things normally with regular lighting. lightIntensity = saturate(dot(input.normal, lightDir)); if(lightIntensity &gt; 0.0f) &#123; color += (diffuseColor * lightIntensity); color = saturate(color); &#125; &#125; // Sample the pixel color from the texture using the sampler at this texture coordinate location. textureColor = shaderTexture.Sample(SampleTypeWrap, input.tex); // Combine the light and texture color. color = color * textureColor; return color;&#125; &emsp;&emsp;ShadowShaderClass 被修改为适应于新着色器的渲染类，其声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051////////////////////////////////////////////////////////////////////////////////// Class name: ShadowShaderClass////////////////////////////////////////////////////////////////////////////////class ShadowShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; DirectX::XMMATRIX lightView; DirectX::XMMATRIX lightProjection; &#125;; struct LightBufferType &#123; DirectX::XMFLOAT4 ambientColor; DirectX::XMFLOAT4 diffuseColor; DirectX::XMFLOAT3 lightDirection; float padding; &#125;;public: ShadowShaderClass(); ShadowShaderClass(const ShadowShaderClass&amp;); ~ShadowShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleStateWrap; ID3D11SamplerState* m_sampleStateClamp; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_lightBuffer;&#125;; &emsp;&emsp;现在我们需要定向光以及正交投影，所以我们在 LightClass 里添加这两个的对象以及生成方法： 12345678910111213141516171819////////////////////////////////////////////////////////////////////////////////// Class name: LightClass////////////////////////////////////////////////////////////////////////////////class LightClass&#123;public: ... void GenerateOrthoMatrix(float, float, float); void GetOrthoMatrix(DirectX::XMMATRIX&amp;); void SetDirection(float, float, float); DirectX::XMFLOAT3 GetDirection(); ...private: ... DirectX::XMMATRIX m_orthoMatrix; DirectX::XMFLOAT3 m_lightDirection;&#125;; &emsp;&emsp;最后，我们使用它的正交矩阵来渲染深度图和最终效果，部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205bool GraphicsClass::Frame(float posX, float posY, float posZ, float rotX, float rotY, float rotZ)&#123; bool result; static float lightAngle = 270.0f; float radians; static float lightPosX = 9.0f; // Set the position of the camera. m_Camera-&gt;SetPosition(posX, posY, posZ); m_Camera-&gt;SetRotation(rotX, rotY, rotZ); lightPosX -= 0.003f; // Update the angle of the light each frame. lightAngle -= 0.03f; if(lightAngle &lt; 90.0f) &#123; lightAngle = 270.0f; // Reset the light position also. lightPosX = 9.0f; &#125; radians = lightAngle * 0.0174532925f; // Update the direction of the light. m_Light-&gt;SetDirection(sinf(radians), cosf(radians), 0.0f); m_Light-&gt;SetPosition(lightPosX, 8.0f, -1.0f); m_Light-&gt;SetLookAt(0.0f, 0.0f, 0.0f); // Render the graphics scene. result = Render(); if(!result) &#123; return false; &#125; return true;&#125;bool GraphicsClass::RenderSceneToTexture()&#123; DirectX::XMMATRIX worldMatrix, lightViewMatrix, lightOrthoMatrix; float posX, posY, posZ; bool result; // Set the render target to be the render to texture. m_RenderTexture-&gt;SetRenderTarget(m_D3D-&gt;GetDeviceContext()); // Clear the render to texture. m_RenderTexture-&gt;ClearRenderTarget(m_D3D-&gt;GetDeviceContext(), 0.0f, 0.0f, 0.0f, 1.0f); // Generate the light view matrix based on the light's position. m_Light-&gt;GenerateViewMatrix(); // Get the world matrix from the d3d object. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Get the view and orthographic matrices from the light object. m_Light-&gt;GetViewMatrix(lightViewMatrix); m_Light-&gt;GetOrthoMatrix(lightOrthoMatrix); // Setup the translation matrix for the cube model. m_CubeModel-&gt;GetPosition(posX, posY, posZ); worldMatrix *= DirectX::XMMatrixTranslation(posX, posY, posZ); // Render the cube model with the depth shader. m_CubeModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_DepthShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_CubeModel-&gt;GetIndexCount(), worldMatrix, lightViewMatrix, lightOrthoMatrix); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Setup the translation matrix for the sphere model. m_SphereModel-&gt;GetPosition(posX, posY, posZ); worldMatrix *= DirectX::XMMatrixTranslation(posX, posY, posZ); // Render the sphere model with the depth shader. m_SphereModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_DepthShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_SphereModel-&gt;GetIndexCount(), worldMatrix, lightViewMatrix, lightOrthoMatrix); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Setup the translation matrix for the ground model. m_GroundModel-&gt;GetPosition(posX, posY, posZ); worldMatrix *= DirectX::XMMatrixTranslation(posX, posY, posZ); // Render the ground model with the depth shader. m_GroundModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_DepthShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_GroundModel-&gt;GetIndexCount(), worldMatrix, lightViewMatrix, lightOrthoMatrix); if(!result) &#123; return false; &#125; // Reset the render target back to the original back buffer and not the render to texture anymore. m_D3D-&gt;SetBackBufferRenderTarget(); // Reset the viewport back to the original. m_D3D-&gt;ResetViewport(); return true;&#125;bool GraphicsClass::Render()&#123; DirectX::XMMATRIX worldMatrix, viewMatrix, projectionMatrix; DirectX::XMMATRIX lightViewMatrix, lightOrthoMatrix; bool result; float posX, posY, posZ; // First render the scene to a texture. result = RenderSceneToTexture(); if(!result) &#123; return false; &#125; // Clear the buffers to begin the scene. m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Generate the light view matrix based on the light's position. m_Light-&gt;GenerateViewMatrix(); // Get the world, view, and projection matrices from the camera and d3d objects. m_Camera-&gt;GetViewMatrix(viewMatrix); m_D3D-&gt;GetWorldMatrix(worldMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); // Get the light's view and projection matrices from the light object. m_Light-&gt;GetViewMatrix(lightViewMatrix); m_Light-&gt;GetOrthoMatrix(lightOrthoMatrix); // Setup the translation matrix for the cube model. m_CubeModel-&gt;GetPosition(posX, posY, posZ); worldMatrix *= DirectX::XMMatrixTranslation(posX, posY, posZ); // Put the cube model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_CubeModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the model using the shadow shader. result = m_ShadowShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_CubeModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, lightOrthoMatrix, m_CubeModel-&gt;GetTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Setup the translation matrix for the sphere model. m_SphereModel-&gt;GetPosition(posX, posY, posZ); worldMatrix *= DirectX::XMMatrixTranslation(posX, posY, posZ); // Put the model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_SphereModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_ShadowShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_SphereModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, lightOrthoMatrix, m_SphereModel-&gt;GetTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Setup the translation matrix for the ground model. m_GroundModel-&gt;GetPosition(posX, posY, posZ); worldMatrix *= DirectX::XMMatrixTranslation(posX, posY, posZ); // Render the ground model using the shadow shader. m_GroundModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_ShadowShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_GroundModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, lightOrthoMatrix, m_GroundModel-&gt;GetTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Present the rendered scene to the screen. m_D3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;最终效果： &emsp;&emsp;源代码：DX11Tutorial-DirectionalShadowMaps]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图形学基础算法】叁-PTP法生成直线]]></title>
    <url>%2F2018%2F04%2F24%2F%E3%80%90%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%91%E5%8F%81-PTP%E6%B3%95%E7%94%9F%E6%88%90%E7%9B%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中我们简单介绍 PTP (point to point comparison method ：逐点比较法) 生成直线算法，它是在画线过程中，每画一点就与理想直线比较，已决定下一点的走向，以步步紧逼的方法点亮最接近直线的一组像素。 &emsp;&emsp;逐点比较发绘制前，先将直线平移，使 y 坐标较小的点位于坐标原点，这样整条直线都可在第一象限和第二象限中去讨论。这里平移的方法是从直线的两端点中找出 y 较小的点，将起点和终点均减去此点坐标。 &emsp;&emsp;平移后，根据另一个点的 x 来判断直线斜率（小于 0 则斜率为负 ，在第二象限，大于 0 相反）。 &emsp;&emsp;算法根据点在理想直线的位置来判断像素移动（每次移动一个像素），如果像素在直线上方则根据象限不同选择向左还是向右移动，如果在直线下方则向上移动。 &emsp;&emsp;偏差公式表示为：F_M=y_Mx_A-y_Ax_M 。M 为画笔的当前位置，x_M 和 y_M 则是当前位置的 x ，y 坐标绝对值。而 A 则是终点的坐标（起点是原点）绝对值。当 F_M > 0 的时候，则代表当前点在理想点上方，我们下一步的点应该是 (x + 1 , y) 或者 (x-1 , y)，相反则是 (x , y+1) 。 &emsp;&emsp;这里的公式我们每次需要计算两次乘法，计算量较大。可以进行优化，我们通过前一点的偏差来推算后一点的偏差。 &emsp;&emsp;设画笔的当前位置为 M_1(x_1,y_1) ，此时 F_1=y_1x_A-y_ax_1=0 ，则 x 方向应走 +1 步到 M_3 ，即 \left\{ \begin{array}\\ x_3=x_2+1 \\ y_3=y_2 \end{array} \right.&emsp;&emsp;F_3 为 ：F_3=F_2-y_A 。 &emsp;&emsp;递推可得每一步的结果，而对于第二象限，当 F_i >= 0 ，y 走 +1 ，x_{i+1} = x_i , y_{i+1}=y_i+1 , F_{i+1}=F_i-(-x_A)，当 F_i]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
        <tag>Graphics Algorithm</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】43-多光源阴影映射]]></title>
    <url>%2F2018%2F04%2F24%2F%E3%80%90DirectX%E3%80%9143-%E5%A4%9A%E5%85%89%E6%BA%90%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考资料Tutorial 41: Multiple Light Shadow Mapping 学习记录&emsp;&emsp;这篇文章中我们介绍多光源环境下的阴影映射，基于上一篇中的代码，我们只需要修改很少一部分。 &emsp;&emsp;我们假定有两个光源，位于场景的左右两侧，我们在 shadow.vs 中添加光源信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106////////////////////////////////////////////////////////////////////////////////// Filename: shadow.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix; matrix lightViewMatrix; matrix lightProjectionMatrix; matrix lightViewMatrix2; matrix lightProjectionMatrix2;&#125;;//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer2&#123; float3 lightPosition; float padding1; float3 lightPosition2; float padding2;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 lightViewPosition : TEXCOORD1; float3 lightPos : TEXCOORD2; float4 lightViewPosition2 : TEXCOORD3; float3 lightPos2 : TEXCOORD4;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType ShadowVertexShader(VertexInputType input)&#123; PixelInputType output; float4 worldPosition; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Calculate the position of the vertice as viewed by the light source. output.lightViewPosition = mul(input.position, worldMatrix); output.lightViewPosition = mul(output.lightViewPosition, lightViewMatrix); output.lightViewPosition = mul(output.lightViewPosition, lightProjectionMatrix); output.lightViewPosition2 = mul(input.position, worldMatrix); output.lightViewPosition2 = mul(output.lightViewPosition2, lightViewMatrix2); output.lightViewPosition2 = mul(output.lightViewPosition2, lightProjectionMatrix2); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); // Calculate the position of the vertex in the world. worldPosition = mul(input.position, worldMatrix); // Determine the light position based on the position of the light and the position of the vertex in the world. output.lightPos = lightPosition.xyz - worldPosition.xyz; // Normalize the light position vector. output.lightPos = normalize(output.lightPos); // Determine the light position based on the position of the light and the position of the vertex in the world. output.lightPos2 = lightPosition2.xyz - worldPosition.xyz; // Normalize the light position vector. output.lightPos2 = normalize(output.lightPos2); return output;&#125; &emsp;&emsp;在 shadow.ps 中我们使用两张深度图处理两次光照，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144////////////////////////////////////////////////////////////////////////////////// Filename: shadow.ps//////////////////////////////////////////////////////////////////////////////////////////////// TEXTURES ////////////////Texture2D shaderTexture : register(t0);Texture2D depthMapTexture : register(t1);Texture2D depthMapTexture2 : register(t2);///////////////////// SAMPLE STATES /////////////////////SamplerState SampleTypeClamp : register(s0);SamplerState SampleTypeWrap : register(s1);//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer&#123; float4 ambientColor; float4 diffuseColor; float4 diffuseColor2;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 lightViewPosition : TEXCOORD1; float3 lightPos : TEXCOORD2; float4 lightViewPosition2 : TEXCOORD3; float3 lightPos2 : TEXCOORD4;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 ShadowPixelShader(PixelInputType input) : SV_TARGET&#123; float bias; float4 color; float2 projectTexCoord; float depthValue; float lightDepthValue; float lightIntensity; float4 textureColor; // Set the bias value for fixing the floating point precision issues. bias = 0.001f; // Set the default output color to the ambient light value for all pixels. color = ambientColor; // Calculate the projected texture coordinates. projectTexCoord.x = input.lightViewPosition.x / input.lightViewPosition.w / 2.0f + 0.5f; projectTexCoord.y = -input.lightViewPosition.y / input.lightViewPosition.w / 2.0f + 0.5f; // Determine if the projected coordinates are in the 0 to 1 range. If so then this pixel is in the view of the light. if((saturate(projectTexCoord.x) == projectTexCoord.x) &amp;&amp; (saturate(projectTexCoord.y) == projectTexCoord.y)) &#123; // Sample the shadow map depth value from the depth texture using the sampler at the projected texture coordinate location. depthValue = depthMapTexture.Sample(SampleTypeClamp, projectTexCoord).r; // Calculate the depth of the light. lightDepthValue = input.lightViewPosition.z / input.lightViewPosition.w; // Subtract the bias from the lightDepthValue. lightDepthValue = lightDepthValue - bias; // Compare the depth of the shadow map value and the depth of the light to determine whether to shadow or to light this pixel. // If the light is in front of the object then light the pixel, if not then shadow this pixel since an object (occluder) is casting a shadow on it. if(lightDepthValue &lt; depthValue) &#123; // Calculate the amount of light on this pixel. lightIntensity = saturate(dot(input.normal, input.lightPos)); if(lightIntensity &gt; 0.0f) &#123; // Determine the final diffuse color based on the diffuse color and the amount of light intensity. color += (diffuseColor * lightIntensity); // Saturate the final light color. color = saturate(color); &#125; &#125; &#125; // Calculate the projected texture coordinates. projectTexCoord.x = input.lightViewPosition2.x / input.lightViewPosition2.w / 2.0f + 0.5f; projectTexCoord.y = -input.lightViewPosition2.y / input.lightViewPosition2.w / 2.0f + 0.5f; // Determine if the projected coordinates are in the 0 to 1 range. If so then this pixel is in the view of the light. if((saturate(projectTexCoord.x) == projectTexCoord.x) &amp;&amp; (saturate(projectTexCoord.y) == projectTexCoord.y)) &#123; // Sample the shadow map depth value from the depth texture using the sampler at the projected texture coordinate location. depthValue = depthMapTexture2.Sample(SampleTypeClamp, projectTexCoord).r; // Calculate the depth of the light. lightDepthValue = input.lightViewPosition2.z / input.lightViewPosition2.w; // Subtract the bias from the lightDepthValue. lightDepthValue = lightDepthValue - bias; // Compare the depth of the shadow map value and the depth of the light to determine whether to shadow or to light this pixel. // If the light is in front of the object then light the pixel, if not then shadow this pixel since an object (occluder) is casting a shadow on it. if(lightDepthValue &lt; depthValue) &#123; // Calculate the amount of light on this pixel. lightIntensity = saturate(dot(input.normal, input.lightPos2)); if(lightIntensity &gt; 0.0f) &#123; // Determine the final diffuse color based on the diffuse color and the amount of light intensity. color += (diffuseColor * lightIntensity); // Saturate the final light color. color = saturate(color); &#125; &#125; &#125; color = saturate(color); // Sample the pixel color from the texture using the sampler at this texture coordinate location. textureColor = shaderTexture.Sample(SampleTypeWrap, input.tex); // Combine the light and texture color. color = color * textureColor; return color;&#125; &emsp;&emsp;ShadowShaderClass 和之前不同的部分也只是增加了一份光源信息，它的声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263////////////////////////////////////////////////////////////////////////////////// Class name: ShadowShaderClass////////////////////////////////////////////////////////////////////////////////class ShadowShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; DirectX::XMMATRIX lightView; DirectX::XMMATRIX lightProjection; DirectX::XMMATRIX lightView2; DirectX::XMMATRIX lightProjection2; &#125;; struct LightBufferType &#123; DirectX::XMFLOAT4 ambientColor; DirectX::XMFLOAT4 diffuseColor; DirectX::XMFLOAT4 diffuseColor2; &#125;; struct LightBufferType2 &#123; DirectX::XMFLOAT3 lightPosition; float padding; DirectX::XMFLOAT3 lightPosition2; float padding2; &#125;;public: ShadowShaderClass(); ShadowShaderClass(const ShadowShaderClass&amp;); ~ShadowShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleStateWrap; ID3D11SamplerState* m_sampleStateClamp; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_lightBuffer; ID3D11Buffer* m_lightBuffer2;&#125;; &emsp;&emsp;修改完 ShadowShaderClass 后，我们在 GraphicsClass 里新增一个 LightClass 对象和一个 RenderToTexture 对象，并为他们进行相应的初始化。 &emsp;&emsp;在渲染时，我们设置光源位置为场景上方的左右两侧，然后分别渲染至纹理，最后使用两张纹理渲染最终场景，部分代码如下： 12345678910111213141516171819202122232425// Update the position of the light.m_Light-&gt;SetPosition(5.0f, 8.0f, -5.0f);m_Light1-&gt;SetPosition(-5.0f, 8.0f, -5.0f);...DirectX::XMMATRIX worldMatrix, viewMatrix, projectionMatrix;DirectX::XMMATRIX lightViewMatrix, lightProjectionMatrix;DirectX::XMMATRIX lightViewMatrix1, lightProjectionMatrix1;bool result;float posX, posY, posZ;// First render the scene to a texture.result = RenderSceneToTexture();if(!result)&#123; return false;&#125;// render the scene to a texture.result = RenderSceneToTexture2();if(!result)&#123; return false;&#125;... &emsp;&emsp;最终效果如下： &emsp;&emsp;源代码：DX11Tutorial-MultipleLightShadowMapping]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】42-阴影映射]]></title>
    <url>%2F2018%2F04%2F24%2F%E3%80%90DirectX%E3%80%9142-%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 40: Shadow Mapping 阴影技术：Shadow Map 初探 Tutorial 16 : Shadow mapping 学习记录&emsp;&emsp;这篇文章中我们介绍在 DX11 中实现阴影映射。 &emsp;&emsp;阴影的示意图如下： &emsp;&emsp;The basic shadowmap algorithm consists in two passes. First, the scene is rendered from the point of view of the light. Only the depth of each fragment is computed. Next, the scene is rendered as usual, but with an extra test to see it the current fragment is in the shadow. &emsp;&emsp;The “being in the shadow” test is actually quite simple. If the current sample is further from the light than the shadowmap at the same point, this means that the scene contains an object that is closer to the light. In other words, the current fragment is in the shadow. &emsp;&emsp;我们对于动态阴影的渲染可以分为以下两个部分：1. 以光的视角来渲染一张纹理，这张纹理上存储了像素点的深度，我们称它为深度图。2. 正常渲染，不同的是我们在像素着色器中判断当前像素的深度，如果它大于深度图中存储的深度，则它处于阴影中。 &emsp;&emsp;这么想的话其实并不复杂，我们首先使用 RenderToTexture 技术将像素的深度存入我们的深度图，我们需要一个 DepthShaderClass 以及对应着色器。由于只是存入深度信息，所以比较简单。 &emsp;&emsp;着色器代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970////////////////////////////////////////////////////////////////////////////////// Filename: depth.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float4 depthPosition : TEXTURE0;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType DepthVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the position value in a second input value for depth value calculations. output.depthPosition = output.position; return output;&#125;////////////////////////////////////////////////////////////////////////////////// Filename: depth.ps//////////////////////////////////////////////////////////////////////////////////////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float4 depthPosition : TEXTURE0;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 DepthPixelShader(PixelInputType input) : SV_TARGET&#123; float depthValue; float4 color; // Get the depth value of the pixel by dividing the Z pixel depth by the homogeneous W coordinate. depthValue = input.depthPosition.z / input.depthPosition.w; color = float4(depthValue, depthValue, depthValue, 1.0f); return color;&#125; &emsp;&emsp;其对应的 DepthShaderClass 类也比较简单，在此我们贴出声明： 123456789101112131415161718192021222324252627282930313233343536////////////////////////////////////////////////////////////////////////////////// Class name: DepthShaderClass////////////////////////////////////////////////////////////////////////////////class DepthShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;;public: DepthShaderClass(); DepthShaderClass(const DepthShaderClass&amp;); ~DepthShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer;&#125;; &emsp;&emsp;相比较而言，我们需要注意的是 shadow 着色器的内容，如我们上边所言，我们需要使用深度图中的深度进行比较，所以需要计算当前像素相对于光源的深度，在 vertex 中我们完成计算光源坐标以及方向，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990////////////////////////////////////////////////////////////////////////////////// Filename: shadow.vs/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix; matrix lightViewMatrix; matrix lightProjectionMatrix;&#125;;//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer2&#123; float3 lightPosition; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 lightViewPosition : TEXCOORD1; float3 lightPos : TEXCOORD2;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType ShadowVertexShader(VertexInputType input)&#123; PixelInputType output; float4 worldPosition; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Calculate the position of the vertice as viewed by the light source. output.lightViewPosition = mul(input.position, worldMatrix); output.lightViewPosition = mul(output.lightViewPosition, lightViewMatrix); output.lightViewPosition = mul(output.lightViewPosition, lightProjectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); // Calculate the position of the vertex in the world. worldPosition = mul(input.position, worldMatrix); // Determine the light position based on the position of the light and the position of the vertex in the world. output.lightPos = lightPosition.xyz - worldPosition.xyz; // Normalize the light position vector. output.lightPos = normalize(output.lightPos); return output;&#125; &emsp;&emsp;在像素着色器中我们读出投影到当前像素的深度图中的深度，然后使用变换后的相对于光源的坐标来得到相对于光源的深度，然后进行比较，当深度小于深度图中深度的时候我们对他进行正常光照，相反则只进行环境光计算，达到阴影效果。像素着色器中代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104////////////////////////////////////////////////////////////////////////////////// Filename: shadow.ps//////////////////////////////////////////////////////////////////////////////////////////////// TEXTURES ////////////////Texture2D shaderTexture : register(t0);Texture2D depthMapTexture : register(t1);///////////////////// SAMPLE STATES /////////////////////SamplerState SampleTypeClamp : register(s0);SamplerState SampleTypeWrap : register(s1);//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer&#123; float4 ambientColor; float4 diffuseColor;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 lightViewPosition : TEXCOORD1; float3 lightPos : TEXCOORD2;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 ShadowPixelShader(PixelInputType input) : SV_TARGET&#123; float bias; float4 color; float2 projectTexCoord; float depthValue; float lightDepthValue; float lightIntensity; float4 textureColor; // Set the bias value for fixing the floating point precision issues. bias = 0.001f; // Set the default output color to the ambient light value for all pixels. color = ambientColor; // Calculate the projected texture coordinates. projectTexCoord.x = input.lightViewPosition.x / input.lightViewPosition.w / 2.0f + 0.5f; projectTexCoord.y = -input.lightViewPosition.y / input.lightViewPosition.w / 2.0f + 0.5f; // Determine if the projected coordinates are in the 0 to 1 range. If so then this pixel is in the view of the light. if((saturate(projectTexCoord.x) == projectTexCoord.x) &amp;&amp; (saturate(projectTexCoord.y) == projectTexCoord.y)) &#123; // Sample the shadow map depth value from the depth texture using the sampler at the projected texture coordinate location. depthValue = depthMapTexture.Sample(SampleTypeClamp, projectTexCoord).r; // Calculate the depth of the light. lightDepthValue = input.lightViewPosition.z / input.lightViewPosition.w; // Subtract the bias from the lightDepthValue. lightDepthValue = lightDepthValue - bias; // Compare the depth of the shadow map value and the depth of the light to determine whether to shadow or to light this pixel. // If the light is in front of the object then light the pixel, if not then shadow this pixel since an object (occluder) is casting a shadow on it. if(lightDepthValue &lt; depthValue) &#123; // Calculate the amount of light on this pixel. lightIntensity = saturate(dot(input.normal, input.lightPos)); if(lightIntensity &gt; 0.0f) &#123; // Determine the final diffuse color based on the diffuse color and the amount of light intensity. color += (diffuseColor * lightIntensity); // Saturate the final light color. color = saturate(color); &#125; &#125; &#125; // Sample the pixel color from the texture using the sampler at this texture coordinate location. textureColor = shaderTexture.Sample(SampleTypeWrap, input.tex); // Combine the light and texture color. color = color * textureColor; return color;&#125; &emsp;&emsp;关于光照，投影映射我们之前的文章中都有介绍。 &emsp;&emsp;Shadow shader 对应的着色器类也仅仅是缓冲的不同，我们依旧只列出其类声明，具体实现可以参考源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556////////////////////////////////////////////////////////////////////////////////// Class name: ShadowShaderClass////////////////////////////////////////////////////////////////////////////////class ShadowShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; DirectX::XMMATRIX lightView; DirectX::XMMATRIX lightProjection; &#125;; struct LightBufferType &#123; DirectX::XMFLOAT4 ambientColor; DirectX::XMFLOAT4 diffuseColor; &#125;; struct LightBufferType2 &#123; DirectX::XMFLOAT3 lightPosition; float padding; &#125;;public: ShadowShaderClass(); ShadowShaderClass(const ShadowShaderClass&amp;); ~ShadowShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleStateWrap; ID3D11SamplerState* m_sampleStateClamp; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_lightBuffer; ID3D11Buffer* m_lightBuffer2;&#125;; &emsp;&emsp;在 GraphicsClass 中我们首先通过 DepthShaderClass 对象将深度信息绘制进纹理中，然后再使用 ShadowShaderClass 对象进行渲染，部分代码如下： 12345678910111213141516171819202122232425262728bool GraphicsClass::Frame(float posX, float posY, float posZ, float rotX, float rotY, float rotZ)&#123; bool result; static float lightPositionX = -5.0f; // Set the position of the camera. m_Camera-&gt;SetPosition(posX, posY, posZ); m_Camera-&gt;SetRotation(rotX, rotY, rotZ); // Update the position of the light each frame. lightPositionX += 0.05f; if(lightPositionX &gt; 5.0f) &#123; lightPositionX = -5.0f; &#125; // Update the position of the light. m_Light-&gt;SetPosition(lightPositionX, 8.0f, -5.0f); // Render the graphics scene. result = Render(); if(!result) &#123; return false; &#125; return true;&#125; &emsp;&emsp;我们设计了一个在场景上方缓缓移动的光源，这样我们可以看到阴影的变化，某一刻的效果如下： &emsp;&emsp;源代码：DX11Tutorial-ShadowMapping]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图形学基础算法】贰-DDA法生成直线]]></title>
    <url>%2F2018%2F04%2F23%2F%E3%80%90%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%B0-DDA%E6%B3%95%E7%94%9F%E6%88%90%E7%9B%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中我们简单介绍 DDA （Digital differential analyzer ：数值微分法），它根据直线的微分方程来绘制直线，是最简单的一种画线方法。 &emsp;&emsp;设直线的起点坐标为 P_s(x_s,y_s) ，终点坐标为P_e(x_e,y_e) ，令 \Delta{x} = x_e-x_s，\Delta{y} = y_e-y_s ，则要绘制的直线微分方程为 \frac{dx}{dt} = \Delta{x} , \frac{dy}{dt} = \Delta{y}&emsp;&emsp;将上式中的微分用差商来代替，即得： \frac{x_{i+1}-x_{i}}{t_{i+1}-t_i} = \Delta{x} , \frac{y_{i+1}-y_{i}}{t_{i+1}-t_i} = \Delta{y}&emsp;&emsp;令 \Delta{m}=max(|\Delta{x}|,|\Delta{y}|) ，取时间步长为 t2-t1=1/\Delta{m} ，则每走一步，可得微分方程数值解得递推公式为 x_{i+1}=x_i+\Delta{x}/\Delta{m} , y_{i+1}=y_i+\Delta{y}/\Delta{m}&emsp;&emsp;根据此公式，即可简单的推出我们我们下一步的像素坐标，转换为代码如下： 12345678910111213141516171819void DrawLineDDA(int x1 , int y1 , int x2 , int y2 , unsigned char r , unsigned char g , unsigned char b , Texture&amp; tex)&#123; int dm = 0; if (abs(x2 - x1) &gt;= abs(y2 - y1))&#123; dm = abs(x2 - x1); &#125; else &#123; dm = abs(y2 - y1); &#125; float dx = (float)(x2 - x1) / dm; float dy = (float)(y2 - y1) / dm; float x = static_cast&lt;float&gt;(x1 + 0.5); float y = static_cast&lt;float&gt;(y1 + 0.5); for (int i = 0; i &lt; dm; ++i) &#123; tex.SetPixel((int)x , (int)y , r , g , b); x += dx; y += dy; &#125;&#125; &emsp;&emsp;在我们的主循环中调用这个方法绘制两条斜线，如下： 123456789101112131415161718while (!glfwWindowShouldClose(pWindow)) &#123; glfwPollEvents(); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glClearColor(0.0f, 0.0f, 0.0f, 1.0f); glslShader.use(); glslTex.Use(); screen.Use(); glslTex.ClearPixel(); DrawLineDDA(100 , 100 , 700 , 400 , 0 , 255 , 0 , glslTex); DrawLineDDA(100 , 400 , 700 , 100 , 255 , 0 , 0 , glslTex); glDrawElements(GL_TRIANGLES , screen.IndexCount() , GL_UNSIGNED_INT , 0); glfwSwapBuffers(pWindow);&#125; &emsp;&emsp;最终效果： &emsp;&emsp;参考资料 ：《计算机图形学基础（OpenGL版）》]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
        <tag>Graphics Algorithm</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图形学基础算法】壹-本系列代码框架]]></title>
    <url>%2F2018%2F04%2F23%2F%E3%80%90%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%91%E5%A3%B9-%E6%9C%AC%E7%B3%BB%E5%88%97%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在光栅扫描显示器等设备上，所有图形的显示都归结为按照图形的描述将显示设备上的光栅像素点亮。为了输出一个像素，需要将该像素的坐标和颜色信息转换成输出设备的相应指令，根据指令在指定的屏幕位置上开启（接通）电路（电子束），将该位置上的显示单元器件发亮。基本图元显示问题就是根据基本图元的描述信息来生成像素组合。 ——《计算机图形学基础（OpenGL版）》 &emsp;&emsp;本系列文章主要介绍根据描述来生成基本图元的算法，例如两点生成直线。 &emsp;&emsp;这篇文章中我们主要实现基础的一个 OpenGL 代码框架来为我们之后的直线或者其他图形生成来做准备。如果你还完全不懂 OpenGL ，那么可以参考本博客站中的 OpenGL 学习记录。 &emsp;&emsp;在很多介绍这些基本算法的文章或者书中，要么是 OpenGL 伪代码，要么是使用命令行来绘制（毕竟算法才是本体），现代 OpenGL 中已经没有了直接操作像素的方法 SetPixel() （使用 OpenGL 3.0+ 和 GLEW , GLFW），所以我们使用了纹理来代替。我们将纹理覆盖在窗口，然后通过修改纹理的数据来达到类似于设置像素的结果。 &emsp;&emsp;基础框架的 Shader 代码极为简单： 123456789101112131415161718192021222324//File Name : vertexShader.glsl#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTex;out vec2 tex;void main()&#123; tex = aTex; gl_Position = vec4(aPos, 1.0f);&#125;//File Name : fragmentShader.glsl#version 330 coreuniform sampler2D samp;in vec2 tex;out vec4 FragColor;void main()&#123; FragColor = texture(samp , tex);&#125; &emsp;&emsp;编译和链接此 Shader 程序的代码暂且不提，之后可以在文末下载。我们主要来看看我们实现 SetPixel 方法的过程。 &emsp;&emsp;我们的纹理将使用我们自己定义的一个数组，如下： 123456789101112131415161718192021222324/* * File : Texture * Author : KsGin * Date : 2018/4/17 */#include &lt;string&gt;#include &lt;GL/glew.h&gt;#include &lt;iostream&gt;class Texture &#123;public: unsigned int ID; unsigned char *data; int width, height; Texture(int w, int h); void UpdateTexture(); void Use(); void SetPixel(int w, int h, unsigned char r, unsigned char g, unsigned char b);&#125;; &emsp;&emsp;这是我们 Texture 类的声明，它共包括四个方法，构造方法，更新，绑定和我们所需要的 SetPixel ，在构造方法中我们接收纹理的 width 和 height 参数，并初始化 data 。 1234width = w;height = h;data = new unsigned char[w * h * 3];memset(data, 0, sizeof(unsigned char) * 3 * height * width); &emsp;&emsp;同时也初始化纹理： 1234567glGenTextures(1, &amp;ID);glBindTexture(GL_TEXTURE_2D, ID);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); &emsp;&emsp;我们的纹理类型为 GL_RGB 三通道，所以 data 的大小应该为 w h 3 。 &emsp;&emsp;在 Use() 方法中我们绑定纹理，在 UpdateTexture 中我们使用 data 加载纹理： 123456void Use() &#123; glBindTexture(GL_TEXTURE_2D, ID);&#125;void UpdateTexture() &#123; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);&#125; &emsp;&emsp;事实上这几个方法都是为 SetPixel() 服务 ，SetPixel() 方法中我们修改 data 数据后调用 Use 和 UpdateTexture() 。SetPixel 方法接受要修改的像素坐标以及要设置的颜色： 1234567void SetPixel(int w, int h, unsigned char r, unsigned char g, unsigned char b) &#123; data[width * (h - 1) * 3 + w * 3 - 2] = r; data[width * (h - 1) * 3 + w * 3 - 1] = g; data[width * (h - 1) * 3 + w * 3 - 0] = b; Use(); UpdateTexture();&#125; &emsp;&emsp;现在，我们创建这么一个简单的 SetPixel 方法，在 OpenGL 的窗口中我们调用这个纹理，并生成一条直线，完整的 main 文件代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;#include "Headers/Shader.hpp"#include "Headers/Texture.hpp"#include "Headers/Model.hpp"using namespace std;using namespace glm;const int width = 800, height = 500;void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mode);int main() &#123; if (!glfwInit()) &#123; cout &lt;&lt; "Init GLFW failed" &lt;&lt; endl; glfwTerminate(); return -1; &#125; glfwWindowHint(GLFW_SAMPLES, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE); GLFWwindow *pWindow = glfwCreateWindow(width, height, "Graphics Algorithm", nullptr, nullptr); if (!pWindow) &#123; cout &lt;&lt; "Create window failed" &lt;&lt; endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(pWindow); glewExperimental = GL_TRUE; if (glewInit() != GLEW_OK) &#123; cout &lt;&lt; "Failed to init GLEW" &lt;&lt; endl; return -1; &#125; glfwSetKeyCallback(pWindow, KeyCallback); glDisable(GL_DEPTH_TEST); auto glslShader = Shader("../Shaders/vertexShader.glsl", "../Shaders/fragmentShader.glsl"); auto glslTex = Texture(width , height); auto screen = Model("../Resources/screen.txt"); while (!glfwWindowShouldClose(pWindow)) &#123; glfwPollEvents(); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glClearColor(0.0f, 0.0f, 0.0f, 1.0f); glslShader.use(); glslTex.Use(); screen.Use(); for (int i = 0; i &lt; 600; ++i) &#123; glslTex.SetPixel(100 + i , 250 , 255 , 255 , 255); &#125; glDrawElements(GL_TRIANGLES , screen.IndexCount() , GL_UNSIGNED_INT , 0); glfwSwapBuffers(pWindow); &#125; return 0;&#125;void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mode) &#123; if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, GL_TRUE); &#125;&#125; &emsp;&emsp;最终效果如下： &emsp;&emsp;完整代码：GraphicsAlgorithm]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
        <tag>Graphics Algorithm</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】41-光照投影映射]]></title>
    <url>%2F2018%2F04%2F22%2F%E3%80%90DirectX%E3%80%9141-%E5%85%89%E7%85%A7%E6%8A%95%E5%BD%B1%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 44: Projected Light Maps 学习记录&emsp;&emsp;这篇文章中，我们基于上篇的代码来实现光照纹理投影。这篇使用上一篇文章的代码，我们仅仅简单的改动了片段着色器。 &emsp;&emsp;我们使用上一篇的场景： &emsp;&emsp;以及一张纹理贴图： &emsp;&emsp;我们使用上一篇中介绍的方法将这张图片投影到我们的场景下，直接投影上去效果如下： &emsp;&emsp;但我们的目的并非这样，我们将从纹理中读取的数据不直接输出，而是作为光照强度，乘以场景本身纹理颜色，PixelShader 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//////////////// TEXTURES ////////////////Texture2D shaderTexture : register(t0);Texture2D projectionTexture : register(t1);//////////////// SAMPLERS ////////////////SamplerState SampleType;//////////////////////// CONSTANT BUFFERS ////////////////////////cbuffer LightBuffer&#123; float4 ambientColor; float4 diffuseColor; float3 lightDirection; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 viewPosition : TEXCOORD1;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 ProjectionPixelShader(PixelInputType input) : SV_TARGET&#123; float4 textureColor; float2 projectTexCoord; float4 projectionColor; float4 color; // Sample the pixel color from the texture using the sampler at this texture coordinate location. textureColor = shaderTexture.Sample(SampleType, input.tex); // Calculate the projected texture coordinates. projectTexCoord.x = input.viewPosition.x / input.viewPosition.w / 2.0f + 0.5f; projectTexCoord.y = -input.viewPosition.y / input.viewPosition.w / 2.0f + 0.5f; // Determine if the projected coordinates are in the 0 to 1 range. If it is then this pixel is inside the projected view port. if((saturate(projectTexCoord.x) == projectTexCoord.x) &amp;&amp; (saturate(projectTexCoord.y) == projectTexCoord.y)) &#123; // Sample the color value from the projection texture using the sampler at the projected texture coordinate location. projectionColor = projectionTexture.Sample(SampleType, projectTexCoord); return projectionColor; color = (projectionColor + 0.1f) * textureColor; &#125; else &#123; color = 0.1f * textureColor; &#125; return textureColor;&#125; &emsp;&emsp;设定默认的环境光为 0.1 后，使用光照贴图投影映射，效果如下： &emsp;&emsp;源代码：DX11Tutorial-ProjectedLightMaps]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】40-投影纹理映射]]></title>
    <url>%2F2018%2F04%2F22%2F%E3%80%90DirectX%E3%80%9140-%E6%8A%95%E5%BD%B1%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 43: Projective Texturing 《GPU Programming And Cg Language Primer 1rd Edition》 学习记录&emsp;&emsp;这篇文章中我们介绍投影纹理映射（Projective Texture Mapping），并且给出一个简单的示例。 &emsp;&emsp;投影纹理映射（Projective Texture Mapping）初由Segal在文章“Fast shadows and lighting effects using texture maaping”中提出，用于映射一个纹理到物体上，就像将幻灯片投影到墙上一样。该方法不需要在应用程序中指定顶点纹理坐标，实际上，投影纹理映射中使用的纹理坐标是在顶点着色程序中通过视点矩阵和投 影矩阵计算得到的，通常也被称作投影纹理坐标(coordinates in projective space)。 而我们常用的纹理坐标是在建模软件中通过手工调整纹理和3D模型的对应关系 而产生的。&emsp;&emsp;投影纹理映射的目的是将纹理和三维空间顶点进行对应，这种对应的方法好 比“将纹理当作一张幻灯片，投影到墙上一样”。 &emsp;&emsp;投影纹理映射真正的流程是“根据投影机（视点相机）的位置、投影角度，物体的坐标，求出每个顶点所对应的纹理坐标，然后依据纹理坐标去查询纹理 值”，也就是说，不是将纹理投影到墙上，而是把墙投影到纹理上。投影纹理坐 标的求得，也与纹理本身没有关系，而是由投影机的位置、角度，以及3D模型 的顶点坐标所决定。 &emsp;&emsp;这篇文章中我们使用一个 ProjectionShaderClass 类来实现渲染，这个类和 TextureShaderClass 不同的是它类似 LightShaderClass ，同时在 MatrixBufferType 里多了一个 view 和 projection 矩阵，其声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class ProjectionShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; DirectX::XMMATRIX view2; DirectX::XMMATRIX projection2; &#125;; struct LightBufferType &#123; DirectX::XMFLOAT4 ambientColor; DirectX::XMFLOAT4 diffuseColor; DirectX::XMFLOAT3 lightDirection; float padding; &#125;;public: ProjectionShaderClass(); ProjectionShaderClass(const ProjectionShaderClass&amp;); ~ProjectionShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT4, DirectX::XMFLOAT4, DirectX::XMFLOAT3, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT4, DirectX::XMFLOAT4, DirectX::XMFLOAT3, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_lightBuffer;&#125;; &emsp;&emsp;其实现并没有什么多少特殊的地方，所以暂且不提。新增的 ViewPoint 类也只是简单的进行了数据封装，主要来看我们的着色器。 &emsp;&emsp;在 VertexShader 中，我们使用新增的 viewMatrix2 和 projectionMatrix2 矩阵变换 viewPosition 并且传递给像素着色器，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix; matrix viewMatrix2; matrix projectionMatrix2;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 viewPosition : TEXCOORD1;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType ProjectionVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the position of the vertice as viewed by the projection view point in a separate variable. output.viewPosition = mul(input.position, worldMatrix); output.viewPosition = mul(output.viewPosition, viewMatrix2); output.viewPosition = mul(output.viewPosition, projectionMatrix2); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); return output;&#125; &emsp;&emsp;在 PixelShader 中，我们除了计算光照以外，我们将 ViewPosition 变换为 0 到 1 之内，然后使用它作为纹理坐标来渲染纹理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//////////////////////cbuffer LightBuffer&#123; float4 ambientColor; float4 diffuseColor; float3 lightDirection; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float4 viewPosition : TEXCOORD1;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 ProjectionPixelShader(PixelInputType input) : SV_TARGET&#123; float4 color; float3 lightDir; float lightIntensity; float4 textureColor; float2 projectTexCoord; float4 projectionColor; // Set the default output color to the ambient light value for all pixels. color = ambientColor; // Invert the light direction for calculations. lightDir = -lightDirection; // Calculate the amount of light on this pixel. lightIntensity = saturate(dot(input.normal, lightDir)); if(lightIntensity &gt; 0.0f) &#123; // Determine the light color based on the diffuse color and the amount of light intensity. color += (diffuseColor * lightIntensity); &#125; // Saturate the light color. color = saturate(color); // Sample the pixel color from the texture using the sampler at this texture coordinate location. textureColor = shaderTexture.Sample(SampleType, input.tex); // Combine the light color and the texture color. color = color * textureColor; // Calculate the projected texture coordinates. projectTexCoord.x = input.viewPosition.x / input.viewPosition.w / 2.0f + 0.5f; projectTexCoord.y = -input.viewPosition.y / input.viewPosition.w / 2.0f + 0.5f; // Determine if the projected coordinates are in the 0 to 1 range. If it is then this pixel is inside the projected view port. if((saturate(projectTexCoord.x) == projectTexCoord.x) &amp;&amp; (saturate(projectTexCoord.y) == projectTexCoord.y)) &#123; // Sample the color value from the projection texture using the sampler at the projected texture coordinate location. projectionColor = projectionTexture.Sample(SampleType, projectTexCoord); // Set the output color of this pixel to the projection texture overriding the regular color value. color = projectionColor; &#125; return color;&#125; &emsp;&emsp;在 GraphicsClass 中我们初始化相应类的对象，设定观察点以及对应的变换矩阵，部分代码如下： 12345678910m_ViewPoint = new ViewPointClass;if (!m_ViewPoint) &#123; return false;&#125;m_ViewPoint-&gt;SetPosition(2.0f, 5.0f, -2.0f);m_ViewPoint-&gt;SetLookAt(0.0f, 0.0f, 0.0f);m_ViewPoint-&gt;SetProjectionParameters((float)(XM_PI / 2.0f), 1.0f, 0.1f, 100.0f);m_ViewPoint-&gt;GenerateViewMatrix();m_ViewPoint-&gt;GenerateProjectionMatrix(); &emsp;&emsp;最后，在 Render 里我们使用 ProjectionShaderClass 的对象来进行渲染，它接受多个矩阵参数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344bool GraphicsClass::Render()&#123; bool result; XMMATRIX worldMatrix, viewMatrix, projectionMatrix; XMMATRIX viewMatrix2, projectionMatrix2; m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); m_Camera-&gt;Render(); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); m_D3D-&gt;GetWorldMatrix(worldMatrix); m_ViewPoint-&gt;GetViewMatrix(viewMatrix2); m_ViewPoint-&gt;GetProjectionMatrix(projectionMatrix2); m_Floor-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_ProjectionShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_Floor-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_Floor-&gt;GetTexture(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor(), m_Light-&gt;GetDirection(), viewMatrix2, projectionMatrix2, m_ProjectionTexture-&gt;GetTexture()); if(!result) &#123; return false; &#125; // Reset the world matrix and setup the translation for the cube model. m_D3D-&gt;GetWorldMatrix(worldMatrix); worldMatrix *= XMMatrixTranslation(0.0f, 2.0f, 0.0f); // Render the cube model using the projection shader. m_Model-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_ProjectionShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_Model-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_Model-&gt;GetTexture(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor(), m_Light-&gt;GetDirection(), viewMatrix2, projectionMatrix2, m_ProjectionTexture-&gt;GetTexture()); if(!result) &#123; return false; &#125; m_D3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;最终效果如下： &emsp;&emsp;源代码：DX11Tutorial-ProjectiveTexturing]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】39-粒子发生器]]></title>
    <url>%2F2018%2F04%2F21%2F%E3%80%90DirectX%E3%80%9139-%E7%B2%92%E5%AD%90%E5%8F%91%E7%94%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 39: Particle Systems 学习记录&emsp;&emsp;这篇文章中我们简单的介绍粒子发生器的实现，我们将使用一个 ParticleSystemClass 类来控制粒子，一个 ParticleShaderClass 类来渲染粒子。 &emsp;&emsp;首先来看看我们的 ParticleSystemClass 类，声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class ParticleSystemClass &#123;private: struct ParticleType &#123; float positionX, positionY, positionZ; float red, green, blue; float velocity; bool active; &#125;; struct VertexType &#123; DirectX::XMFLOAT3 position; DirectX::XMFLOAT2 texture; DirectX::XMFLOAT4 color; &#125;;public: ParticleSystemClass(); ParticleSystemClass(const ParticleSystemClass&amp;); ~ParticleSystemClass(); bool Initialize(ID3D11Device*, CHAR*); void Shutdown(); bool Frame(float, ID3D11DeviceContext*); void Render(ID3D11DeviceContext*); ID3D11ShaderResourceView* GetTexture(); int GetIndexCount();private: bool LoadTexture(ID3D11Device*, CHAR*); void ReleaseTexture(); bool InitializeParticleSystem(); void ShutdownParticleSystem(); bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void EmitParticles(float); void UpdateParticles(float); void KillParticles(); bool UpdateBuffers(ID3D11DeviceContext*); void RenderBuffers(ID3D11DeviceContext*);private: float m_particleDeviationX, m_particleDeviationY, m_particleDeviationZ; float m_particleVelocity, m_particleVelocityVariation; float m_particleSize, m_particlesPerSecond; int m_maxParticles; int m_currentParticleCount; float m_accumulatedTime; TextureClass* m_Texture; ParticleType* m_particleList; int m_vertexCount, m_indexCount; VertexType* m_vertices; ID3D11Buffer *m_vertexBuffer, *m_indexBuffer;&#125;; &emsp;&emsp;这个类可能比较复杂，因为我们的粒子发生器的每一个粒子有自己的坐标，速度，颜色等等。我们使用 void EmitParticles(float); ， void UpdateParticles(float);，void KillParticles(); 来控制粒子的生命周期。我们不断的在上方生成粒子，并且在下方结束他们，以达到一个粒子瀑布的效果。 &emsp;&emsp;EmitParticles 方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void ParticleSystemClass::EmitParticles(float frameTime) &#123; bool emitParticle, found; float positionX, positionY, positionZ, velocity, red, green, blue; int index, i, j; // Increment the frame time. m_accumulatedTime += frameTime; // Set emit particle to false for now. emitParticle = false; // Check if it is time to emit a new particle or not. if(m_accumulatedTime &gt; (1000.0f / m_particlesPerSecond)) &#123; m_accumulatedTime = 0.0f; emitParticle = true; &#125; // If there are particles to emit then emit one per frame. if((emitParticle == true) &amp;&amp; (m_currentParticleCount &lt; (m_maxParticles - 1))) &#123; m_currentParticleCount++; // Now generate the randomized particle properties. positionX = (((float)rand()-(float)rand())/RAND_MAX) * m_particleDeviationX; positionY = (((float)rand()-(float)rand())/RAND_MAX) * m_particleDeviationY; positionZ = (((float)rand()-(float)rand())/RAND_MAX) * m_particleDeviationZ; velocity = m_particleVelocity + (((float)rand()-(float)rand())/RAND_MAX) * m_particleVelocityVariation; red = (((float)rand()-(float)rand())/RAND_MAX) + 0.5f; green = (((float)rand()-(float)rand())/RAND_MAX) + 0.5f; blue = (((float)rand()-(float)rand())/RAND_MAX) + 0.5f; // Now since the particles need to be rendered from back to front for blending we have to sort the particle array. // We will sort using Z depth so we need to find where in the list the particle should be inserted. index = 0; found = false; while(!found) &#123; if((m_particleList[index].active == false) || (m_particleList[index].positionZ &lt; positionZ)) &#123; found = true; &#125; else &#123; index++; &#125; &#125; // Now that we know the location to insert into we need to copy the array over by one position from the index to make room for the new particle. i = m_currentParticleCount; j = i - 1; while(i != index) &#123; m_particleList[i].positionX = m_particleList[j].positionX; m_particleList[i].positionY = m_particleList[j].positionY; m_particleList[i].positionZ = m_particleList[j].positionZ; m_particleList[i].red = m_particleList[j].red; m_particleList[i].green = m_particleList[j].green; m_particleList[i].blue = m_particleList[j].blue; m_particleList[i].velocity = m_particleList[j].velocity; m_particleList[i].active = m_particleList[j].active; i--; j--; &#125; // Now insert it into the particle array in the correct depth order. m_particleList[index].positionX = positionX; m_particleList[index].positionY = positionY; m_particleList[index].positionZ = positionZ; m_particleList[index].red = red; m_particleList[index].green = green; m_particleList[index].blue = blue; m_particleList[index].velocity = velocity; m_particleList[index].active = true; &#125; return;&#125; &emsp;&emsp;我们在这里生成粒子信息，在 UpdateParticles 方法中修改他们的位置，使得其不断向下： 123456789void ParticleSystemClass::UpdateParticles(float frameTime) &#123; int i; // Each frame we update all the particles by making them move downwards using their position, velocity, and the frame time. for(i=0; i&lt;m_currentParticleCount; i++) &#123; m_particleList[i].positionY = m_particleList[i].positionY - (m_particleList[i].velocity * frameTime * 0.001f); &#125; return;&#125; &emsp;&emsp;最后当粒子移动到下方时，我们使用 KillParticles 清除粒子： 1234567891011121314151617181920212223242526272829void ParticleSystemClass::KillParticles() &#123; int i, j; // Kill all the particles that have gone below a certain height range. for(i=0; i&lt;m_maxParticles; i++) &#123; if((m_particleList[i].active == true) &amp;&amp; (m_particleList[i].positionY &lt; -3.0f)) &#123; m_particleList[i].active = false; m_currentParticleCount--; // Now shift all the live particles back up the array to erase the destroyed particle and keep the array sorted correctly. for(j=i; j&lt;m_maxParticles-1; j++) &#123; m_particleList[j].positionX = m_particleList[j+1].positionX; m_particleList[j].positionY = m_particleList[j+1].positionY; m_particleList[j].positionZ = m_particleList[j+1].positionZ; m_particleList[j].red = m_particleList[j+1].red; m_particleList[j].green = m_particleList[j+1].green; m_particleList[j].blue = m_particleList[j+1].blue; m_particleList[j].velocity = m_particleList[j+1].velocity; m_particleList[j].active = m_particleList[j+1].active; &#125; &#125; &#125; return;&#125; &emsp;&emsp;我们在每一帧中调用这三个方法，他会不断地生成新粒子，修改粒子瀑布中的粒子位置并且删除已经到达底部的粒子。 &emsp;&emsp;ParticleShaderClass 类则是和其它的渲染类似，所以在此暂且不表，我们的主要内容便是上边的三个方法。最终效果如下： &emsp;&emsp;源代码：DX11Tutorial-ParticleSystems]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My-Calendar-I]]></title>
    <url>%2F2018%2F04%2F21%2FMy-Calendar-I%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#729 My Calendar I 题目描述&emsp;&emsp;Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking. &emsp;&emsp;Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. &emsp;&emsp;A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.) &emsp;&emsp;For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); ， MyCalendar.book(start, end) 。 Example 1: 1234567MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(15, 25); // returns falseMyCalendar.book(20, 30); // returns trueExplanation: The first event can be booked. The second can&apos;t because time 15 is already booked by another event.The third event can be booked, as the first event takes every time less than 20, but not including 20. Note: &emsp;&emsp;The number of calls to MyCalendar.book per test case will be at most 1000. &emsp;&emsp;In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9]. 解题思路&emsp;&emsp;在 book 方法中我们遍历当前区间数组进行插入，就可以了。 解题代码1234567891011121314151617181920212223242526272829303132333435363738class MyCalendar &#123; struct Interval &#123; int start; int end; Interval(int s , int e) : start(s) , end(e)&#123;&#125; &#125;; vector&lt;Interval&gt; intervals;public: MyCalendar() &#123; &#125; bool book(int start, int end) &#123; if (intervals.empty() || end &lt;= intervals.front().start) &#123; intervals.insert(intervals.begin() , Interval(start , end)); return true; &#125; for (auto it = intervals.begin(); it != intervals.end() - 1; ++it) &#123; if (start &gt;= (*it).end &amp;&amp; end &lt;= (*(it+1)).start) &#123; intervals.insert(it+1 , Interval(start , end)); return true; &#125; &#125; if (intervals.back().end &lt;= start)&#123; intervals.insert(intervals.end() , Interval(start , end)); return true; &#125; return false; &#125;&#125;;/** * Your MyCalendar object will be instantiated and called as such: * MyCalendar obj = new MyCalendar(); * bool param_1]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】38-Tessellation技术]]></title>
    <url>%2F2018%2F04%2F20%2F%E3%80%90DirectX%E3%80%9138-Tessellation%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 38: Hardware Tessellation DirectX 11 Tessellation 学习记录&emsp;&emsp;这篇文章主要介绍曲面细分（Tessellation）技术，本篇代码不多。主要在着色器方面，我们新增了两个着色器 HullShader 和 DomainShader 。 &emsp;&emsp;这一篇中，我们介绍在 DX11 中实现曲面细分，我们将使用线框模式画一个正方形： &emsp;&emsp;经过细分以后，如下： &emsp;&emsp;曲面细分，英文称Tessellation，如果直译的话应该译作“镶嵌化处理技术”。 由ATI开发，微软采纳后将其加入DirectX 11，成为DirectX 11的组成部分之一。 由于这种技术广泛的应用在曲面的几何处理上，因此国内翻译时通常译作“曲面细分”。 但实际上，这种技术不是只能用在曲面的细分处理上。 &emsp;&emsp;我们主要的代码增改都在着色器里，所以直接来看着色器代码吧，在 VertexShader 中，我们不再处理变换，而是直接将顶点属性传递给我们新增的 HullShader ： 12345678910111213141516171819struct VertexInputType&#123; float3 position : POSITION; float2 tex : TEXCOORD0;&#125;;struct HullInputType&#123; float3 position : POSITION; float2 tex : TEXCOORD0;&#125;;HullInputType TextureVertexShader(VertexInputType input)&#123; HullInputType output; output.position = input.position; output.tex = input.tex; return output;&#125; &emsp;&emsp;在 HullShader 阶段，我们从代码中传入一个 TessellationAmount 来控制细分级别，对正方形的两个三角形进行细分（ 也可以直接细分四边形 ），我们的 HullShader 着色器接受一个 TessellationBuffer ： 12345cbuffer TessellationBuffer&#123; float tessellationAmount; float3 padding;&#125;; &emsp;&emsp;其全部代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465cbuffer TessellationBuffer&#123; float tessellationAmount; float3 padding;&#125;;// 输入struct HullInputType&#123; float3 position : POSITION; float2 tex : TEXCOORD0;&#125;;// 输出struct HullOutputType&#123; float3 position : POSITION; float2 tex : TEXCOORD0;&#125;;// 输出修补程序常量数据。struct HS_CONSTANT_DATA_OUTPUT&#123; float EdgeTessFactor[3] : SV_TessFactor; // 例如，对于四象限域，将为 [4] float InsideTessFactor : SV_InsideTessFactor; // 例如，对于四象限域，将为 Inside[2]&#125;;#define NUM_CONTROL_POINTS 3// 修补程序常量函数HS_CONSTANT_DATA_OUTPUT CalcHSPatchConstants( InputPatch&lt; HullInputType , NUM_CONTROL_POINTS&gt; ip, uint PatchID : SV_PrimitiveID)&#123; HS_CONSTANT_DATA_OUTPUT Output; // 设定三条边的细分因子 Output.EdgeTessFactor[0] = tessellationAmount; Output.EdgeTessFactor[1] = tessellationAmount; Output.EdgeTessFactor[2] = tessellationAmount; // 设定内部的细分因子 Output.InsideTessFactor = tessellationAmount; return Output;&#125;[domain("tri")] // 补丁类型为三角形[partitioning("integer")] // 细分模式整形[outputtopology("triangle_cw")] // 环绕方向设定为顺时针[outputcontrolpoints(3)] // 控制点个数[patchconstantfunc("CalcHSPatchConstants")] // 函数名HullOutputType TextureHullShader( InputPatch&lt; HullInputType , NUM_CONTROL_POINTS&gt; ip, uint i : SV_OutputControlPointID, uint PatchID : SV_PrimitiveID )&#123; HullOutputType output; // 直接赋值 output.position = ip[i].position; output.tex = ip[i].tex; return output;&#125; &emsp;&emsp;HallShader 阶段我们完成了曲面细分因子的设置和片元控制点的输入，之后会经过固定渲染的细分阶段，这个阶段无需编程。然后才会进入 DomainShader 阶段，也是我们要新增的第二个着色器程序。在 DomainShader 着色器中，我们对细分后的顶点进行变换，即我们之前在 VertexShader 阶段实现的内容在这里实现了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;struct HullOutputType&#123; float3 position : POSITION; float2 tex : TEXCOORD0;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0;&#125;;// 输出修补程序常量数据。struct HS_CONSTANT_DATA_OUTPUT&#123; float EdgeTessFactor[3] : SV_TessFactor; float InsideTessFactor : SV_InsideTessFactor; &#125;;#define NUM_CONTROL_POINTS 3[domain("tri")]PixelInputType TextureDomainShader( HS_CONSTANT_DATA_OUTPUT input, float3 domain : SV_DomainLocation, const OutputPatch&lt; HullOutputType , NUM_CONTROL_POINTS&gt; patch)&#123; PixelInputType output; float3 vertexPosition; vertexPosition = domain.x * patch[0].position + domain.y * patch[1].position + domain.z * patch[2].position; // Calculate the position of the vertex against the world, view, and projection matrices output.position = mul(float4(vertexPosition , 1.0f), worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); output.tex = domain.x * patch[0].tex + domain.y * patch[1].tex + domain.z * patch[2].tex; return output;&#125; &emsp;&emsp;需要注意的是在这里的时候我们的坐标操作都需要使用 domain 和 patch 计算得到。最后一个阶段自然是我们的像素着色器了，它和之前一样并没有改变。 &emsp;&emsp;想要观察到我们的曲面细分结果，我们需要使用线框模式绘制，因为直接绘制的画，会是这样： &emsp;&emsp;诺。 &emsp;&emsp;在 D3DClass 中我们暂且修改光栅化的配置使其使用线框绘制： 1234... //rasterDesc.FillMode = D3D11_FILL_SOLID; rasterDesc.FillMode = D3D11_FILL_WIREFRAME; // 设置为线框模式... &emsp;&emsp;然后在 TextureShaderClass 中，新增两个着色器以及对应缓冲： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class TextureShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;; struct TessellationBufferType &#123; float tessellationAmount; DirectX::XMFLOAT3 padding; &#125;;public: TextureShaderClass(); TextureShaderClass(const TextureShaderClass&amp;); ~TextureShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView* , float);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, char*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView* , float); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11HullShader* m_hullShader; ID3D11DomainShader* m_domainShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_tessellationBuffer;&#125;; &emsp;&emsp;他们的创建什么的和顶点着色器这些并无区别，所以代码就不贴了（请注意我们两个缓冲的位置，MatrixBuffer 已经不在顶点着色器了）。 &emsp;&emsp;最后我们需要修改绘制图元，在 ModelClass 里修改为： 1deviceContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST); &emsp;&emsp;最终我们在 GraphicsClass 调用他们的绘制并且传入 tessellationAmount 为 3 ，效果如下（我们使用的是三角形细分）： &emsp;&emsp;源代码：DX11Tutorial-Tessellation]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】37-Instancing技术]]></title>
    <url>%2F2018%2F04%2F20%2F%E3%80%90DirectX%E3%80%9137-Instancing%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 37: Instancing 学习记录&emsp;&emsp;这篇文章中我们简单的介绍 DX 中 Instancing 绘制，代码依旧很简单。 &emsp;&emsp;在之前介绍视锥裁剪的时候（【DirectX】21-视锥裁剪），我们在屏幕上绘制了大量的物体，使用一个循环然后调用 N 次 DrawIndexed 方法来绘制。即每一帧给 GPU 发送了 N 次基本相同的数据，这显然是一个不太理想的方法，在 OpenGL 系列学习笔记中，我们介绍过在 OpenGL 下的重复物体渲染（【OpenGL】23-实例化） ，在 DX 中自然也有。 &emsp;&emsp;我们这次会使用 Instancing 绘制技术在屏幕上渲染多个 Square 。代码对 ModelClass 和 TextureClass 作以修改即可实现。 &emsp;&emsp;首先修改我们的 ModelClass 类，我们需要绘制多个基本相同物体的场景自然是在他们区别较小的情况下，例如相同的物体在不同的位置，我们使用一个结构体来保存多个实例间不同的属性，在这里只有 position 一个。 1234struct InstanceType &#123; DirectX::XMFLOAT3 position;&#125;; &emsp;&emsp;同时，我们声明一个 Instance 缓冲以及一个 int 型的变量保存实例个数，同时我们暂时的去掉了 Index 相关变量，最终的声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455////////////////////////////////////////////////////////////////////////////////// Class name: ModelClass////////////////////////////////////////////////////////////////////////////////class ModelClass&#123;private: struct VertexType &#123; DirectX::XMFLOAT3 position; DirectX::XMFLOAT2 texture; DirectX::XMFLOAT3 normal; &#125;; struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;; struct InstanceType &#123; DirectX::XMFLOAT3 position; &#125;;public: ModelClass(); ModelClass(const ModelClass&amp;); ~ModelClass(); bool Initialize(ID3D11Device*, char*, char*); void Shutdown(); void Render(ID3D11DeviceContext*); int GetVertexCount(); int GetInstanceCount(); ID3D11ShaderResourceView* GetTexture();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); bool LoadTexture(ID3D11Device*, char*); void ReleaseTexture(); bool LoadModel(char*); void ReleaseModel();private: ID3D11Buffer * m_vertexBuffer, *m_instanceBuffer; int m_vertexCount, m_instanceCount; TextureClass* m_Texture; ModelType* m_model;&#125;; &emsp;&emsp;我们声明了两个方法用于获取单个实例的顶点个数以及实例个数，然后创建绑定缓冲的操作和其他一样，所以代码就不贴了。接下来看我们对于 TextureShaderClass 的改动，在这里我们需要修改的只有两样，一个是输入布局 InputLayout ，一个是绘制方式 DrawInstanced。 输入布局中我们新增了一项： 1234567polygonLayout[2].SemanticName = "TEXCOORD";polygonLayout[2].SemanticIndex = 1;polygonLayout[2].Format = DXGI_FORMAT_R32G32_FLOAT;polygonLayout[2].InputSlot = 1;polygonLayout[2].AlignedByteOffset = 0;polygonLayout[2].InputSlotClass = D3D11_INPUT_PER_INSTANCE_DATA;polygonLayout[2].InstanceDataStepRate = 1; &emsp;&emsp;最后，我们在 RenderShader 方法里修改绘制方式： 12// Render the triangle.deviceContext-&gt;DrawInstanced(vertexCount , instanceCount , 0 , 0); &emsp;&emsp;这样，我们可以在屏幕上绘制多个 Square 。如下： &emsp;&emsp;这里我在 ModelClass 直接硬编码写入了实例的属性。 &emsp;&emsp;源代码：DX11Tutorial-Instancing]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】36-BillBoard技术]]></title>
    <url>%2F2018%2F04%2F20%2F%E3%80%90DirectX%E3%80%9136-BillBoard%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 34: Billboarding 《计算机游戏程序设计》 学习记录&emsp;&emsp;这篇文章中，我们简单的介绍下 BillBoard 快速绘制技术。 &emsp;&emsp;BillBoard 是一种常见的绘制技术，它允许我们使用较小的资源完成对 3D 物体的绘制，在《计算机游戏程序设计》中对 BillBoarding 技术的具体描述如下： &emsp;&emsp;“ BillBoard技术采用一个带有纹理的四边形，其纹理图像为该BillBoard所代表的物体的图像，即用带有该物体图像的长方形，代替生成该物体的图形画面。BillBoard放置于所代表物体的位置中心，并随相机的运动而变化，始终面对用户。将BillBoard技术与Alpha纹理和动画技术相结合，可以模拟很多自然现象，如树、烟、火、爆炸、云等。”——《计算机游戏程序设计》 &emsp;&emsp;如书中所述，BillBoard技术并不复杂。其核心内容在于无论何时二维图像都面向于观察者，我们可以用它来绘制树，火等等效果。 &emsp;&emsp;这篇文章的实现代码我们使用最简单的一个二维贴图，同时为了观察二维贴图方向的改变，我们使用带网格的地面作为参考。 &emsp;&emsp;首先我们渲染出我们所需要的地面和贴图正方形： &emsp;&emsp;此时，我们处于这个 Square 的正前方，在我们看来它貌似可以当作一个正方体（因为后边我们是看不到的），如果我们移动摄像机位置，然后从另一个方向看它，就会变成这样： &emsp;&emsp;由于角度问题，我们已经可以很清楚的看出来这是一个二维图像，然而这显示不是我们想要的。如果我们需要使用二维图像来模拟三维物体的话，我们有一种办法是在同一处使用不同角度多渲染几张，这样不管我们从哪个角度来看都能看到物体。例如游戏中的草堆： &emsp;&emsp;截图来自游戏《天涯明月刀》 &emsp;&emsp;判断是否是这样渲染的方法是拉近之后旋转视角，你会清晰的看到二维图像在不同角度下的形态，当与二维图像一个平面时图像会消失。 &emsp;&emsp;另一种便是这篇文章的主题，BillBoard 绘制技术，它将一张二维图像根据我们摄像机的位置变换而旋转方向，保证永远面向着摄像机，这样不管在哪个角度看来都像是三维模型，我们修改图片面向后再看，如下： &emsp;&emsp;摄像机依旧在 Square 正前方 &emsp;&emsp;它的计算也比较简单，我们直接在渲染前根据物体的位置和摄像机的位置，计算出角度，然后再对物体绕 Y 轴旋转，在 GraphicsClass::Render() 里直接实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool GraphicsClass::Render()&#123; DirectX::XMMATRIX worldMatrix, viewMatrix, projectionMatrix; bool result; XMFLOAT3 cameraPosition, modelPosition; double angle; float rotation; // Clear the buffers to begin the scene. m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Get the world, view, and projection matrices from the camera and d3d objects. m_Camera-&gt;GetViewMatrix(viewMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); m_D3D-&gt;GetWorldMatrix(worldMatrix); worldMatrix *= XMMatrixScaling(5.0f, 1.0f, 5.0f); m_FloorModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_TextureShader-&gt;Render( m_D3D-&gt;GetDeviceContext(), m_FloorModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_FloorModel-&gt;GetTexture()); if (!result) &#123; return false; &#125; m_Camera-&gt;GetPosition(cameraPosition); modelPosition = XMFLOAT3(0.0f, 1.5f, 1.0f); angle = atan2(modelPosition.x - cameraPosition.x, modelPosition.z - cameraPosition.z) * (180.0f / XM_PI); rotation = angle * 0.0174532925f; m_D3D-&gt;GetWorldMatrix(worldMatrix); worldMatrix *= XMMatrixTranslation(modelPosition.x, modelPosition.y, modelPosition.z); worldMatrix *= XMMatrixRotationY(rotation); m_BillBoardModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_TextureShader-&gt;Render( m_D3D-&gt;GetDeviceContext(), m_BillBoardModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_BillBoardModel-&gt;GetTexture()); if (!result) &#123; return false; &#125; // Present the rendered scene to the screen. m_D3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;源代码：DX11Tutorial-BillBoarding]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】35-火效果]]></title>
    <url>%2F2018%2F04%2F19%2F%E3%80%90DirectX%E3%80%9135-%E7%81%AB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 33: Fire 学习记录&emsp;&emsp;这篇文章中我们简单介绍火焰的一种常用实现，此次使用的框架文件如下： &emsp;&emsp;火焰的实现也是使用纹理贴图，辅以随时间而进行的纹理坐标扰动而实现。火焰的纹理以及纹理使用如下（原文）： One of the most realistic ways to create a fire effect in DirectX is to use a noise texture and to perturb the sampling of that texturein the same way we have for water, glass, and ice.The only major difference is in the manipulation of the noise texture and the specific way we perturb the texture coordinates. First start with a grey scale noise texture such as follows: These noise textures can be procedurally generated with several different graphics manipulation programs.The key is to produce one that has noise properties specific to a good looking fire. The second texture needed for fire effect will be a texture composed of fire colored noise and a flame outline.For example the following texture is composed of a texture that uses perlin noise with fire colors and a texture of a small flame.If you look closely at the middle bottom part of the texture you can see the umbra and penumbra of the flame: And finally you will need an alpha texture for transparency of the flame so that the final shape is very close to that of a small flame.This can be rough as the perturbation will take care of making it take shape of a good flame: Now that we have the three textures required for the fire effect we can explain how the shader works.The first thing we do is take the noise texture and create three separate textures from it.The three separate textures are all based on the original noise texture except that they are scaled differently.These scales are called octaves as they are simply repeated tiles of the original noise texture to create numerous more detailed noise textures.The following three noise textures are scaled (tiled) by 1, 2, and 3: We are also going to scroll all three noise textures upwards to create an upward moving noise which will correlate with a fire that burns upwards.The scroll speed will be set differently for all three so that each moves at a different rate.We will eventually combine the three noise textures so having them move at different rates adds dimension to the fire. The next step is to convert the three noise textures from the (0, 1) range into the (-1, +1) range.This has the effect of removing some of the noise and creating noise that looks closer to fire.For example the first noise texture now looks like the following: With all three noise textures in the (-1, +1) range we can now add distortion to each texture along the x and y coordinates.The distortion modifies the noise textures by scaling down the noise similar to how the refraction scale in the water, glass, and ice shaders did so.Once each noise texture is distorted we can then combine all three noise textures to produce a final noise texture. Note that the distortion here is only applied to the x and y coordinates since we will be using them as a look up table for the x and y texture samplingjust like we do with normal maps.The z coordinate is ignored as it has no use when sampling textures in 2D. Remember also that each frame the three noise textures are scrolling upwards at different rates so combining them creates an almost organized flowing noisethat looks like fire. Now the next very important step is to perturb the original fire color texture.In other shaders such as water, glass, and ice we usually use a normal map at this point to perturb the texture sampling coordinates.However in fire we use the noise as our perturbed texture sampling coordinates.But before we do that we want to also perturb the noise itself. We will use a distortion scale and bias to distort the noise higher at the top of the texture and less at the bottom of the textureto create a solid flame at the base and flame licks at the top. In other words we perturb the noise along the Y axis using an increased amount of distortion as we go up the noise texture from the bottom. We now use the perturbed final noise texture as our look up table for texture sampling coordinates that will be used to sample the fire color texture.Note that we use Clamp instead of Wrap for the fire color texture or we will get flame licks wrapping around to the bottom which would ruin the look.The fire color texture sampled using the perturbed noise now looks like the following: Now that we have an animated burning square that looks fairly realistic we need a way of shaping it into more of a flame.To do so we turn on blending and use the alpha texture we created earlier.The trick is to sample the alpha texture using the same perturbed noise to make the alpha look like a burning flame.We also need to use Clamp instead of Wrap for sampling to prevent the flames from wrapping around to the bottom.When we do so we get the following result from the sampled perturbed alpha: To complete the effect we set the perturbed alpha value to be the alpha channel of the perturbed fire color texture and the blending takes care of the rest: When you see this animated it looks very realistic. &emsp;&emsp;实现中，我们首先修改 ModelClass 使其接受一个模型和三个纹理，声明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253////////////////////////////////////////////////////////////////////////////////// Class name: ModelClass////////////////////////////////////////////////////////////////////////////////class ModelClass&#123;private: struct VertexType &#123; DirectX::XMFLOAT3 position; DirectX::XMFLOAT2 texture; DirectX::XMFLOAT3 normal; &#125;; struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;;public: ModelClass(); ModelClass(const ModelClass&amp;); ~ModelClass(); bool Initialize(ID3D11Device*, char*, char* , char* , char*); void Shutdown(); void Render(ID3D11DeviceContext*); int GetIndexCount(); ID3D11ShaderResourceView* GetTexture1(); ID3D11ShaderResourceView* GetTexture2(); ID3D11ShaderResourceView* GetTexture3();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); bool LoadTexture(ID3D11Device*, char* , char* , char*); void ReleaseTexture(); bool LoadModel(char*); void ReleaseModel();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount; TextureClass* m_Texture1; TextureClass* m_Texture2; TextureClass* m_Texture3; ModelType* m_model;&#125;; &emsp;&emsp;我们的 FireShaderClass 中，我们除了一般的 MatrixBufferType 缓冲结构体外，还需要两个为生成火焰效果而添加的缓冲结构体： 12345678910111213141516struct NoiseBufferType&#123; float frameTime; DirectX::XMFLOAT3 scrollSpeeds; DirectX::XMFLOAT3 scales; float padding;&#125;;struct DistortionBufferType&#123; DirectX::XMFLOAT2 distortion1; DirectX::XMFLOAT2 distortion2; DirectX::XMFLOAT2 distortion3; float distortionScale; float distortionBias;&#125;; &emsp;&emsp;为省篇幅，其创建缓冲和填充数据的过程不贴出来了。主要看我们的 HLSL 代码。我们的 NoiseBufferType 缓冲是送给顶点着色器的，使用它们生成多个不同的纹理坐标： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;cbuffer NoiseBuffer&#123; float frameTime; float3 scrollSpeeds; float3 scales; float padding;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float2 texCoords1 : TEXCOORD1; float2 texCoords2 : TEXCOORD2; float2 texCoords3 : TEXCOORD3;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType FireVertexShader(VertexInputType input)&#123; PixelInputType output; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Compute texture coordinates for first noise texture using the first scale and upward scrolling speed values. output.texCoords1 = (input.tex * scales.x); output.texCoords1.y = output.texCoords1.y + (frameTime * scrollSpeeds.x); // Compute texture coordinates for second noise texture using the second scale and upward scrolling speed values. output.texCoords2 = (input.tex * scales.y); output.texCoords2.y = output.texCoords2.y + (frameTime * scrollSpeeds.y); // Compute texture coordinates for third noise texture using the third scale and upward scrolling speed values. output.texCoords3 = (input.tex * scales.z); output.texCoords3.y = output.texCoords3.y + (frameTime * scrollSpeeds.z); return output;&#125; &emsp;&emsp;像素着色器中，我们使用由 CPU 代码传进来的缓冲和顶点着色器传进来的多个纹理坐标，从 noiseTexture 中混合得到最终的 nosie 纹理坐标值，并且使用它从火焰纹理和透明纹理中取值。 &emsp;&emsp;源代码：DX11Tutorial-Fire]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】34-玻璃和冰效果]]></title>
    <url>%2F2018%2F04%2F17%2F%E3%80%90DirectX%E3%80%9134-%E7%8E%BB%E7%92%83%E5%92%8C%E5%86%B0%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 32: Glass and Ice 学习记录&emsp;&emsp;这篇文章中我们简单介绍玻璃和冰效果。此次使用框架文件如下： &emsp;&emsp;玻璃和冰的主要实现与我们之前介绍过的 水 实现类似，我们将它背后所能看见的物体渲染至纹理，然后通过法线贴图对纹理进行一定程度上的移位，达成效果。类似如下： &emsp;&emsp;在渲染这个的时候，我们需要以下几张纹理（使用冰来介绍）： &emsp;&emsp;物体纹理： &emsp;&emsp;冰的表面纹理： &emsp;&emsp;冰的法线纹理： &emsp;&emsp;在原教程中，对其渲染描述如下： Step 1: Render the scene that is behind the glass to a texture, this is called the refraction. Step 2: Project the refraction texture onto the glass surface. Step 3: Perturb the texture coordinates of the refraction texture using a normal map to simulate light traveling through glass. Step 4: Combine the perturbed refraction texture with a glass color texture for the final result. We will now examine how to implement each step for both glass and ice. &emsp;&emsp;我们来看代码实现吧。首先来看这次新增的 GlassShaderClass 类，这个类也是从 TextureShaderClass 类修改而成，它相比于普通的纹理渲染类多了一个 GlassBufferType ，如下： 12345struct GlassBufferType &#123; float refractionScale; DirectX::XMFLOAT3 padding;&#125;; &emsp;&emsp;refractionScale 决定了我们最后纹理的移位程度。 &emsp;&emsp;除多了一个缓冲之外，它的渲染使用三张纹理资源，如下： 1bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView* , ID3D11ShaderResourceView* , ID3D11ShaderResourceView* , float); &emsp;&emsp;其最终的声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243////////////////////////////////////////////////////////////////////////////////// Class name: GlassShaderClass////////////////////////////////////////////////////////////////////////////////class GlassShaderClass&#123; struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;; struct GlassBufferType &#123; float refractionScale; DirectX::XMFLOAT3 padding; &#125;;public: GlassShaderClass(); GlassShaderClass(const GlassShaderClass&amp;); ~GlassShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView* , ID3D11ShaderResourceView* , ID3D11ShaderResourceView* , float);private: bool InitializeShader(ID3D11Device*, HWND, char*, char*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, char*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView* , ID3D11ShaderResourceView* , ID3D11ShaderResourceView* , float); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_glassBuffer;&#125;; &emsp;&emsp;当使用多张纹理的时候，我们再设置的时候需要一一设置，在 SetShaderParameters 方法中，我们对其进行配置： 1234// Set shader texture resource in the pixel shader.deviceContext-&gt;PSSetShaderResources(0, 1, &amp;texture);deviceContext-&gt;PSSetShaderResources(1, 1, &amp;normalTexture);deviceContext-&gt;PSSetShaderResources(2, 1, &amp;refractionTexture); &emsp;&emsp;限于篇幅，其它的实现基本与 TextureShaderClass 相同，使用多缓冲的操作我们也介绍过很多次了，所以在此暂且不表。 &emsp;&emsp;在其对应的顶点着色器中，我们向像素着色器里新传入一个变量 refractionPosition （折射顶点坐标）： 12345678910111213141516171819202122232425262728293031323334353637383940cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;struct VertexInputType &#123; float4 position : POSITION; float2 texcoord : TEXCOORD0;&#125;;struct PixelInputType &#123; float4 position : SV_POSITION; float2 texcoord : TEXCOORD0; float4 refractionPosition : TEXCOORD1;&#125;;PixelInputType GlassVertexShader(VertexInputType input)&#123; PixelInputType output; matrix viewProjectWorld; input.position.w = 1.0f; output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); output.texcoord = input.texcoord; viewProjectWorld = mul(viewMatrix, projectionMatrix); viewProjectWorld = mul(worldMatrix, viewProjectWorld); output.refractionPosition = mul(input.position, viewProjectWorld); return output;&#125; &emsp;&emsp;像素着色器中，我们使用法线纹理读出的法线对折射纹理进行移位，然后使用最终使用折射纹理和冰本身纹理进行混合： 1234567891011121314151617181920212223242526272829303132333435363738394041424344SamplerState sampleType;Texture2D colorTex : register(t0);Texture2D normalTex : register(t1);Texture2D refractionTex : register(t2);cbuffer GlassBuffer&#123; float refractionScale; float3 padding;&#125;;struct PixelInputType &#123; float4 position : SV_POSITION; float2 texcoord : TEXCOORD0; float4 refractionPosition : TEXCOORD1;&#125;;float4 GlassPixelShader(PixelInputType input) : SV_TARGET&#123; float2 refractTexcoord; float4 normalMap; float3 normal; float4 refractionColor; float4 textureColor; float4 color; refractTexcoord.x = input.refractionPosition.x / input.refractionPosition.w / 2.0f + 0.5f; refractTexcoord.y = input.refractionPosition.y / input.refractionPosition.w / 2.0f + 0.5f; normalMap = normalTex.Sample(sampleType, input.texcoord); normal = (normalMap.xyz * 2.0f) - 1.0f; refractTexcoord = refractTexcoord + (normal.xy * refractionScale); refractionColor = refractionTex.Sample(sampleType, refractTexcoord); textureColor = colorTex.Sample(sampleType, input.texcoord); color = lerp(refractionColor, textureColor, 0.5f); return color;&#125; &emsp;&emsp;由于我们的玻璃模型需要两个纹理贴图（颜色纹理和法线纹理），所以我们修改 ModelClass ，使其可以适应两张纹理，修改后如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354////////////////////////////////////////////////////////////////////////////////// Class name: ModelClass////////////////////////////////////////////////////////////////////////////////class ModelClass&#123;private: struct VertexType &#123; DirectX::XMFLOAT3 position; DirectX::XMFLOAT2 texture; DirectX::XMFLOAT3 normal; &#125;; struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;;public: ModelClass(); ModelClass(const ModelClass&amp;); ~ModelClass(); bool Initialize(ID3D11Device*, char*, char* , char* = nullptr); void Shutdown(); void Render(ID3D11DeviceContext*); int GetIndexCount(); ID3D11ShaderResourceView* GetTexture(); ID3D11ShaderResourceView* GetNormalTexture();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); bool LoadTexture(ID3D11Device*, char*); void ReleaseTexture(); bool LoadNormalTexture(ID3D11Device*, char*); void ReleaseNormalTexture(); bool LoadModel(char*); void ReleaseModel();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount; TextureClass* m_Texture; TextureClass* m_NormalTexture; ModelType* m_model;&#125;; &emsp;&emsp;我们新增了 m_NormalTexture 成员变量以及它的读取和释放函数，并且在构造函数中使用了默认为空的第三个参数，这样我们可以根据自己需求选择是否使用模型的法线纹理。 &emsp;&emsp;最后来看 GraphicsClass ，我们新增了 m_WindowModel ，m_GlassShader ，m_RenderTexture成员变量以及他们的初始化等操作。 &emsp;&emsp;最终渲染时，我们首先渲染我们的 cube 至纹理，然后就可以使用纹理来渲染冰效果。部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102bool GraphicsClass::Frame()&#123; static float rotation = 0.0f; bool result; rotation += (float)XM_PI * 0.005f; if (rotation &gt; 360.0f) &#123; rotation -= 360.0f; &#125; // Set the position and rotation of the camera. m_Camera-&gt;SetPosition(0.0f, 0.0f, -10.0f); result = RenderToTexture(rotation); if (!result) &#123; return false; &#125; result = Render(rotation); if (!result) &#123; return false; &#125; return true;&#125;bool GraphicsClass::RenderToTexture(float rotation) &#123; bool result; XMMATRIX worldMatrix, viewMatrix, projectionMatrix; m_RenderTexture-&gt;SetRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView()); m_RenderTexture-&gt;ClearRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView(), 0.0f, 0.0f, 0.0f, 1.0f); m_Camera-&gt;Render(); m_D3D-&gt;GetWorldMatrix(worldMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); worldMatrix *= XMMatrixRotationY(rotation); m_Model-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_TextureShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_Model-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_Model-&gt;GetTexture()); if (!result) &#123; return false; &#125; m_D3D-&gt;SetBackBufferRenderTarget(); return true;&#125;bool GraphicsClass::Render(float rotation)&#123; bool result; XMMATRIX worldMatrix, viewMatrix, projectionMatrix; float refracionScale = 0.1f; m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); m_Camera-&gt;Render(); m_D3D-&gt;GetWorldMatrix(worldMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); worldMatrix *= XMMatrixRotationY(rotation); m_Model-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_TextureShader-&gt;Render( m_D3D-&gt;GetDeviceContext(), m_Model-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_Model-&gt;GetTexture()); if (!result) &#123; return false; &#125; m_D3D-&gt;GetWorldMatrix(worldMatrix); worldMatrix *= XMMatrixTranslation(0.0f, 0.0f, -1.5f); m_WindowModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); result = m_GlassShader-&gt;Render( m_D3D-&gt;GetDeviceContext(), m_WindowModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_WindowModel-&gt;GetTexture() , m_WindowModel-&gt;GetNormalTexture(), m_RenderTexture-&gt;GetShaderResourceView(), refracionScale ); if (!result) &#123; return false; &#125; m_D3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;我们在这里渲染了两次 cube ，第一次渲染至纹理其纹理供我们渲染冰所用，第二次渲染至后台呈现所用。最终效果如下： &emsp;&emsp;（渲染玻璃只是更换颜色法线贴图就可以） &emsp;&emsp;源代码：DX11Tutorial-GlassAndIce]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】33-点光源]]></title>
    <url>%2F2018%2F04%2F16%2F%E3%80%90DirectX%E3%80%9133-%E7%82%B9%E5%85%89%E6%BA%90%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 30: Multiple Point Lights 学习记录&emsp;&emsp;这篇文章中我们将介绍点光源的以及实现多个点光源渲染平面。本次的框架如下： &emsp;&emsp;这次的内容比较简单，我们首先修改 LightClass ，将其改为保存有点光源坐标和颜色的数据类： 1234567891011121314151617181920212223242526272829303132333435////////////////////////////////////////////////////////////////////////////////// Filename: lightclass.h////////////////////////////////////////////////////////////////////////////////#ifndef _LIGHTCLASS_H_#define _LIGHTCLASS_H_//////////////// INCLUDES ////////////////#include &lt;DirectXMath.h&gt;////////////////////////////////////////////////////////////////////////////////// Class name: LightClass////////////////////////////////////////////////////////////////////////////////class LightClass&#123;public: LightClass(); LightClass(const LightClass&amp;); ~LightClass(); void SetDiffuseColor(float, float, float, float); void SetPosition(float, float, float); DirectX::XMFLOAT4 GetDiffuseColor(); DirectX::XMFLOAT4 GetPosition();private: DirectX::XMFLOAT4 m_diffuseColor; DirectX::XMFLOAT4 m_position;&#125;;#endif &emsp;&emsp;这只是一个用来保存数据的类，实现暂且不贴出来了。接下来看我们的 LightShaderClass ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int NUM_LIGHTS = 4;////////////////////////////////////////////////////////////////////////////////// Class name: LightShaderClass////////////////////////////////////////////////////////////////////////////////class LightShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;; struct LightColorBufferType &#123; DirectX::XMFLOAT4 diffuseColor[NUM_LIGHTS]; &#125;; struct LightPositionBufferType &#123; DirectX::XMFLOAT4 lightPosition[NUM_LIGHTS]; &#125;;public: LightShaderClass(); LightShaderClass(const LightShaderClass&amp;); ~LightShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT4*, DirectX::XMFLOAT4*);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT4*, DirectX::XMFLOAT4*); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_lightColorBuffer; ID3D11Buffer* m_lightPositionBuffer;&#125;; &emsp;&emsp;我们新增加了两个结构体，LightColorBufferType 用来保存光颜色，LightPositionBufferType 用来保存光位置。需要注意到的是我们的 Render ，SetShaderParameters 的参数修改为需要接受两个 FLOAT4 数组，用来向光颜色数组和光位置数组传值。 &emsp;&emsp;在 InitializeShader 方法中，这次我们要创建 matrixBuffer ，lightColorBuffer ，lightPositionBuffer 三个缓冲区，其中 matrixBuffer 和 lightPositionBuffer 两个将传给顶点着色器， lightColorBuffer 传给像素着色器。其实现如下（只列出部分）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152bool LightShaderClass::InitializeShader(ID3D11Device* device, HWND hwnd, CHAR* vsFilename, CHAR* psFilename)&#123; ... // Setup the description of the matrix dynamic constant buffer that is in the vertex shader. matrixBufferDesc.Usage = D3D11_USAGE_DYNAMIC; matrixBufferDesc.ByteWidth = sizeof(MatrixBufferType); matrixBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER; matrixBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; matrixBufferDesc.MiscFlags = 0; matrixBufferDesc.StructureByteStride = 0; // Create the matrix constant buffer pointer so we can access the vertex shader constant buffer from within this class. result = device-&gt;CreateBuffer(&amp;matrixBufferDesc, NULL, &amp;m_matrixBuffer); if(FAILED(result)) &#123; return false; &#125; // Setup the description of the light dynamic constant buffer that is in the pixel shader. // Note that ByteWidth always needs to be a multiple of 16 if using D3D11_BIND_CONSTANT_BUFFER or CreateBuffer will fail. lightColorBufferDesc.Usage = D3D11_USAGE_DYNAMIC; lightColorBufferDesc.ByteWidth = sizeof(LightColorBufferType); lightColorBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER; lightColorBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; lightColorBufferDesc.MiscFlags = 0; lightColorBufferDesc.StructureByteStride = 0; // Create the constant buffer pointer so we can access the vertex shader constant buffer from within this class. result = device-&gt;CreateBuffer(&amp;lightColorBufferDesc, NULL, &amp;m_lightColorBuffer); if(FAILED(result)) &#123; return false; &#125; // Setup the description of the light dynamic constant buffer that is in the pixel shader. // Note that ByteWidth always needs to be a multiple of 16 if using D3D11_BIND_CONSTANT_BUFFER or CreateBuffer will fail. lightPositionBufferDesc.Usage = D3D11_USAGE_DYNAMIC; lightPositionBufferDesc.ByteWidth = sizeof(LightPositionBufferType); lightPositionBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER; lightPositionBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; lightPositionBufferDesc.MiscFlags = 0; lightPositionBufferDesc.StructureByteStride = 0; // Create the constant buffer pointer so we can access the vertex shader constant buffer from within this class. result = device-&gt;CreateBuffer(&amp;lightPositionBufferDesc, NULL, &amp;m_lightPositionBuffer); if(FAILED(result)) &#123; return false; &#125; return true;&#125; &emsp;&emsp;在 SetShaderParameters 中，我们动态的为其赋值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394bool LightShaderClass::SetShaderParameters(ID3D11DeviceContext* deviceContext, DirectX::XMMATRIX worldMatrix, DirectX::XMMATRIX viewMatrix, DirectX::XMMATRIX projectionMatrix, ID3D11ShaderResourceView* texture, DirectX::XMFLOAT4 lightColor[], DirectX::XMFLOAT4 lightPosition[])&#123; HRESULT result; D3D11_MAPPED_SUBRESOURCE mappedResource; MatrixBufferType* dataPtr; LightColorBufferType* dataPtr2; LightPositionBufferType* dataPtr3; unsigned int bufferNumber; // Set shader texture resource in the pixel shader. deviceContext-&gt;PSSetShaderResources(0, 1, &amp;texture); // Lock the matrix constant buffer so it can be written to. result = deviceContext-&gt;Map(m_matrixBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource); if(FAILED(result)) &#123; return false; &#125; // Get a pointer to the data in the constant buffer. dataPtr = (MatrixBufferType*)mappedResource.pData; // Transpose the matrices to prepare them for the shader. worldMatrix = DirectX::XMMatrixTranspose(worldMatrix); viewMatrix = DirectX::XMMatrixTranspose(viewMatrix); projectionMatrix = DirectX::XMMatrixTranspose(projectionMatrix); // Copy the matrices into the constant buffer. dataPtr-&gt;world = worldMatrix; dataPtr-&gt;view = viewMatrix; dataPtr-&gt;projection = projectionMatrix; // Unlock the matrix constant buffer. deviceContext-&gt;Unmap(m_matrixBuffer, 0); // Set the position of the matrix constant buffer in the vertex shader. bufferNumber = 0; // Now set the matrix constant buffer in the vertex shader with the updated values. deviceContext-&gt;VSSetConstantBuffers(bufferNumber, 1, &amp;m_matrixBuffer); // Lock the light constant buffer so it can be written to. result = deviceContext-&gt;Map(m_lightColorBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource); if(FAILED(result)) &#123; return false; &#125; // Get a pointer to the data in the constant buffer. dataPtr2 = (LightColorBufferType*)mappedResource.pData; // Copy the lighting variables into the constant buffer. for (int i = 0 ; i &lt; NUM_LIGHTS ; ++i) &#123; dataPtr2-&gt;diffuseColor[i] = lightColor[i]; &#125; // Unlock the constant buffer. deviceContext-&gt;Unmap(m_lightColorBuffer, 0); // Set the position of the light constant buffer in the pixel shader. bufferNumber = 0; // Finally set the light constant buffer in the pixel shader with the updated values. deviceContext-&gt;PSSetConstantBuffers(bufferNumber, 1, &amp;m_lightColorBuffer); // Lock the light constant buffer so it can be written to. result = deviceContext-&gt;Map(m_lightPositionBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource); if(FAILED(result)) &#123; return false; &#125; // Get a pointer to the data in the constant buffer. dataPtr3 = (LightPositionBufferType*)mappedResource.pData; // Copy the lighting variables into the constant buffer. for (int i = 0 ; i &lt; NUM_LIGHTS ; ++i) &#123; dataPtr3-&gt;lightPosition[i] = lightPosition[i]; &#125; // Unlock the constant buffer. deviceContext-&gt;Unmap(m_lightPositionBuffer, 0); // Set the position of the light constant buffer in the vertex shader. bufferNumber = 1; // Finally set the light constant buffer in the vertex shader with the updated values. deviceContext-&gt;VSSetConstantBuffers(bufferNumber, 1, &amp;m_lightPositionBuffer); return true;&#125; &emsp;&emsp;在对应的着色器代码中，我们在顶点着色器中对光源坐标进行变换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/////////////// DEFINES ///////////////#define NUM_LIGHTS 4/////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;cbuffer LightPositionBuffer &#123; float4 lightPosition[NUM_LIGHTS];&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 lightPos1 : TEXCOORD1; float3 lightPos2 : TEXCOORD2; float3 lightPos3 : TEXCOORD3; float3 lightPos4 : TEXCOORD4;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType LightVertexShader(VertexInputType input)&#123; PixelInputType output; float4 worldPosition; // Change the position vector to be 4 units for proper matrix calculations. input.position.w = 1.0f; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Calculate the normal vector against the world matrix only. output.normal = mul(input.normal, (float3x3)worldMatrix); // Normalize the normal vector. output.normal = normalize(output.normal); worldPosition = mul(input.position, worldMatrix); output.lightPos1.xyz = lightPosition[0].xyz - worldPosition.xyz; output.lightPos2.xyz = lightPosition[1].xyz - worldPosition.xyz; output.lightPos3.xyz = lightPosition[2].xyz - worldPosition.xyz; output.lightPos4.xyz = lightPosition[3].xyz - worldPosition.xyz; output.lightPos1 = normalize(output.lightPos1); output.lightPos2 = normalize(output.lightPos2); output.lightPos3 = normalize(output.lightPos3); output.lightPos4 = normalize(output.lightPos4); return output;&#125; &emsp;&emsp;像素着色器中我们使用四个光混合进行计算最终颜色： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/////////////// DEFINES ///////////////#define NUM_LIGHTS 4/////////////// GLOBALS ///////////////Texture2D shaderTexture;SamplerState SampleType;cbuffer LightColorBuffer&#123; float4 diffuseColor[NUM_LIGHTS];&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 lightPos1 : TEXCOORD1; float3 lightPos2 : TEXCOORD2; float3 lightPos3 : TEXCOORD3; float3 lightPos4 : TEXCOORD4;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 LightPixelShader(PixelInputType input) : SV_TARGET&#123; float4 texColor; float lightIntensity1, lightIntensity2, lightIntensity3, lightIntensity4; float4 color1, color2, color3, color4; lightIntensity1 = saturate(dot(input.normal, input.lightPos1)); lightIntensity2 = saturate(dot(input.normal, input.lightPos2)); lightIntensity3 = saturate(dot(input.normal, input.lightPos3)); lightIntensity4 = saturate(dot(input.normal, input.lightPos4)); color1 = diffuseColor[0] * lightIntensity1; color2 = diffuseColor[1] * lightIntensity2; color3 = diffuseColor[2] * lightIntensity3; color4 = diffuseColor[3] * lightIntensity4; texColor = shaderTexture.Sample(SampleType, input.tex); return saturate(color1 + color2 + color3 + color4) * texColor;;&#125; &emsp;&emsp;最后，修改我们的 GraphicsClass ，成员变量新加入了四个光源对象： 12345678910111213141516171819202122232425////////////////////////////////////////////////////////////////////////////////// Class name: GraphicsClass////////////////////////////////////////////////////////////////////////////////class GraphicsClass&#123;public: GraphicsClass(); GraphicsClass(const GraphicsClass&amp;); ~GraphicsClass(); bool Initialize(int, int, HWND); void Shutdown(); bool Frame(); bool Render();private:private: D3DClass* m_D3D; CameraClass* m_Camera; ModelClass *m_Model; LightClass *m_Light1 , *m_Light2 , *m_Light3 , *m_Light4; LightShaderClass* m_LightShader;&#125;; &emsp;&emsp;在 Initialize 中初始化 light 对象： 12345678910111213141516171819202122232425262728293031323334bool GraphicsClass::Initialize(int screenWidth, int screenHeight, HWND hwnd)&#123; bool result; ... m_Light1 = new LightClass; if (!m_Light1) &#123; return false; &#125; m_Light1-&gt;SetDiffuseColor(1.0f, 0.0f, 0.0f, 1.0f); m_Light1-&gt;SetPosition(-10.0f, 1.0f, 10.0f); m_Light2 = new LightClass; if (!m_Light2) &#123; return false; &#125; m_Light2-&gt;SetDiffuseColor(0.0f, 1.0f, 0.0f, 1.0f); m_Light2-&gt;SetPosition(10.0f, 1.0f, 10.0f); m_Light3 = new LightClass; if (!m_Light3) &#123; return false; &#125; m_Light3-&gt;SetDiffuseColor(0.0f, 0.0f, 1.0f, 1.0f); m_Light3-&gt;SetPosition(-10.0f, 1.0f, -10.0f); m_Light4 = new LightClass; if (!m_Light4) &#123; return false; &#125; m_Light4-&gt;SetDiffuseColor(1.0f, 1.0f, 1.0f, 1.0f); m_Light4-&gt;SetPosition(10.0f, 1.0f, -10.0f); return true;&#125; &emsp;&emsp;在 Render 里进行渲染： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool GraphicsClass::Render()&#123; bool result; XMMATRIX worldMatrix, viewMatrix, projectionMatrix; XMFLOAT4 diffusecolor[4]; XMFLOAT4 lightPosition[4]; diffusecolor[0] = m_Light1-&gt;GetDiffuseColor(); diffusecolor[1] = m_Light2-&gt;GetDiffuseColor(); diffusecolor[2] = m_Light3-&gt;GetDiffuseColor(); diffusecolor[3] = m_Light4-&gt;GetDiffuseColor(); lightPosition[0] = m_Light1-&gt;GetPosition(); lightPosition[1] = m_Light2-&gt;GetPosition(); lightPosition[2] = m_Light3-&gt;GetPosition(); lightPosition[3] = m_Light4-&gt;GetPosition(); m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); m_Camera-&gt;Render(); m_D3D-&gt;GetWorldMatrix(worldMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); m_Model-&gt;Render(m_D3D-&gt;GetDeviceContext()); worldMatrix *= XMMatrixScaling(10.0f , 0.1f , 10.0f); result = m_LightShader-&gt;Render( m_D3D-&gt;GetDeviceContext(), m_Model-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_Model-&gt;GetTexture(), diffusecolor, lightPosition); if (!result) &#123; return false; &#125; m_D3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;最终效果如下：]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】32-水]]></title>
    <url>%2F2018%2F04%2F15%2F%E3%80%90DirectX%E3%80%9132-%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 29: Water 学习记录&emsp;&emsp;这一篇文章中，主要介绍水的实现，本篇更新后使用的框架如下： &emsp;&emsp;水面的渲染比较麻烦，首先纹理是靠着反射与折射实现，我们使用 LightShaderClass 来处理光照，RefractionShaderClass 处理折射相关的着色，WaterShaderClass 则负责综合各种效果实现水的渲染。 &emsp;&emsp;首先看 LightClass 和 LightShaderClass ，LightClass 只是用来做一个简单的数据封装，如下： 1234567891011121314151617181920212223242526272829////////////////////////////////////////////////////////////////////////////////// Class name: LightClass////////////////////////////////////////////////////////////////////////////////class LightClass&#123;public: LightClass(); LightClass(const LightClass&amp;); ~LightClass(); void SetAmbientColor(float, float, float, float); void SetDiffuseColor(float, float, float, float); void SetSpecularColor(float, float, float, float); void SetSpecularPower(float); void SetDirection(float, float, float); DirectX::XMFLOAT4 GetAmbientColor(); DirectX::XMFLOAT4 GetDiffuseColor(); DirectX::XMFLOAT4 GetSpecularColor(); float GetSpecularPower(); DirectX::XMFLOAT3 GetDirection();private: DirectX::XMFLOAT4 m_ambientColor; DirectX::XMFLOAT4 m_diffuseColor; DirectX::XMFLOAT4 m_specularColor; float m_specularPower; DirectX::XMFLOAT3 m_direction;&#125;; &emsp;&emsp;LightShaderClass 以 ShaderClass 为基础封装了 LightShader 的处理，声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748////////////////////////////////////////////////////////////////////////////////// Class name: LightShaderClass////////////////////////////////////////////////////////////////////////////////class LightShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;; struct LightBufferType &#123; DirectX::XMFLOAT4 ambientColor; DirectX::XMFLOAT4 diffuseColor; DirectX::XMFLOAT3 lightDirection; float padding; &#125;;public: LightShaderClass(); LightShaderClass(const LightShaderClass&amp;); ~LightShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_lightBuffer;&#125;; &emsp;&emsp;DX 代码里只是多了一个 LightBufferType ，而光照的计算代码之前我们写过，这里暂时不贴出来了。需要的话可以去文末的源代码地址下载。 &emsp;&emsp;RefractionShaderClass 则是封装了折射效果的实现，其声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354////////////////////////////////////////////////////////////////////////////////// Class name: RefractionShaderClass////////////////////////////////////////////////////////////////////////////////class RefractionShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;; struct LightBufferType &#123; DirectX::XMFLOAT4 ambientColor; DirectX::XMFLOAT4 diffuseColor; DirectX::XMFLOAT3 lightDirection; float padding; &#125;; struct ClipPlaneBufferType &#123; DirectX::XMFLOAT4 clipPlane; &#125;;public: RefractionShaderClass(); RefractionShaderClass(const RefractionShaderClass&amp;); ~RefractionShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4, DirectX::XMFLOAT4);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, DirectX::XMFLOAT3, DirectX::XMFLOAT4, DirectX::XMFLOAT4, DirectX::XMFLOAT4); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_lightBuffer; ID3D11Buffer* m_clipPlaneBuffer;&#125;; &emsp;&emsp;而 WaterShaderClass 则是实现使用多张纹理来渲染水的动作，同时为了模拟出动态的效果以及水面的波纹，我们首先需要一张水面的法线贴图。如下： &emsp;除了法线贴图以外，反射和折射的效果也将作为纹理来使用，WaterShaderClass 所对应的着色器 WaterVertexShader 中，我们有一个反射矩阵和三个纹理坐标，分别为他们计算变换后的值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/////////////// GLOBALS ///////////////cbuffer MatrixBuffer&#123; matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix;&#125;;cbuffer ReflectionBuffer&#123; matrix reflectionMatrix;&#125;;//////////////// TYPEDEFS ////////////////struct VertexInputType&#123; float4 position : POSITION; float2 tex : TEXCOORD0;&#125;;struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float4 reflectionPosition : TEXCOORD1; float4 refractionPosition : TEXCOORD2;&#125;;////////////////////////////////////////////////////////////////////////////////// Vertex Shader////////////////////////////////////////////////////////////////////////////////PixelInputType WaterVertexShader(VertexInputType input)&#123; PixelInputType output; matrix reflectProjectWorld; matrix viewProjectWorld; // Calculate the position of the vertex against the world, view, and projection matrices. output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // Store the texture coordinates for the pixel shader. output.tex = input.tex; // Create the reflection projection world matrix. reflectProjectWorld = mul(reflectionMatrix, projectionMatrix); reflectProjectWorld = mul(worldMatrix, reflectProjectWorld); // Calculate the input position against the reflectProjectWorld matrix. output.reflectionPosition = mul(input.position, reflectProjectWorld); // Create the view projection world matrix for refraction. viewProjectWorld = mul(viewMatrix, projectionMatrix); viewProjectWorld = mul(worldMatrix, viewProjectWorld); // Calculate the input position against the viewProjectWorld matrix. output.refractionPosition = mul(input.position, viewProjectWorld); return output;&#125; &emsp;&emsp;WaterPixelShader 中，我们使用反射纹理和折射纹理混合，最终可以渲染出这样的效果： &emsp;&emsp;着色器代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Texture2D reflectionTexture;Texture2D refractionTexture;Texture2D normalTexture;cbuffer WaterBuffer&#123; float waterTranslation; float reflectRefractScale; float2 padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float4 reflectionPosition : TEXCOORD1; float4 refractionPosition : TEXCOORD2;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 WaterPixelShader(PixelInputType input) : SV_TARGET&#123; float2 reflectTexCoord; float2 refractTexCoord; float4 normalMap; float3 normal; float4 reflectionColor; float4 refractionColor; float4 color; // Calculate the projected reflection texture coordinates. reflectTexCoord.x = input.reflectionPosition.x / input.reflectionPosition.w / 2.0f + 0.5f; reflectTexCoord.y = -input.reflectionPosition.y / input.reflectionPosition.w / 2.0f + 0.5f; // Calculate the projected refraction texture coordinates. refractTexCoord.x = input.refractionPosition.x / input.refractionPosition.w / 2.0f + 0.5f; refractTexCoord.y = -input.refractionPosition.y / input.refractionPosition.w / 2.0f + 0.5f; // Sample the texture pixels from the textures using the updated texture coordinates. reflectionColor = reflectionTexture.Sample(SampleType, reflectTexCoord); refractionColor = refractionTexture.Sample(SampleType, refractTexCoord); // Combine the reflection and refraction results for the final color. color = lerp(reflectionColor, refractionColor, 0.6f); return color;&#125; &emsp;&emsp;但是水面并非为平面，所以我们需要一个变量来模仿波纹效果。我们使用法线向量来对纹理进行偏移，如下： 123456789// Sample the normal from the normal map texture.normalMap = normalTexture.Sample(SampleType, input.tex);// Expand the range of the normal from (0,1) to (-1,+1).normal = (normalMap.xyz * 2.0f) - 1.0f;// Re-position the texture coordinate sampling position by the normal map value to simulate the rippling wave effect.reflectTexCoord = reflectTexCoord + (normal.xy * reflectRefractScale);refractTexCoord = refractTexCoord + (normal.xy * reflectRefractScale); &emsp;&emsp;我们使用法线贴图读取法线，然后对折射和反射做一定程度上的偏移计算，使得水面出现一定的波纹效果。效果如下： &emsp;&emsp;和上图相比，由于折射和反射纹理的局部移位，我们的水面已经看起来很真实了，不过依旧可以改进，我们使用一个外部传进来的值来对法线贴图的纹理坐标进行计算以模拟水面的动态效果。 1input.tex.y += waterTranslation; &emsp;&emsp;这里就不截图了，反正截图也看不出来动态的效果。 &emsp;&emsp;最后，当我们修改完毕之后，我们的最终的 WaterPixelShader 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/////////////// GLOBALS ///////////////SamplerState SampleType;Texture2D reflectionTexture;Texture2D refractionTexture;Texture2D normalTexture;cbuffer WaterBuffer&#123; float waterTranslation; float reflectRefractScale; float2 padding;&#125;;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float4 reflectionPosition : TEXCOORD1; float4 refractionPosition : TEXCOORD2;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 WaterPixelShader(PixelInputType input) : SV_TARGET&#123; float2 reflectTexCoord; float2 refractTexCoord; float4 normalMap; float3 normal; float4 reflectionColor; float4 refractionColor; float4 color; // Move the position the water normal is sampled from to simulate moving water. input.tex.xy += waterTranslation; // Calculate the projected reflection texture coordinates. reflectTexCoord.x = input.reflectionPosition.x / input.reflectionPosition.w / 2.0f + 0.5f; reflectTexCoord.y = -input.reflectionPosition.y / input.reflectionPosition.w / 2.0f + 0.5f; // Calculate the projected refraction texture coordinates. refractTexCoord.x = input.refractionPosition.x / input.refractionPosition.w / 2.0f + 0.5f; refractTexCoord.y = -input.refractionPosition.y / input.refractionPosition.w / 2.0f + 0.5f; // Sample the normal from the normal map texture. normalMap = normalTexture.Sample(SampleType, input.tex); // Expand the range of the normal from (0,1) to (-1,+1). normal = (normalMap.xyz * 2.0f) - 1.0f; // Re-position the texture coordinate sampling position by the normal map value to simulate the rippling wave effect. reflectTexCoord = reflectTexCoord + (normal.xy * reflectRefractScale); refractTexCoord = refractTexCoord + (normal.xy * reflectRefractScale); // Sample the texture pixels from the textures using the updated texture coordinates. reflectionColor = reflectionTexture.Sample(SampleType, reflectTexCoord); refractionColor = refractionTexture.Sample(SampleType, refractTexCoord); // Combine the reflection and refraction results for the final color. color = lerp(reflectionColor, refractionColor, 0.6f); return color;&#125; &emsp;&emsp;我们有 waterTranslation ，reflectRefractScale 两个变量来对纹理坐标计算使得水面更加真实。在 WaterShaderClass 中我们对这两个着色器服务，声明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253////////////////////////////////////////////////////////////////////////////////// Class name: WaterShaderClass////////////////////////////////////////////////////////////////////////////////class WaterShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;; struct ReflectionBufferType &#123; DirectX::XMMATRIX reflection; &#125;; struct WaterBufferType &#123; float waterTranslation; float reflectRefractScale; DirectX::XMFLOAT2 padding; &#125;;public: WaterShaderClass(); WaterShaderClass(const WaterShaderClass&amp;); ~WaterShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, float, float);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, float, float); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_matrixBuffer; ID3D11Buffer* m_reflectionBuffer; ID3D11Buffer* m_waterBuffer;&#125;; &emsp;&emsp;在 GraphicsClass 中，我们实现将折射和反射渲染至纹理的方法，然后再用两张纹理和法线纹理来渲染水面，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184bool GraphicsClass::RenderRefractionToTexture()&#123; DirectX::XMFLOAT4 clipPlane; DirectX::XMMATRIX worldMatrix, viewMatrix, projectionMatrix; bool result; // Setup a clipping plane based on the height of the water to clip everything above it. clipPlane = DirectX::XMFLOAT4(0.0f, -1.0f, 0.0f, m_waterHeight + 0.1f); // Set the render target to be the refraction render to texture. m_RefractionTexture-&gt;SetRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView()); // Clear the refraction render to texture. m_RefractionTexture-&gt;ClearRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView(), 0.0f, 0.0f, 0.0f, 1.0f); // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Get the world, view, and projection matrices from the camera and d3d objects. m_D3D-&gt;GetWorldMatrix(worldMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); // Translate to where the bath model will be rendered. worldMatrix *= XMMatrixTranslation(0.0f, 2.0f, 0.0f); // Put the bath model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_BathModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the bath model using the light shader. result = m_RefractionShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_BathModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_BathModel-&gt;GetTexture(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor(), clipPlane); if(!result) &#123; return false; &#125; // Reset the render target back to the original back buffer and not the render to texture anymore. m_D3D-&gt;SetBackBufferRenderTarget(); return true;&#125;bool GraphicsClass::RenderReflectionToTexture()&#123; DirectX::XMMATRIX reflectionViewMatrix, worldMatrix, projectionMatrix; bool result; // Set the render target to be the reflection render to texture. m_ReflectionTexture-&gt;SetRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView()); // Clear the reflection render to texture. m_ReflectionTexture-&gt;ClearRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView(), 0.0f, 0.0f, 0.0f, 1.0f); // Use the camera to render the reflection and create a reflection view matrix. m_Camera-&gt;RenderReflection(m_waterHeight); // Get the camera reflection view matrix instead of the normal view matrix. reflectionViewMatrix = m_Camera-&gt;GetReflectionViewMatrix(); // Get the world and projection matrices from the d3d object. m_D3D-&gt;GetWorldMatrix(worldMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); // Translate to where the wall model will be rendered. worldMatrix *= XMMatrixTranslation(0.0f, 6.0f, 8.0f); // Put the wall model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_WallModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the wall model using the light shader and the reflection view matrix. result = m_LightShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_WallModel-&gt;GetIndexCount(), worldMatrix, reflectionViewMatrix, projectionMatrix, m_WallModel-&gt;GetTexture(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Reset the render target back to the original back buffer and not the render to texture anymore. m_D3D-&gt;SetBackBufferRenderTarget(); return true;&#125;bool GraphicsClass::RenderScene()&#123; DirectX::XMMATRIX worldMatrix, viewMatrix, projectionMatrix, reflectionMatrix; bool result; // Clear the buffers to begin the scene. m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Get the world, view, and projection matrices from the camera and d3d objects. m_D3D-&gt;GetWorldMatrix(worldMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); // Translate to where the ground model will be rendered. worldMatrix *= XMMatrixTranslation(0.0f, 1.0f, 0.0f); // Put the ground model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_GroundModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the ground model using the light shader. result = m_LightShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_GroundModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_GroundModel-&gt;GetTexture(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Translate to where the wall model will be rendered. worldMatrix *= XMMatrixTranslation(0.0f, 6.0f, 8.0f); // Put the wall model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_WallModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the wall model using the light shader. result = m_LightShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_WallModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_WallModel-&gt;GetTexture(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Translate to where the bath model will be rendered. worldMatrix *= XMMatrixTranslation(0.0f, 2.0f, 0.0f); // Put the bath model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_BathModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the bath model using the light shader. result = m_LightShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_BathModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_BathModel-&gt;GetTexture(), m_Light-&gt;GetDirection(), m_Light-&gt;GetAmbientColor(), m_Light-&gt;GetDiffuseColor()); if(!result) &#123; return false; &#125; // Reset the world matrix. m_D3D-&gt;GetWorldMatrix(worldMatrix); // Get the camera reflection view matrix. reflectionMatrix = m_Camera-&gt;GetReflectionViewMatrix(); // Translate to where the water model will be rendered. worldMatrix *= XMMatrixTranslation(0.0f, m_waterHeight, 0.0f); // Put the water model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_WaterModel-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the water model using the water shader. result = m_WaterShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_WaterModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, reflectionMatrix, m_ReflectionTexture-&gt;GetShaderResourceView(), m_RefractionTexture-&gt;GetShaderResourceView(), m_WaterModel-&gt;GetTexture(), m_waterTranslation, 0.01f); if(!result) &#123; return false; &#125; // Present the rendered scene to the screen. m_D3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;在 Render 里调用： 12345678910111213141516171819202122232425262728bool GraphicsClass::Render()&#123; bool result; // Render the refraction of the scene to a texture. result = RenderRefractionToTexture(); if(!result) &#123; return false; &#125; // Render the reflection of the scene to a texture. result = RenderReflectionToTexture(); if(!result) &#123; return false; &#125; // Render the scene as normal to the back buffer. result = RenderScene(); if(!result) &#123; return false; &#125; return true;&#125; &emsp;&emsp;源代码：DX11Tutorial-Water]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】31-屏幕淡入淡出效果]]></title>
    <url>%2F2018%2F04%2F14%2F%E3%80%90DirectX%E3%80%9131-%E5%B1%8F%E5%B9%95%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 28: Screen Fades 学习记录&emsp;&emsp;这一篇文章中我们将基于之前的代码内容来实现场景中创建淡入淡出的效果。框架应当如下： &emsp;&emsp;新加的 BitmapClass , FadeShaderClass 两个类我们将在下边详细介绍。 &emsp;&emsp;淡入淡出的代码说起来很简单，我们先将需要渲染的内容渲染至纹理，然后根据在短时间内增加或者减少颜色以达到淡入淡出效果。首先我们需要渲染一张至屏幕的纹理，那么就需要一张屏幕贴图，这个由我们的 bitmapclass 类来做。这个类可以创建两个三角形覆盖屏幕并且贴图，也可以只是创建两个三角形覆盖屏幕，使用此缓冲区和 RenderTextureClass 所生成的纹理来渲染。 &emsp;&emsp;BitmapClass 类的声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#pragma once#include &lt;D3D11.h&gt;#include &lt;DirectXMath.h&gt;#include "textureclass.h"class BitmapClass&#123;private: struct VertexType &#123; DirectX::XMFLOAT3 position; DirectX::XMFLOAT2 texture; &#125;;public: BitmapClass(); BitmapClass(const BitmapClass&amp;); ~BitmapClass(); bool Initialize(ID3D11Device*, int, int, int, int); void Shutdown(); bool Render(ID3D11DeviceContext*, int, int); int GetIndexCount() const;private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); bool UpdateBuffers(ID3D11DeviceContext*, int, int); void RenderBuffers(ID3D11DeviceContext*); bool LoadTexture(ID3D11Device*, CHAR*); void ReleaseTexture();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; TextureClass *m_Texture; int m_vertexCount, m_indexCount; int m_screenWidth, m_screenHeight; int m_bitmapWidth, m_bitmapHeight; int m_previousPosX, m_previousPosY;&#125;; &emsp;&emsp;这个类将根据给定的 w 和 h 生成一张覆盖屏幕的位图，在声明中我们有读取纹理和释放纹理的操作，不过在这篇文章中并未使用。 &emsp;&emsp;FadeShaderClass 则是由 TextureShaderClass 修改而来，它多了一个 FadeAmount 属性来控制纹理显示颜色。它的声明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class FadeShaderClass&#123;private: struct MatrixBufferType &#123; DirectX::XMMATRIX world; DirectX::XMMATRIX view; DirectX::XMMATRIX projection; &#125;; struct FadeBufferType &#123; float fadeAmount; DirectX::XMFLOAT3 padding; &#125;;public: FadeShaderClass(); FadeShaderClass(const FadeShaderClass&amp;); ~FadeShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, float);private: bool InitializeShader(ID3D11Device*, HWND, CHAR*, CHAR*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, CHAR*); bool SetShaderParameters(ID3D11DeviceContext*, DirectX::XMMATRIX, DirectX::XMMATRIX, DirectX::XMMATRIX, ID3D11ShaderResourceView*, float); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11SamplerState* m_sampleState; struct ID3D11Buffer* m_fadeBuffer;&#125;; &emsp;&emsp;可以看到我们的多了一个 FadeBufferType 类型，这个类型只有一个 float 变量（另外那个是用来对齐的）。实现也是比较简单，在 InitializeShader 方法里，我们初始化了 fadeBuffer ： 12345678910111213141516........ // Setup the description of the fade dynamic constant buffer that is in the vertex shader. fadeBufferDesc.Usage = D3D11_USAGE_DYNAMIC; fadeBufferDesc.ByteWidth = sizeof(FadeBufferType); fadeBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER; fadeBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; fadeBufferDesc.MiscFlags = 0; fadeBufferDesc.StructureByteStride = 0; // Create the constant buffer pointer so we can access the pixel shader constant buffer from within this class. result = pDevice-&gt;CreateBuffer(&amp;fadeBufferDesc, NULL, &amp;m_fadeBuffer); if(FAILED(result)) &#123; return false; &#125;........ &emsp;&emsp;这两个类实现后我们就可以简单的来实现这个效果了。为了节省资源，我们在渲染的时候首先会判断当前淡入的动画是否完毕，如果没有完毕。我们会先将内容渲染至纹理，这个交以 FadeShaderClass 来处理。然后在将纹理贴图到屏幕位图中，如果已经完毕，则直接渲染至后台缓冲。 &emsp;&emsp;GraphicsClass 更新后的定义如下： 1234567891011121314151617181920212223242526272829303132////////////////////////////////////////////////////////////////////////////////// Class name: GraphicsClass////////////////////////////////////////////////////////////////////////////////class GraphicsClass&#123;public: GraphicsClass(); GraphicsClass(const GraphicsClass&amp;); ~GraphicsClass(); bool Initialize(int, int, HWND); void Shutdown(); bool Frame(float frameTime); bool Render();private: bool RenderToTexture(float rotation); bool RenderFadingScene(); bool RenderNormalScene(float); D3DClass* m_D3D; CameraClass* m_Camera; ModelClass* m_Model; TextureShaderClass* m_TextureShader; RenderTextureClass* m_RenderTexture; BitmapClass* m_Bitmap; float m_fadeInTime, m_accumulatedTime, m_fadePercentage; bool m_fadeDone; FadeShaderClass* m_FadeShader;&#125;; &emsp;&emsp;我们增加了几个成员变量，用来控制淡入淡出的动画效果。m_fadeDone 判断动画效果是否结束，m_fadeInTime 则是动画效果的总时间，m_accumulatedTime 则是已累积时间，m_fadePercentage 代表我们将会渲染的颜色亮度的百分比。当累积时间超过总时间的时候，动画结束。 &emsp;&emsp;在初始化方法里初始化这几个值： 1234567891011121314m_fadeInTime = 3000.0f;m_accumulatedTime = 0;m_fadePercentage = 0;m_fadeDone = false;m_FadeShader = new FadeShaderClass;if (!m_FadeShader) &#123; return false;&#125;result = m_FadeShader-&gt;Initialize(m_D3D-&gt;GetDevice(), hwnd);if (!result) &#123; MessageBox(hwnd, "Could not initialize the fade shader object", "Error", MB_OK); return false;&#125; &emsp;&emsp;Frame 方法里，我们每帧更新累积值以及淡入百分比，直到动画结束。 123456789101112131415bool GraphicsClass::Frame(float frameTime)&#123; // Set the position of the camera. if (!m_fadeDone) &#123; m_accumulatedTime += frameTime; if (m_accumulatedTime &lt; m_fadeInTime) &#123; m_fadePercentage = m_accumulatedTime / m_fadeInTime; &#125; else &#123; m_fadeDone = true; m_fadePercentage = 1.0f; &#125; &#125; m_Camera-&gt;SetPosition(0.0f, 0.0f, -10.0f); return true;&#125; &emsp;&emsp;最后，在 Render 方法里，我们根据当前是否在动画状态选择不一样的渲染方式： 123456789101112131415161718192021222324252627282930bool GraphicsClass::Render()&#123; bool result; static float rotation = 0.0f; rotation += (float)XM_PI * 0.005f; if (rotation &gt; 360.0f) &#123; rotation -= 360.0f; &#125; if (m_fadeDone) &#123; RenderNormalScene(rotation); &#125; else &#123; // Render the entire scene as a reflection to the texture first. result = RenderToTexture(rotation); if (!result) &#123; return false; &#125; // Render the scene as normal to the back buffer. result = RenderFadingScene(); if (!result) &#123; return false; &#125; &#125; return true;&#125; &emsp;&emsp;RenderToTexture 与 RenderFadingScene 方法定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778bool GraphicsClass::RenderToTexture(float rotation)&#123; XMMATRIX worldMatrix, viewMatrix, projectionMatrix; bool result; // Set the render target to be the render to texture. m_RenderTexture-&gt;SetRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView()); // Clear the render to texture. m_RenderTexture-&gt;ClearRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView(), 0.0f, 0.0f, 0.0f, 1.0f); // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Get the world, view, and projection matrices from the camera and d3d objects. m_D3D-&gt;GetWorldMatrix(worldMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); // Multiply the world matrix by the rotation. worldMatrix = worldMatrix * XMMatrixRotationY(rotation); // Put the model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_Model-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the model with the texture shader. result = m_TextureShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_Model-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_Model-&gt;GetTexture()); if(!result) &#123; return false; &#125; // Reset the render target back to the original back buffer and not the render to texture anymore. m_D3D-&gt;SetBackBufferRenderTarget(); return true;&#125;bool GraphicsClass::RenderFadingScene()&#123; XMMATRIX worldMatrix, viewMatrix, orthoMatrix; bool result; // Clear the buffers to begin the scene. m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f); // Generate the view matrix based on the camera's position. m_Camera-&gt;Render(); // Get the world, view, and projection matrices from the camera and d3d objects. m_D3D-&gt;GetWorldMatrix(worldMatrix); m_Camera-&gt;GetViewMatrix(viewMatrix); m_D3D-&gt;GetOrthoMatrix(orthoMatrix); m_D3D-&gt;TurnZBufferOff(); result = m_Bitmap-&gt;Render(m_D3D-&gt;GetDeviceContext(), 0, 0); if (!result) &#123; return false; &#125; result = m_FadeShader-&gt;Render( m_D3D-&gt;GetDeviceContext(), m_Bitmap-&gt;GetIndexCount(), worldMatrix, viewMatrix, orthoMatrix, m_RenderTexture-&gt;GetShaderResourceView(), m_fadePercentage); if (!result) &#123; return false; &#125; m_D3D-&gt;TurnZBufferOn(); // Present the rendered scene to the screen. m_D3D-&gt;EndScene(); return true;&#125; &emsp;&emsp;RenderNormalScene 则是直接渲染至后台缓冲。 &emsp;&emsp;我们的着色器代码也是比较简单，顶点着色器和普通一样，而像素着色器则是新增了一个缓冲： 12345cbuffer FadeBuffer&#123; float fadeAmount; float3 padding; // 占位用的&#125;; &emsp;&emsp;我们将纹理采样的值与 fadeAmount 相乘则是最终的颜色了。 123456789101112float4 FadePixelShader(PixelInputType input) : SV_TARGET&#123; float4 color; // Sample the texture pixel at this location. color = shaderTexture.Sample(SampleType, input.tex); // Reduce the color brightness to the current fade percentage. color = color * fadeAmount; return color;&#125; &emsp;&emsp;最终效果则是一个淡淡变量的立方体。我随便截了一张淡入过程中的图，如下： &emsp;&emsp;源代码：DX11Tutorial-ScreenFades]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】30-框架的简单梳理]]></title>
    <url>%2F2018%2F04%2F14%2F%E3%80%90DirectX%E3%80%9130-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 27: Reflection 学习记录&emsp;&emsp;上一篇里， 我们再次的启用了框架，之前的内容里我们已经基本学完了 dx 的基础 api 知识 ，之后多是对其的用法。现在我们使用框架后，虽然觉得应该很轻松使用了，但是还是简单的梳理一下比较好。这一篇便是做此处理，顺便对框架的某些内容做以修改。 &emsp;&emsp;以上是从 rastertek 的教程框架截图而来，我想光是看框架的图就已经很明白了。我们的框架以 WinMain 为入口， SystemClass 包含输入 Input 与 Graphics 输出。 &emsp;&emsp;Input 输入较为简单， Graphics 则是包含诸多内容： &emsp;&emsp;D3DClass 负责对于 D3D 设备的初始化以及统一控制，其封装了 D3D 设备的初始化以及调用等等内容，其声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152////////////////////////////////////////////////////////////////////////////////// Class name: D3DClass////////////////////////////////////////////////////////////////////////////////class D3DClass&#123;public: D3DClass(); D3DClass(const D3DClass&amp;); ~D3DClass(); bool Initialize(int, int, bool, HWND, bool, float, float); void Shutdown(); void BeginScene(float, float, float, float); void EndScene(); ID3D11Device* GetDevice(); ID3D11DeviceContext* GetDeviceContext(); void GetProjectionMatrix(D3DXMATRIX&amp;); void GetWorldMatrix(D3DXMATRIX&amp;); void GetOrthoMatrix(D3DXMATRIX&amp;); void TurnZBufferOn(); void TurnZBufferOff(); void TurnOnAlphaBlending(); void TurnOffAlphaBlending(); ID3D11DepthStencilView* GetDepthStencilView(); void SetBackBufferRenderTarget();private: bool m_vsync_enabled; IDXGISwapChain* m_swapChain; ID3D11Device* m_device; ID3D11DeviceContext* m_deviceContext; ID3D11RenderTargetView* m_renderTargetView; ID3D11Texture2D* m_depthStencilBuffer; ID3D11DepthStencilState* m_depthStencilState; ID3D11DepthStencilView* m_depthStencilView; ID3D11RasterizerState* m_rasterState; D3DXMATRIX m_projectionMatrix; D3DXMATRIX m_worldMatrix; D3DXMATRIX m_orthoMatrix; ID3D11DepthStencilState* m_depthDisabledStencilState; ID3D11BlendState* m_alphaEnableBlendingState; ID3D11BlendState* m_alphaDisableBlendingState;&#125;; &emsp;&emsp;CameraClass 封装了摄像机操作，其声明如下： 12345678910111213141516171819202122232425////////////////////////////////////////////////////////////////////////////////// Class name: CameraClass////////////////////////////////////////////////////////////////////////////////class CameraClass&#123;public: CameraClass(); CameraClass(const CameraClass&amp;); ~CameraClass(); void SetPosition(float, float, float); void SetRotation(float, float, float); void Render(); void GetViewMatrix(D3DXMATRIX&amp;); void RenderReflection(float); D3DXMATRIX GetReflectionViewMatrix();private: D3DXMATRIX m_viewMatrix; float m_positionX, m_positionY, m_positionZ; float m_rotationX, m_rotationY, m_rotationZ; D3DXMATRIX m_reflectionViewMatrix;&#125;; &emsp;&emsp;ModelClass 主要负责模型部分，它包括了模型的渲染，其下有 TextureClass 类负责模型的纹理，声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849////////////////////////////////////////////////////////////////////////////////// Class name: ModelClass////////////////////////////////////////////////////////////////////////////////class ModelClass&#123;private: struct VertexType &#123; D3DXVECTOR3 position; D3DXVECTOR2 texture; D3DXVECTOR3 normal; &#125;; struct ModelType &#123; float x, y, z; float tu, tv; float nx, ny, nz; &#125;;public: ModelClass(); ModelClass(const ModelClass&amp;); ~ModelClass(); bool Initialize(ID3D11Device*, char*, char*); void Shutdown(); void Render(ID3D11DeviceContext*); int GetIndexCount(); ID3D11ShaderResourceView* GetTexture();private: bool InitializeBuffers(ID3D11Device*); void ShutdownBuffers(); void RenderBuffers(ID3D11DeviceContext*); bool LoadTexture(ID3D11Device*, char*); void ReleaseTexture(); bool LoadModel(char*); void ReleaseModel();private: ID3D11Buffer *m_vertexBuffer, *m_indexBuffer; int m_vertexCount, m_indexCount; TextureClass* m_Texture; ModelType* m_model;&#125;; &emsp;&emsp;TextureClass 如下： 123456789101112131415161718////////////////////////////////////////////////////////////////////////////////// Class name: TextureClass////////////////////////////////////////////////////////////////////////////////class TextureClass&#123;public: TextureClass(); TextureClass(const TextureClass&amp;); ~TextureClass(); bool Initialize(ID3D11Device*, char*); void Shutdown(); ID3D11ShaderResourceView* GetTexture();private: ID3D11ShaderResourceView* m_texture;&#125;; &emsp;&emsp;RenderTextureClass 我们封装了离屛渲染的方法，使用它我们可以将画面渲染至纹理以实现一些后期处理。其声明如下： 12345678910111213141516171819202122////////////////////////////////////////////////////////////////////////////////// Class name: RenderTextureClass////////////////////////////////////////////////////////////////////////////////class RenderTextureClass&#123;public: RenderTextureClass(); RenderTextureClass(const RenderTextureClass&amp;); ~RenderTextureClass(); bool Initialize(ID3D11Device*, int, int); void Shutdown(); void SetRenderTarget(ID3D11DeviceContext*, ID3D11DepthStencilView*); void ClearRenderTarget(ID3D11DeviceContext*, ID3D11DepthStencilView*, float, float, float, float); ID3D11ShaderResourceView* GetShaderResourceView();private: ID3D11Texture2D* m_renderTargetTexture; ID3D11RenderTargetView* m_renderTargetView; ID3D11ShaderResourceView* m_shaderResourceView;&#125;; &emsp;&emsp;TextureShaderClass 类中，我们主要封装了与 Shader 交互的操作，其他有些特殊的 Shader 类则可以由这个类修改而成。其声明如下： 12345678910111213141516171819202122232425262728293031323334353637////////////////////////////////////////////////////////////////////////////////// Class name: TextureShaderClass////////////////////////////////////////////////////////////////////////////////class TextureShaderClass&#123;private: struct MatrixBufferType &#123; D3DXMATRIX world; D3DXMATRIX view; D3DXMATRIX projection; &#125;;public: TextureShaderClass(); TextureShaderClass(const TextureShaderClass&amp;); ~TextureShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*);private: bool InitializeShader(ID3D11Device*, HWND, char*, char*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, char*); bool SetShaderParameters(ID3D11DeviceContext*, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11SamplerState* m_sampleState;&#125;; &emsp;&emsp;ReflectionShaderClass 则就是以 TextureShaderClass 类为基础的一个特殊类，它封装了反射纹理的操作，在上篇文章中我们使用它来渲染了反射效果，声明如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445////////////////////////////////////////////////////////////////////////////////// Class name: ReflectionShaderClass////////////////////////////////////////////////////////////////////////////////class ReflectionShaderClass&#123;private: struct MatrixBufferType &#123; D3DXMATRIX world; D3DXMATRIX view; D3DXMATRIX projection; &#125;; struct ReflectionBufferType &#123; D3DXMATRIX reflectionMatrix; &#125;;public: ReflectionShaderClass(); ReflectionShaderClass(const ReflectionShaderClass&amp;); ~ReflectionShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, D3DXMATRIX);private: bool InitializeShader(ID3D11Device*, HWND, char*, char*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, char*); bool SetShaderParameters(ID3D11DeviceContext*, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, D3DXMATRIX); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_reflectionBuffer;&#125;; &emsp;&emsp;对于框架的更改，我们只是简单的对所使用的数学库进行升级，使用 DirectXMath 数学库，修改的内容比较多，所以不在此完整列出，源代码可以直接下载。 &emsp;&emsp;源代码：DX11Tutorial-ScreenFades]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】29-平面反射]]></title>
    <url>%2F2018%2F04%2F13%2F%E3%80%90DirectX%E3%80%9129-%E5%B9%B3%E9%9D%A2%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 27: Reflection 学习记录&emsp;&emsp;这一篇文章中，我们主要介绍在 dx11 中实现平面反射。与之前不同，这篇文章和之后的源代码我们将使用已有框架来进行实验（事实上是因为代码逐渐变多之后看的好乱），相信在之前基础知识完成学习后对于这个框架已经没有多少入手难度了。源码将在文末下载。 &emsp;&emsp; 创建反射我们首先会将要渲染的物体的反射图案渲染到纹理上，然后用纹理与镜面混合，最终达到反射效果。将 cube 的反射图案渲染至纹理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142bool GraphicsClass::RenderToTexture()&#123; D3DXMATRIX worldMatrix, reflectionViewMatrix, projectionMatrix; static float rotation = 0.0f; // Set the render target to be the render to texture. m_RenderTexture-&gt;SetRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView()); // Clear the render to texture. m_RenderTexture-&gt;ClearRenderTarget(m_D3D-&gt;GetDeviceContext(), m_D3D-&gt;GetDepthStencilView(), 0.0f, 0.0f, 0.0f, 1.0f); // Use the camera to calculate the reflection matrix. m_Camera-&gt;RenderReflection(-1.5f); // Get the camera reflection view matrix instead of the normal view matrix. reflectionViewMatrix = m_Camera-&gt;GetReflectionViewMatrix(); // Get the world and projection matrices. m_D3D-&gt;GetWorldMatrix(worldMatrix); m_D3D-&gt;GetProjectionMatrix(projectionMatrix); // Update the rotation variable each frame. rotation += (float)D3DX_PI * 0.005f; if(rotation &gt; 360.0f) &#123; rotation -= 360.0f; &#125; D3DXMatrixRotationY(&amp;worldMatrix, rotation); // Put the model vertex and index buffers on the graphics pipeline to prepare them for drawing. m_Model-&gt;Render(m_D3D-&gt;GetDeviceContext()); // Render the model using the texture shader and the reflection view matrix. m_TextureShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_Model-&gt;GetIndexCount(), worldMatrix, reflectionViewMatrix, projectionMatrix, m_Model-&gt;GetTexture()); // Reset the render target back to the original back buffer and not the render to texture anymore. m_D3D-&gt;SetBackBufferRenderTarget(); return true;&#125; &emsp;&emsp;与普通的渲染至纹理不同，这次我们采用了 reflectionViewMatrix = m_Camera-&gt;GetReflectionViewMatrix(); 来代替普通的 view 矩阵，ReflectionViewMatrix 定义如下： 123456789101112131415161718192021222324252627282930void CameraClass::RenderReflection(float height)&#123; D3DXVECTOR3 up, position, lookAt; float radians; // Setup the vector that points upwards. up.x = 0.0f; up.y = 1.0f; up.z = 0.0f; // Setup the position of the camera in the world. // For planar reflection invert the Y position of the camera. position.x = m_positionX; position.y = -m_positionY + (height * 2.0f); position.z = m_positionZ; // Calculate the rotation in radians. radians = m_rotationY * 0.0174532925f; // Setup where the camera is looking. lookAt.x = sinf(radians) + m_positionX; lookAt.y = position.y; lookAt.z = cosf(radians) + m_positionZ; // Create the view matrix from the three vectors. D3DXMatrixLookAtLH(&amp;m_reflectionViewMatrix, &amp;position, &amp;lookAt, &amp;up); return;&#125; &emsp;&emsp;可以看到，我们使用一个高度作为参数来设置一个对于 x , z 平面的 Reflection 矩阵。在设置中也是简单的对 y 轴做以修改。 &emsp;&emsp;之后，我们使用类 ReflectionShaderClass 来渲染反射纹理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263////////////////////////////////////////////////////////////////////////////////// Filename: reflectionshaderclass.h////////////////////////////////////////////////////////////////////////////////#ifndef _REFLECTIONSHADERCLASS_H_#define _REFLECTIONSHADERCLASS_H_//////////////// INCLUDES ////////////////#include &lt;D3D11.h&gt;#include &lt;D3DX10math.h&gt;#include &lt;fstream&gt;using namespace std;////////////////////////////////////////////////////////////////////////////////// Class name: ReflectionShaderClass////////////////////////////////////////////////////////////////////////////////class ReflectionShaderClass&#123;private: struct MatrixBufferType &#123; D3DXMATRIX world; D3DXMATRIX view; D3DXMATRIX projection; &#125;; struct ReflectionBufferType &#123; D3DXMATRIX reflectionMatrix; &#125;;public: ReflectionShaderClass(); ReflectionShaderClass(const ReflectionShaderClass&amp;); ~ReflectionShaderClass(); bool Initialize(ID3D11Device*, HWND); void Shutdown(); bool Render(ID3D11DeviceContext*, int, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, D3DXMATRIX);private: bool InitializeShader(ID3D11Device*, HWND, char*, char*); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, char*); bool SetShaderParameters(ID3D11DeviceContext*, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*, ID3D11ShaderResourceView*, D3DXMATRIX); void RenderShader(ID3D11DeviceContext*, int);private: ID3D11VertexShader* m_vertexShader; ID3D11PixelShader* m_pixelShader; ID3D11InputLayout* m_layout; ID3D11Buffer* m_matrixBuffer; ID3D11SamplerState* m_sampleState; ID3D11Buffer* m_reflectionBuffer;&#125;;#endif &emsp;&emsp;这个和我们直接的 shader 类差不多，除了多出了一个新的矩阵变量，这个变量我们将传入着色器来为我们渲染正确的目标。 &emsp;&emsp;在我们的顶点着色器里，我们在它对于像素着色器的输出结构体里新增了一个属性，它用来保存纹理的输入的位置： 123456struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float4 reflectionPosition : TEXCOORD1;&#125;; &emsp;&emsp;同时，使用反射矩阵来设置新增的变量： 123456// Create the reflection projection world matrix.reflectProjectWorld = mul(reflectionMatrix, projectionMatrix);reflectProjectWorld = mul(worldMatrix, reflectProjectWorld);// Calculate the input position against the reflectProjectWorld matrix.output.reflectionPosition = mul(input.position, reflectProjectWorld); &emsp;&emsp;像素着色器中，我们将反射位置映射到 0 - 1 之间作为纹理坐标使用，然后读取我们之前渲染的纹理，最后于平面纹理进行混合： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950////////////////////////////////////////////////////////////////////////////////// Filename: reflection.ps/////////////////////////////////////////////////////////////////////////////////////////////// GLOBALS ///////////////Texture2D shaderTexture;SamplerState SampleType;Texture2D reflectionTexture;//////////////// TYPEDEFS ////////////////struct PixelInputType&#123; float4 position : SV_POSITION; float2 tex : TEXCOORD0; float4 reflectionPosition : TEXCOORD1;&#125;;////////////////////////////////////////////////////////////////////////////////// Pixel Shader////////////////////////////////////////////////////////////////////////////////float4 ReflectionPixelShader(PixelInputType input) : SV_TARGET&#123; float4 textureColor; float2 reflectTexCoord; float4 reflectionColor; float4 color; // Sample the texture pixel at this location. textureColor = shaderTexture.Sample(SampleType, input.tex); // Calculate the projected reflection texture coordinates. reflectTexCoord.x = input.reflectionPosition.x / input.reflectionPosition.w / 2.0f + 0.5f; reflectTexCoord.y = -input.reflectionPosition.y / input.reflectionPosition.w / 2.0f + 0.5f; // Sample the texture pixel from the reflection texture using the projected texture coordinates. reflectionColor = reflectionTexture.Sample(SampleType, reflectTexCoord); // Do a linear interpolation between the two textures for a blend effect. color = lerp(textureColor, reflectionColor, 0.15f); return color;&#125; &emsp;&emsp;最终效果如下： &emsp;&emsp;（这篇文章开始使用近似于框架的方式来组织代码，可能显得比较突兀，稍后会专门再介绍一下这个框架的构造） &emsp;&emsp;源代码：DX11Tutorial-Reflection]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CXX中operator-new/delete与new/delete-operator]]></title>
    <url>%2F2018%2F04%2F12%2FCXX-operator-new%3Adelete%E4%B8%8Enew%3Adelete-operator%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;C++中，我们用 new 和 delete 来创建和销毁对象指针，这是一个内建操作符，就像是 sizeof 一样。它为我们申请了一块空间，并且使用我们所要申请的类对象的构造方法为这块空间初始化。 &emsp;&emsp;这篇文章，主要介绍 operator new/delete 与 new/delete operator 。 &emsp;&emsp;首先给定结论：new operator 是一个操作符，而 operator 是一个函数。我们无法去改变 new operator 所做的事，但是我们可以重写或者重载 operator new 函数。 &emsp;&emsp;如文章开始所说，new operator 是一个用来申请空间创建对象的操作符，它申请空间则是使用的 operator new 。operator new 的声明通常如下： 1void * operator new(size_t size); &emsp;&emsp;它的返回值为 void * ，一个指向一块原始的、未设初值的内存。如果我们愿意，我们也可以直接使用它来申请空间： 1void * emptyMemory = operator new(10); &emsp;&emsp;这种使用相当于我们调用 malloc ，因为它的唯一任务就是分配内存。而我们调用 new operator 的时候，它会先调用 operator new 申请内存，然后将其转换为一个对象并返回。例如我们如下的调用： 1string *p = new string("M"); &emsp;&emsp;它的实现类似于下边的内容： 123void * m = operator new(sizeof(string));call string::string("M") on *m;string *p = static_cast&lt;string*&gt;(m); &emsp;&emsp;它的过程就是先申请内存，然后调用对应的构造函数，最后转换为我们所需要的指针对象。 &emsp;&emsp;operator delete 和 delete operator 也是这样的，和他们所对应的 new 类似。delete operator 也是一个内建操作符，operator delete 则是函数。operator delete 的声明如下： 1void operator delete(void* memory); &emsp;&emsp;和 new 相反的是，在执行 delete p 的时候，他首先会调用对应析构函数然后才使用 operator delete ，如下： 12p-&gt;~string();operator delete(p);]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】28-透明混合]]></title>
    <url>%2F2018%2F04%2F12%2F%E3%80%90DirectX%E3%80%9128-%E9%80%8F%E6%98%8E%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 26: Transparency 【D3D11游戏编程】学习笔记十五：混合（Blending） 学习记录&emsp;&emsp;这篇文章中，我们将简单的介绍在 DX 中实现透明度混合的方法。开启混合时，当像素片段通过深度测试后，不会直接覆盖掉原缓冲中的颜色，而是使用透明度因子进行插值，结果作为当前点的颜色，这就是混合。 &emsp;&emsp;要使用混合的话，我们需要设置 Blend State ，和其他的一样我们需要创建相应指针对象然后进行设置，首先声明一个 ID3D11BlendState 指针： 1ID3D11BlendState *pD3DBlendState = nullptr; &emsp;&emsp;在 InitWindowAndD3D 方法里我们新加入一个需要初始化的指针： 1234567891011inline HRESULT InitWindowAndD3D( const HINSTANCE hInstance, const char * windowName, HWND * hWnd, IDXGISwapChain **pSwapChain, ID3D11BlendState **pD3DBlendState, // 这里 ID3D11RenderTargetView **pRenderTargetView, ID3D11Device **pDevice, ID3D11DeviceContext **pImmediateContext) &#123; ..............&#125; &emsp;&emsp;然后进行初始化： 12345678910111213141516D3D11_BLEND_DESC dd;ZeroMemory(&amp;dd, sizeof(dd));dd.RenderTarget[0].BlendEnable = true;dd.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;dd.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;dd.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;dd.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;dd.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;dd.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;dd.RenderTarget[0].RenderTargetWriteMask = 0x0f;hr = (*pDevice)-&gt;CreateBlendState(&amp;dd, pD3DBlendState);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateBlendState_Error", "Error", MB_OK); return hr;&#125; &emsp;&emsp;那些赋值的含义如下： ​ D3D11_BLEND_ZERO：此外针对颜色混合，F为（0，0，0），针对alpha值，F为0。 ​ D3D11_BLEND_ONE：针对颜色混合为（1，1，1），针对alpha值为1； ​ D3D11_BLEND_SRC_COLOR：针对颜色混合为（Rs，Gs, Bs），针对alpha值为As； ​ D3D11_BLEND_INV_SRC_COLOR：针对颜色混合为（1-Rs，1-Gs，1-Bs），针对alpha值为1-As； ​ D3D11_BLEND_SRC_ALPHA：针对颜色混合为（As,As,As），针对alpha值为As； ​ D3D11_BLEND_INV_SRC_ALPHA：针对颜色混合为（1-As,1-As,1-As），针对alpha值为1-As； ​ D3D11_BLEND_DEST_COLOR：针对颜色混合为（Rd,Gd,Bd），针对alpha值为Ad； ​ D3D11_BLEND_INV_DESC_COLOR：针对颜色混合为（1-Rd,1-Gd,1-Bd），针对alpha值为1-Ad； ​ D3D11_BLEND_DEST_ALPHA：针对颜色混合为（Ad,Ad,Ad），针对alpha值为Ad； ​ D3D11_BLEND_INV_DEST_ALPHA：针对颜色混合为(1-Rd,1-Rd,1-Rd），针对alpha值为1-Ad； ​ D3D11_BLEND_BLEND_FACTOR：此时的混合因子为程序员指定的颜色值（R,G,B,A)，针对颜色混合为(R,G,B)，针对alpha值为A。该颜色值通过函数ID3D11DeviceContext::OMSetBlendState来指定； ​ D3D11_BLEND_INV_BLEND_FACTOR：同上，为程序员指定颜色值，针对颜色混合为(1-R,1-G,1-B)，针对alpha值为1-A。 &emsp;&emsp;之后，我们可以开始渲染了。这次会渲染两个变形后的 cube ，一个在前开启了混合，一个在后未开启混合，并且两个有一定区域的重叠。 &emsp;&emsp;我们定义两个 cube 的世界坐标矩阵： 1234XMMATRIX worldMatrix[2] = &#123; XMMatrixIdentity() * XMMatrixScaling(1.5 , 1.5 , 0.2), XMMatrixIdentity() * XMMatrixScaling(1.5 , 1.5 , 0.2) * XMMatrixTranslation(1.0 , 1.0 , 1.0)&#125;; &emsp;&emsp;请注意，当我们使用混合渲染的时候，渲染顺序必须是从后往前，即深度从大到小，否则无法实现混合效果。因为我们如果先绘制深度小的部分，后绘制的部分在深度测试的时候就被丢弃了。 &emsp;&emsp;现在，渲染两个 cube ： 12345678910111213141516171819202122232425262728293031323334353637matrix3d.world = worldMatrix[1];Update3DModelWorld(matrix3d, pMatrixDBuffer3D, &amp;pD3DImmediateContext);DrawModelIndex( cubeVertexNum, pCubeVertexBufferObject, pCubeIndexBufferObject, pMatrixDBuffer3D, pCubeSamplerState, nNumCubeTex, pCubeShaderResourceView, pCubeVertexShader, pCubePixelShader, pCubeInputLayout, pDepthStencilView, pEnableDepthStencilState, &amp;pRenderTargetViewT, &amp;pD3DImmediateContext);pD3DImmediateContext-&gt;OMSetBlendState(pD3DBlendState, bkgc, D3D11_DEFAULT_SAMPLE_MASK);matrix3d.world = worldMatrix[0];Update3DModelWorld(matrix3d, pMatrixDBuffer3D, &amp;pD3DImmediateContext);DrawModelIndex( cubeVertexNum, pCubeVertexBufferObject, pCubeIndexBufferObject, pMatrixDBuffer3D, pCubeSamplerState, nNumCubeTex, pCubeShaderResourceView, pCubeVertexShader, pCubePixelShader, pCubeInputLayout, pDepthStencilView, pEnableDepthStencilState, &amp;pRenderTargetViewT, &amp;pD3DImmediateContext);pD3DImmediateContext-&gt;OMSetBlendState(0, bkgc, D3D11_DEFAULT_SAMPLE_MASK); &emsp;&emsp;可以看到，在渲染第二个 cube 之前，我们开启了 blend ，渲染完毕后又直接关闭掉了它。 &emsp;&emsp;最后，我们在片段着色器里直接设置 cube 颜色的透明度为 0.5 ： 12345float4 main(pixelInputType input) : SV_TARGET &#123; float4 color = tex[0].Sample(samp, input.texcoord); color.a = 0.5f; return color;&#125; &emsp;&emsp;最终效果如下： &emsp;&emsp;当渲染靠后的 cube 的时候，我们并未开启 blend ，所以它是完全可见的，而较近的那个则变成了透明状。 &emsp;&emsp;源代码：DX11Tutorial-Transparency]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】27-雾效果]]></title>
    <url>%2F2018%2F04%2F10%2F%E3%80%90DirectX%E3%80%9127-%E9%9B%BE%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 23: Fog 学习记录&emsp;&emsp;在这篇开始，我们首先需要纠正上一篇部分的错误之处，在上一篇我们渲染到纹理的时候，渲染了一张 200 x 200 的纹理，然后使用的还是我们之前渲染 1920 x 1080 后缓冲用的深度缓冲，所以会出现错误，错误信息如下： &emsp;&emsp;D3D11 ERROR: ID3D11DeviceContext::OMSetRenderTargets: The RenderTargetView at slot 0 is not compatible with the DepthStencilView. DepthStencilViews may only be used with RenderTargetViews if the effective dimensions of the Views are equal, as well as the Resource types, multisample count, and multisample quality. The RenderTargetView at slot 0 has (w:200,h:200,as:1), while the Resource is a Texture2D with (mc:1,mq:0). The DepthStencilView has (w:1920,h:1080,as:1), while the Resource is a Texture2D with (mc:1,mq:0). [ STATE_SETTING ERROR #388: OMSETRENDERTARGETS_INVALIDVIEW] &emsp;&emsp;如果我们确实需要渲染不同的视图，那么需要创建不同的深度模板使用，如上。 &emsp;&emsp;这一篇中，我们主要学习在 D3D11 中实现雾效果。 &emsp;&emsp;首先我们需要模拟雾天气，所以我们修改渲染的背景为淡灰色的雾状，如下： &emsp;&emsp;只需要简单的修改清空渲染时候的背景颜色就可以实现了。之后我们为了表现在近处看的清晰远处模糊的情况，我们先渲染出多个立方体。 12345678910111213141516171819202122232425262728vector&lt;XMMATRIX&gt; worldMatrixList(5);vector&lt;XMFLOAT3&gt; rotateDir(5);for (int i = 0; i &lt; 5; ++i) &#123; worldMatrixList[i] = XMMatrixIdentity() * XMMatrixScaling(0.2f, 0.2f, 0.2f) * XMMatrixTranslation((rand() - rand()) % 2, (rand() - rand()) % 2, (rand() - rand()) % 2); rotateDir[i] = XMFLOAT3((rand() - rand()) % 2 * 0.001f, (rand() - rand()) % 2 * 0.001f, (rand() - rand()) % 2 * 0.001f);&#125;.......for (int i = 0; i &lt; 5; ++i) &#123; worldMatrixList[i] *= XMMatrixRotationX(rotateDir[i].x) * XMMatrixRotationY(rotateDir[i].y) * XMMatrixRotationZ(rotateDir[i].z); matrix3d.world = worldMatrixList[i]; Update3DModelWorld(matrix3d, pMatrixDBuffer3D, &amp;pD3DImmediateContext); DrawModelIndex( cubeVertexNum, pCubeVertexBufferObject, pCubeIndexBufferObject, pMatrixDBuffer3D, pCubeSamplerState, nNumCubeTex, pCubeShaderResourceView, pCubeVertexShader, pCubePixelShader, pCubeInputLayout, pDepthStencilView, pEnableDepthStencilState, &amp;pRenderTargetViewT, &amp;pD3DImmediateContext);&#125; &emsp;&emsp;我们渲染了5个不同位置的立方体，并且他们会随机绕着某一个方向运动，某个状态可能如下： &emsp;&emsp;现在，可以开始实现我们的雾效果了。在全局雾的情况下，我们会清晰的看到距离我们很近的物体，然后随着距离变远，物体会渐渐被雾掩盖，直到看不见。 &emsp;&emsp;首先我们要定义我们从完全看见到完全看不见的范围，写者直接在顶点着色器中进行了定义： 12float fogStart = 1.0f;float fogEnd = 4.0f; &emsp;&emsp;当距离在 0 ~ 1 的范围内我们完全可以看见（小于 0 在摄像机身后），而超过 4 则是完全看不见了。定义了这个之后我们需要物体的坐标和摄像机的坐标： 1234567float4 modelPosition;float4 cameraPosition;modelPosition = mul(input.pos, world);modelPosition = mul(modelPosition, view);cameraPosition = float4(1.0f, 1.0f, -1.0f, 0.0f); &emsp;&emsp;摄像机坐标直接写好（与我们实际上的摄像机坐标一致，实际上最好用 buffer 传进来），物体坐标则使用 wv 矩阵来计算。有了这个之后，我们可以计算摄像机到物体这一点的距离： 12float distToEye;distToEye = length(cameraPosition - modelPosition); &emsp;&emsp;现在，我们可以在传入像素着色器的结构体中添加一个元素： 12345struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD0; float fogFactor : FOG;&#125;; &emsp;&emsp;并且计算他的值： 1output.fogFactor = saturate((distToEye - fogStart) / (fogEnd - fogStart)); &emsp;&emsp;这个值我们可以称之为雾权重，这个值越大说明物体距离摄像机越远，那么它的颜色越贴近于雾的颜色（即看起来越模糊）。需要注意的是，这应该是一个在 0 ~ 1 之间的数字，我们要用它来插值。所以使用 saturate 来限定范围。 &emsp;&emsp;在像素着色器中，则是简单的混合雾颜色和纹理颜色： 123456float4 main(pixelInputType input) : SV_TARGET &#123; float4 fogColor = float4(0.5f, 0.5f, 0.5f, 1.0f); float4 texColor = tex[0].Sample(samp, input.texcoord); return fogColor * input.fogFactor + texColor * (1 - input.fogFactor);&#125; &emsp;&emsp;最终的效果应该如下： &emsp;&emsp;可以看到，我们的五个 Cube ，有一个已经完全被雾掩盖了，剩下的也都有了或多或少的模糊。距离我们越远的越模糊。 &emsp;&emsp;源代码：DX11Tutorial-FogEffect]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rotate-String]]></title>
    <url>%2F2018%2F04%2F10%2FRotate-String%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#796 Rotate String 题目描述&emsp;&emsp;We are given two strings, A and B. &emsp;&emsp;A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = &#39;abcde&#39;, then it will be &#39;bcdea&#39; after one shift on A. Return True if and only if A can become B after some number of shifts on A. 1234567Example 1:Input: A = &apos;abcde&apos;, B = &apos;cdeab&apos;Output: trueExample 2:Input: A = &apos;abcde&apos;, B = &apos;abced&apos;Output: false Note: A and B will have length at most 100. 解题思路&emsp;&emsp;题目要求我们判断字符串 B 是不是 字符串 A 的 Rotate String 。它的定义是将字符串左边的一部分移到右边组成新的字符串，例如：&#39;ABCDEF&#39; 我们将 AB 移到右边之后为 CDEFAB 。也就是说，字符串 B 如果是由字符串 A 的前半部（顺序不能变）移到后边而来，那么就满足要求。依此，我们可以想到，我们将两个 A 字符串连接在一起成为一个新的串 C ，即 ABCDEFABCDEF ，那么满足要求的串 B 自然属于这个 C 串的子串（因为 C 串中间部分既包含了 A 的后半部也包含了 A 的前半部）。 解题代码123456class Solution &#123;public: bool rotateString(string A, string B) &#123; return (A.length() == B.length()) &amp;&amp; ((A + A).find(B) != string::npos); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】26-渲染到纹理]]></title>
    <url>%2F2018%2F04%2F09%2F%E3%80%90DirectX%E3%80%9126-%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 22: Render to Texture 学习记录&emsp;&emsp;在 OpenGL 中我们介绍过帧缓冲：【OpenGL】17-帧缓冲与离屏渲染 ，这篇文章中我们主要介绍在 DX11 中实现离屏渲染。 &emsp;&emsp;这篇文章的内容比较简单，我们会首先渲染一张长宽为 200 的纹理，然后使用这张纹理来为我们的立方体贴图。 &emsp;&emsp;首先我们需要创建新的贴图，以及相应视图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748HRESULT InitTextureResourceView( const INT width , const INT height , ID3D11Device *pDevice, ID3D11Texture2D **pTexure2D , ID3D11RenderTargetView **pRenderTargetView , ID3D11ShaderResourceView ** pShaderResourceView) &#123; HRESULT hr; D3D11_TEXTURE2D_DESC td; ZeroMemory(&amp;td, sizeof(td)); td.Width = width; td.Height = height; td.MipLevels = 1; td.ArraySize = 1; td.Format = DXGI_FORMAT_R32G32B32A32_FLOAT; td.SampleDesc.Count = 1; td.Usage = D3D11_USAGE_DEFAULT; td.BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE; hr = pDevice-&gt;CreateTexture2D(&amp;td, nullptr, pTexure2D); if (FAILED(hr)) &#123; return hr; &#125; D3D11_RENDER_TARGET_VIEW_DESC rd; ZeroMemory(&amp;rd, sizeof(rd)); rd.Format = td.Format; rd.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D; rd.Texture2D.MipSlice = 0; hr = pDevice-&gt;CreateRenderTargetView(*pTexure2D, &amp;rd, pRenderTargetView); if (FAILED(hr)) &#123; return hr; &#125; D3D11_SHADER_RESOURCE_VIEW_DESC sd; ZeroMemory(&amp;sd, sizeof(sd)); sd.Format = td.Format; sd.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D; sd.Texture2D.MipLevels = 1; hr = pDevice-&gt;CreateShaderResourceView(*pTexure2D, &amp;sd, &amp;pShaderResourceView[0]); if (FAILED(hr)) &#123; return hr; &#125; return S_OK;&#125; &emsp;&emsp;之后，我们在 main 方法里创建不同的 viewport ,分别用于渲染纹理和渲染屏幕： 123456789101112131415D3D11_VIEWPORT dv1;dv1.Width = width;dv1.Height = height;dv1.TopLeftX = 0;dv1.TopLeftY = 0;dv1.MinDepth = 0;dv1.MaxDepth = 1;D3D11_VIEWPORT dv2;dv2.Width = 200;dv2.Height = 200;dv2.TopLeftX = 0;dv2.TopLeftY = 0;dv2.MinDepth = 0;dv2.MaxDepth = 1; &emsp;&emsp;声明并初始化我们的纹理及其资源等（调用刚才的方法）： 1234567891011121314ID3D11ShaderResourceView *pShaderResourceViewT[nNumCubeTex];ID3D11RenderTargetView *pRenderTargetViewT = nullptr;ID3D11Texture2D *pTexure2DT = nullptr;hr = InitTextureResourceView( 200, 200, pD3DDevice, &amp;pTexure2DT, &amp;pRenderTargetViewT, pShaderResourceViewT);if (FAILED(hr)) &#123; return hr;&#125; &emsp;&emsp;此时，我们为要渲染的纹理创建一个新的投影矩阵（因为直接用之前的有点丑。。。），如下： 123456789const MatrixXD matrixTex = &#123;XMMatrixIdentity() * XMMatrixScaling(3.0f , 3.0f , 3.0f) ,XMMatrixLookAtLH( XMVectorSet(0.0f, 0.0f , -4.0f , 0.0f), XMVectorSet(0.0f, 0.0f , 0.0f , 0.0f), XMVectorSet(0.0f, 1.0f , 0.0f , 0.0f)),XMMatrixPerspectiveFovLH(90 , 1.0f , snear , sfar)&#125;; &emsp;&emsp;如果你要渲染静态的二维目标，可以使用正交矩阵并且在帧循环前就可以绘制完毕，如果你的纹理是动态的，那么就要在每一帧里运行了。 &emsp;&emsp;我们在主循环里加入每一帧的清空以及对应渲染： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364pD3DImmediateContext-&gt;ClearRenderTargetView(pD3DRenderTargetView, backgroundColor1); // blackpD3DImmediateContext-&gt;ClearRenderTargetView(pRenderTargetViewT, backgroundColor2); // greenpD3DImmediateContext-&gt;ClearDepthStencilView(pDepthStencilView, D3D11_CLEAR_DEPTH, 1.0f, 0);pD3DImmediateContext-&gt;RSSetViewports(1, &amp;dv2);Update3DModelWorld(matrixTex, pMatrixDBuffer3D, &amp;pD3DImmediateContext);DrawModelIndex( cubeVertexNum, pCubeVertexBufferObject, pCubeIndexBufferObject, pMatrixDBuffer3D, pCubeSamplerState, nNumCubeTex , pCubeShaderResourceView, // 使用 cube 渲染的视图 pCubeVertexShader, pCubePixelShader, pCubeInputLayout, pDepthStencilView, pEnableDepthStencilState, &amp;pRenderTargetViewT, // 渲染到纹理的 target &amp;pD3DImmediateContext);pD3DImmediateContext-&gt;RSSetViewports(1, &amp;dv1);matrix3d.world *= XMMatrixRotationY(0.0001);Update3DModelWorld(matrix3d, pMatrixDBuffer3D, &amp;pD3DImmediateContext);DrawModelIndex( cubeVertexNum, pCubeVertexBufferObject, pCubeIndexBufferObject, pMatrixDBuffer3D, pCubeSamplerState, nNumCubeTex , pShaderResourceViewT, // 使用我们选然后的纹理视图 pCubeVertexShader, pCubePixelShader, pCubeInputLayout, pDepthStencilView, pEnableDepthStencilState, &amp;pD3DRenderTargetView, // 渲染到屏幕 &amp;pD3DImmediateContext);UpdateSentenceVertexAndIndexBuffer( (fpsText + to_string(GetFPS(startTime, fps, tCount)) + cpuText + to_string(GetCPUUsage(canSample, cpuUsage, lastSampleTime, hQuery, hCounter))).c_str(), -width / 2 + offsetX, height / 2 - offsetY, fonts, &amp;pFontVertexBufferObject, &amp;pFontIndexBufferObject, &amp;pD3DImmediateContext, sentenceVertexNum, fontVertice, fontIndices);DrawModelIndex( sentenceVertexNum, pFontVertexBufferObject, pFontIndexBufferObject, pMatrixDBuffer2D, pFontSamplerState, nNumFontTex , pFontShaderResourceView, pFontVertexShader, pFontPixelShader, pFontInputLayout, pDepthStencilView, pDisableDepthStencilState, &amp;pD3DRenderTargetView, &amp;pD3DImmediateContext);pD3DSwapChain-&gt;Present(0, 0); &emsp;&emsp;这一大段代码需要注意的地方也就是我注释出来的部分，可以看到我们首先为纹理渲染，然后用这张纹理去贴图我们的立方体，同时我们为两个渲染目标使用了不同的背景颜色来重置。 &emsp;&emsp;最终效果如下： &emsp;&emsp;源代码：DX11Tutorial-RenderToTexture]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】25-镜面贴图]]></title>
    <url>%2F2018%2F04%2F08%2F%E3%80%90DirectX%E3%80%9125-%E9%95%9C%E9%9D%A2%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 21: Specular Mapping 学习记录&emsp;&emsp;这篇文章中，我们将基于上一篇的内容加一点扩展，为凹凸贴图实现的效果再加上镜面反射。关于镜面反射在 OpenGL 学习笔记中有介绍过：【OpenGL】11-光照 。这一篇文章则是简单的介绍在使用贴图的情况下实现。 &emsp;&emsp;这一篇内容比较少，因为我们只需要更改着色器代码就可以了。首先我们更新一下我们的贴图。这一次将使用新的图片（在文末的源代码链接可以找到）。 &emsp;&emsp;在这里我们只需要对着色器代码进行修改，首先在顶点着色器中我们需要一个摄像机坐标，这里我们直接在着色器里写入我们当前的摄像机位置： 1float3 cameraPos = float3(1.0f, 1.0f, -1.0f); &emsp;&emsp;同时我们需要得到与世界变换矩阵变换后的坐标： 12float4 worldPosition;worldPosition = mul(input.pos, world); &emsp;&emsp;我们在 pixelInputType 结构体里也新增了视野方向变量 ，并且在顶点着色器里进行计算，传给像素着色器： 123worldPosition = mul(input.pos, world);output.viewDir = cameraPos - output.pos.xyz;output.viewDir = normalize(output.viewDir); &emsp;&emsp;顶点着色器的完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950cbuffer ConstantBuffer : register(b0) &#123; matrix world; matrix view; matrix projection;&#125;struct vertexInputType &#123; float4 pos : POSITION; float2 texcoord : TEXCOORD; float3 normal : NORMAL; float3 tangent : TANGENT; float3 bitangent : BITANGENT;&#125;;struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD0; float3 normal : NORMAL; float3 tangent : TANGENT; float3 bitangent : BITANGENT; float3 viewDir : TEXCOORD1;&#125;;pixelInputType main( vertexInputType input )&#123; pixelInputType output; float4 worldPosition; float3 cameraPos = float3(1.0f, 1.0f, -1.0f); output.pos = input.pos; output.pos = mul(output.pos, world); output.pos = mul(output.pos, view); output.pos = mul(output.pos, projection); output.texcoord = input.texcoord; output.normal = mul(input.normal, (float3x3)world); output.normal = normalize(output.normal); output.tangent = mul(input.tangent, (float3x3)world); output.tangent = normalize(output.tangent); output.bitangent = mul(input.bitangent, (float3x3)world); output.bitangent = normalize(output.bitangent); worldPosition = mul(worldPosition, world); output.viewDir = cameraPos - output.pos.xyz; output.viewDir = normalize(output.viewDir); return output;&#125; &emsp;&emsp;在片段着色器里，我们为了更好的显示效果，将光源方向修改了一下，变成了正对 z 轴，它的反方向就成了正对 z 负轴。 12lightDir = normalize(float3(0.0f, 0.0f, 1.0f));lightDir = -lightDir; &emsp;&emsp;片段着色前前边的代码与上一篇一样，而当法线与光照反向量的点乘大于 0 的时候，即光能照到的时候，我们开始计算镜面反射。 12345if (lightIntensity &gt; 0.0f) &#123; reflection = normalize(2 * lightIntensity * bumpNormal - float4(lightDir, 1.0f)); specular = pow(saturate(dot(reflection, input.viewDir)), specularPower); specular = specularIntensity * specular;&#125; &emsp;&emsp;最后将颜色混合。 1return saturate(color + specular); &emsp;&emsp;像素着色器的完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Texture2D tex[3];SamplerState samp;struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD; float3 normal : NORMAL; float3 tangent : TANGENT; float3 bitangent : BITANGENT; float3 viewDir : TEXCOORD1;&#125;;float4 main(pixelInputType input) : SV_TARGET &#123; float4 texColor; float4 bumpMap; float4 specularIntensity; float3 lightDir; float3 bumpNormal; float lightIntensity; float4 color; float3 reflection; float4 specularPower = 16; float4 specular; texColor = tex[0].Sample(samp, input.texcoord); bumpMap = tex[1].Sample(samp, input.texcoord); specularIntensity = tex[2].Sample(samp, input.texcoord); lightDir = normalize(float3(0.0f, 0.0f, 1.0f)); lightDir = -lightDir; bumpMap = bumpMap * 2.0f - 1.0f; bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.bitangent) + (bumpMap.z * input.normal); bumpNormal = normalize(bumpNormal); lightIntensity = saturate(dot(bumpNormal , lightDir)); color = lightIntensity * float4(1.0f, 1.0f, 1.0f, 1.0f); color = color * texColor; if (lightIntensity &gt; 0.0f) &#123; reflection = normalize(2 * lightIntensity * bumpNormal - float4(lightDir, 1.0f)); specular = pow(saturate(dot(reflection, input.viewDir)), specularPower); specular = specularIntensity * specular; &#125; return saturate(color + specular);&#125; &emsp;&emsp;最终效果如下： &emsp;&emsp;这个效果很明显了吧。 &emsp;&emsp;源代码：DX11Tutorial-SpecularMapping]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenCV_初识】环境配置]]></title>
    <url>%2F2018%2F04%2F08%2F%E3%80%90OpenCV-%E5%88%9D%E8%AF%86%E3%80%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;心里没有 AC 数的我，又要开始开新坑了。这一系列文章的坑是为了学习 OpenCV 而开。 &emsp;&emsp;本篇文章介绍了在 Mac 环境下 OpenCV + CLion 的配置。 &emsp;&emsp;其实很简单，因为有 brew 的缘故，只需要简单的一条命令就可以了。 1brew install opencv &emsp;&emsp;之后，你可以喝杯茶冷静一下，等待它安装结束。安装结束后 opencv 的 include 和 lib 文件夹会分别在 /usr/local/Cellar/opencv/x.x.x_x/include 和 /usr/local/Cellar/opencv/x.x.x_x/lib，可以在 Clion 项目里添加头文件和库的依赖，如下： 12345678910111213cmake_minimum_required(VERSION 3.10)project(OpenCVDemo1_OpenImage)set(CMAKE_CXX_STANDARD 11)include_directories(/usr/local/Cellar/opencv/3.4.1_2/include)add_executable(OpenCVDemo1_OpenImage main.cpp)target_link_libraries(OpenCVDemo1_OpenImage /usr/local/Cellar/opencv/3.4.1_2/lib/libopencv_core.dylib)target_link_libraries(OpenCVDemo1_OpenImage /usr/local/Cellar/opencv/3.4.1_2/lib/libopencv_imgproc.dylib)target_link_libraries(OpenCVDemo1_OpenImage /usr/local/Cellar/opencv/3.4.1_2/lib/libopencv_highgui.dylib)target_link_libraries(OpenCVDemo1_OpenImage /usr/local/Cellar/opencv/3.4.1_2/lib/libopencv_imgcodecs.dylib) &emsp;&emsp;之后，就可以写代码了。下边有一份测试代码： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char *argv[]) &#123; Mat im(300 , 300 , CV_8UC1); if (im.empty()) &#123; cout &lt;&lt; "Can not create the image" &lt;&lt; endl; return -1; &#125; imshow("CV", im); waitKey(0);&#125; &emsp;&emsp;简单介绍下这几行代码： &emsp;&emsp;Mat im(300 , 300 , CV_8UC1) 创建了一个长宽 300，单通道分量的图片。（关于图片可能会在下篇介绍，暂时知道是创建图片就好） &emsp;&emsp;imshow(&quot;CV&quot; , im) 则是创建了一个窗口来显示图片，由于我们的图片比较简单，所以运行后就是一个简单的黑色窗口。]]></content>
      <tags>
        <tag>OpenCV</tag>
        <tag>Computer vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】24-法线贴图]]></title>
    <url>%2F2018%2F04%2F08%2F%E3%80%90DirectX%E3%80%9124-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 20: Bump Mapping 学习记录&emsp;&emsp;这篇文章中，我们将介绍使用纹理的法线贴图来实现感官上的凹凸效果。在之前我们的文章中我们使用一张纹理图片实现墙壁的纹理效果，但是在光照下因为纹理在一个平面的原因，法线总是向着一个方向。所以总是没有真实感，而这篇文章中我们用一张和纹理对应的法线图片进行贴图来增强真实感。 &emsp;&emsp;我们的源纹理如下： &emsp;&emsp;法线纹理如下： &emsp;&emsp;法线贴图其实就是将纹理上位置对应的法线存入纹理中，我们可以直接在 pixel 着色器中计算出像素点对应的法线从而避免了使用插值法得到的所有法线共向的问题。 &emsp;&emsp;在实现之前，或许需要了解以下内容：切线空间，切线副切线的计算（这些内容可能会找个时间去专门介绍也可能不会=。=） &emsp;&emsp;首先我们给顶点结构体中添加了三个属性： 123XMFLOAT3 nor;XMFLOAT3 tgt;XMFLOAT3 bit; &emsp;&emsp;分别为法线，切线，副切线。这三个属性可以通过计算得到也可以直接给定（一般的模型会有这些属性），在这里我们试着使用顶点数据进行计算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657inline HRESULT CalculateTangentAndBiTangent(Vertex *&amp;vertices, UINT *&amp;indices, const UINT nNumIndices) &#123; const UINT faceCount = nNumIndices / 3; FLOAT edge1[3], edge2[3]; FLOAT tuVector[2], tvVector[2]; XMFLOAT3 tangent, bitangent, normal; FLOAT f, l; for (UINT i = 0; i &lt; faceCount; ++i) &#123; Vertex&amp; v1 = vertices[indices[3 * i]]; Vertex&amp; v2 = vertices[indices[3 * i + 1]]; Vertex&amp; v3 = vertices[indices[3 * i + 2]]; /////////////////////////////////////////////// Edge edge1[0] = v2.pos.x - v1.pos.x; edge1[1] = v2.pos.y - v1.pos.y; edge1[2] = v2.pos.z - v1.pos.z; edge2[0] = v3.pos.x - v1.pos.x; edge2[1] = v3.pos.y - v1.pos.y; edge2[2] = v3.pos.z - v1.pos.z; /////////////////////////////////////////////// UV tuVector[0] = v2.tex.x - v1.tex.x; tvVector[0] = v2.tex.y - v1.tex.y; tuVector[1] = v3.tex.x - v1.tex.x; tvVector[1] = v3.tex.y - v1.tex.y; /////////////////////////////////////////////// f f = 1.0f / (tuVector[0] * tvVector[1] - tuVector[1] * tvVector[0]); /////////////////////////////////////////////// tangent tangent.x = (tvVector[1] * edge1[0] - tvVector[0] * edge2[0]) * f; tangent.y = (tvVector[1] * edge1[1] - tvVector[0] * edge2[1]) * f; tangent.z = (tvVector[1] * edge1[2] - tvVector[0] * edge2[2]) * f; l = sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z); tangent.x /= l; tangent.y /= l; tangent.z /= l; v1.tgt = v2.tgt = v3.tgt = XMFLOAT3(tangent.x, tangent.y, tangent.z); ///////////////////////////////////////////////// bitangent bitangent.x = (tuVector[0] * edge2[0] - tuVector[1] * edge1[0]) * f; bitangent.y = (tuVector[0] * edge2[1] - tuVector[1] * edge1[1]) * f; bitangent.z = (tuVector[0] * edge2[2] - tuVector[1] * edge1[2]) * f; l = sqrt(bitangent.x * bitangent.x + bitangent.y * bitangent.y + bitangent.z * bitangent.z); bitangent.x /= l; bitangent.y /= l; bitangent.z /= l; v1.bit = v2.bit = v3.bit = XMFLOAT3(bitangent.x, bitangent.y, bitangent.z); ////////////////////////////////////////////////// normal normal.x = tangent.y * bitangent.z - tangent.z * bitangent.y; normal.y = tangent.z * bitangent.x - tangent.x * bitangent.z; normal.z = tangent.x * bitangent.y - tangent.y * bitangent.x; l = sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z); normal.x /= l; normal.y /= l; normal.z /= l; v1.nor = v2.nor = v3.nor = XMFLOAT3(normal.x, normal.y, normal.z); &#125; return S_OK;&#125; &emsp;&emsp;我们在 InitCubeVertexAndIndexBuffer 里写入定点数据和索引数据后调用这个方法。 &emsp;&emsp;同时，我们的顶点格式变了，所以 InputLayout 也要改变： 12345678910111213141516171819202122232425D3D11_INPUT_ELEMENT_DESC layout[5];ZeroMemory(&amp;layout[0], sizeof(layout[0]));layout[0].SemanticName = "POSITION";layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;ZeroMemory(&amp;layout[1], sizeof(layout[1]));layout[1].SemanticName = "TEXCOORD";layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;ZeroMemory(&amp;layout[2], sizeof(layout[2]));layout[2].SemanticName = "NORMAL";layout[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;ZeroMemory(&amp;layout[3], sizeof(layout[3]));layout[3].SemanticName = "TANGENT";layout[3].Format = DXGI_FORMAT_R32G32B32_FLOAT;layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;ZeroMemory(&amp;layout[4], sizeof(layout[4]));layout[4].SemanticName = "BITANGENT";layout[4].Format = DXGI_FORMAT_R32G32B32_FLOAT;layout[4].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;layout[4].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; &emsp;&emsp;我们现在有五个属性，在着色器里也需要变化： 123456789101112131415struct vertexInputType &#123; float4 pos : POSITION; float2 texcoord : TEXCOORD; float3 normal : NORMAL; float3 tangent : TANGENT; float3 bitangent : BITANGENT;&#125;;struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD; float3 normal : NORMAL; float3 tangent : TANGENT; float3 bitangent : BITANGENT;&#125;; &emsp;&emsp;在顶点着色器里我们对法线这些数据进行处理： 12345678910111213141516171819202122pixelInputType main( vertexInputType input )&#123; pixelInputType output; output.pos = input.pos; output.pos = mul(output.pos, world); output.pos = mul(output.pos, view); output.pos = mul(output.pos, projection); output.texcoord = input.texcoord; output.normal = mul(normalize(input.normal), (float)world); output.normal = normalize(output.normal); output.tangent = mul(normalize(input.tangent), (float)world); output.tangent = normalize(output.tangent); output.bitangent = mul(normalize(input.bitangent), (float)world); output.bitangent = normalize(output.bitangent); return output;&#125; &emsp;&emsp;片段着色器里我们对法线贴图进行计算 bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal); ，这将是我们计算凹凸法线的公式。然后我们会用这个法线去和光照做计算。 1234567891011121314151617181920212223242526272829Texture2D tex[2];SamplerState samp;struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD; float3 normal : NORMAL; float3 tangent : TANGENT; float3 bitangent : BITANGENT;&#125;;float4 main(pixelInputType input) : SV_TARGET&#123; float3 lightDir; float4 bumpMap; float4 texColor; float3 bumpNormal; float color; lightDir = float3(-1.0f, -1.0f, 1.0f); bumpMap = tex[1].Sample(samp, input.texcoord); bumpMap = bumpMap * 2.0f - 1.0f; bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.bitangent) + (bumpMap.z * input.normal); bumpNormal = normalize(bumpNormal); color = saturate(dot(bumpNormal , -lightDir)); texColor = tex[0].Sample(samp, input.texcoord); return color * float4(1.0f,1.0f,1.0f,1.0f) * texColor;&#125; &emsp;&emsp;lightDir 是我们的光照方向，bumpNormal 则是我们计算出来的凹凸法线，使用它来进行光照计算后，效果如下： &emsp;&emsp;可以看到，比起直接使用插值法得到的数据法线计算光照，使用法线贴图后我们的纹理多了一些细节，更加具有真实感。 &emsp;&emsp;源代码：DX11Tutorial-BumpMapping]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Insert-Interval]]></title>
    <url>%2F2018%2F04%2F08%2FInsert-Interval%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#57 插入区间 题目描述&emsp;&emsp;给出一个无重叠的按照区间起始端点排序的区间列表。 &emsp;&emsp;在列表中插入一个新的区间，你要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1:给定区间 [1,3],[6,9]，插入并合并 [2,5] 得到 [1,5],[6,9]. 示例 2:给定区间 [1,2],[3,5],[6,7],[8,10],[12,16]，插入并合并 [4,9] 得到 [1,2],[3,10],[12,16]. 这是因为新的区间 [4,9] 与 [3,5],[6,7],[8,10] 重叠。 解题思路&emsp;&emsp;题目要求插入一个区间并且合并因为插入导致所有的重叠区间。由于题目给定的区间数组本身是不重叠的，所以计算起来比较简单，我们通过遍历找到第一个和最后一个与要插入区间重叠的区间，然后将他们合并。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt; &amp;intervals, Interval newInterval) &#123; // 原数组为空 if (intervals.empty()) &#123; return vector&lt;Interval&gt;&#123;newInterval&#125;; &#125; // 新的区间在最前 if (newInterval.end &lt; intervals.front().start) &#123; vector&lt;Interval&gt; ret = intervals; ret.insert(ret.begin(), newInterval); return ret; &#125; // 在最后 if (newInterval.start &gt; intervals.back().end) &#123; vector&lt;Interval&gt; ret = intervals; ret.push_back(newInterval); return ret; &#125; int start = 0, end = 0; vector&lt;Interval&gt; ret(0); bool f = false; for (int i = 0; i &lt; intervals.size(); ++i) &#123; if (!f &amp;&amp; intervals[i].end &gt;= newInterval.start) &#123; start = min(intervals[i].start, newInterval.start); for (int j = i; j &lt; intervals.size(); ++j) &#123; if (intervals[j].start &gt; newInterval.end) break; ++i; &#125; end = max(intervals[--i].end, newInterval.end); ret.emplace_back(start, end); f = true; &#125; else &#123; ret.push_back(intervals[i]); &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并区间]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#56 合并区间 题目描述&emsp;&emsp;给出一个区间的集合, 请合并所有重叠的区间。 示例：给出 [1,3],[2,6],[8,10],[15,18],返回 [1,6],[8,10],[15,18]. 解题思路&emsp;&emsp;判断 b 区间是否重叠 a 需要判断 b.start &lt; a.end 。更新合并后的区间为 a.end = max(a.end , b.end)。 解题代码12345678910111213141516171819202122232425/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; if (intervals.size() &lt;= 1) return intervals; sort(intervals.begin() , intervals.end() , [](Interval &amp;a , Interval &amp;b)&#123; return a.start &lt; b.start; &#125;); vector&lt;Interval&gt; ret(0); ret.push_back(intervals[0]); for (auto &amp;interval : intervals)&#123; if (interval.start &gt; ret.back().end) ret.push_back(interval); else ret.back().end = max(ret.back().end , interval.end); &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】23-使用贴图实现特殊效果]]></title>
    <url>%2F2018%2F04%2F06%2F%E3%80%90DirectX%E3%80%9123-%E4%BD%BF%E7%94%A8%E8%B4%B4%E5%9B%BE%E5%AE%9E%E7%8E%B0%E7%89%B9%E6%AE%8A%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 18: Light Maps Tutorial 19: Alpha Mapping 学习记录&emsp;&emsp;这篇文章主要会介绍使用多重贴图来实现的一些有趣的效果，包括使用光照纹理和透明纹理。 &emsp;&emsp;第一个需要介绍的是 Light Maps ，它使得我们可以在某些情况下使用及其少的资源实现光照效果。其实介绍起来也很简单，就是使用一张渐变的黑白纹理来和我们的基础纹理混合，达到类似于光照的效果，渐变纹理如下： &emsp;&emsp;我们使用它来取代上一篇中完全不搭的那张纹理，同时修改像素着色器。 1234567891011Texture2D tex[2];SamplerState samp;struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD0;&#125;;float4 main(pixelInputType input) : SV_TARGET&#123; return tex[0].Sample(samp, input.texcoord) * (tex[1].Sample(samp, input.texcoord) + 0.1f);&#125; &emsp;&emsp;简单的对其相乘，可以达到光照的效果，如下： &emsp;&emsp;第二个要介绍的是 Alpha Mapping。这个则是使用一张透明贴图，来对另外两张图片进行混合。首先列出我们的贴图： &emsp;&emsp;分别将他们命名为 texture3.gif , texture4.gif , texture5.gif ，同时扩充我们的纹理数组： 12345678const char * cubeTexs[] = &#123; "texture1.jpg", "texture2.gif", "texture3.gif", "texture4.gif", "texture5.gif" &#125;;const int nNumCubeTex = 5; &emsp;&emsp;最后，修改像素着色器： 123456789101112131415Texture2D tex[5];SamplerState samp;struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD0;&#125;;float4 main(pixelInputType input) : SV_TARGET&#123; //return tex[0].Sample(samp, input.texcoord) * (tex[1].Sample(samp, input.texcoord) + 0.1f); float4 alpha = tex[2].Sample(samp, input.texcoord); return tex[3].Sample(samp, input.texcoord) * alpha + tex[4].Sample(samp, input.texcoord) * (1-alpha);&#125; &emsp;&emsp;效果如下： &emsp;&emsp;源代码：DX11Tutorial-TextureMaps]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】22-多重纹理]]></title>
    <url>%2F2018%2F04%2F06%2F%E3%80%90DirectX%E3%80%9122-%E5%A4%9A%E9%87%8D%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 17: Multitexturing and Texture Arrays 学习记录&emsp;&emsp;这一篇相比之前的花了两天来写的视锥裁剪就显得简单的多了。我们在很久之前就学会了使用纹理，但每次都是单一的为一个模型贴上一张。而这篇文章中我们将对之前的代码修改以两张纹理贴图一个立方体。 &emsp;&emsp;首先我们创建我们的纹理文件名数组： 123456789const char * cubeTexs[] = &#123; "texture1.jpg", "texture2.jpg"&#125;;const int nNumCubeTex = 2;const char * fontTexs[] = &#123; "font.dds"&#125;;const int nNumFontTex = 1; &emsp;&emsp;之后更改我们的 ID3D11ShaderResourceView 为数组： 12ID3D11ShaderResourceView *pCubeShaderResourceView[nNumCubeTex];ID3D11ShaderResourceView *pFontShaderResourceView[nNumFontTex]; &emsp;&emsp;接下来更改 InitShader 方法，将其改为支持多重纹理（其实也就是改成循环创建）： 1234567891011121314151617181920212223242526inline HRESULT InitShader( const char * vertexShaderName, const char * pixelShaderName, const char * texFileName[], const int nNumTex , ID3D11Device *pDevice, ID3D11VertexShader **pVertexShader, ID3D11PixelShader **pPixelShader, ID3D11InputLayout **pInputLayout, ID3D11SamplerState **pSamplerState, ID3D11ShaderResourceView **pShaderResourceView) &#123; ....... for (int i = 0 ; i &lt; nNumTex ; ++i) &#123; hr = D3DX11CreateShaderResourceViewFromFile(pDevice, texFileName[i], nullptr, nullptr, &amp;pShaderResourceView[i], nullptr); if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateShaderResourceView", "Error", MB_OK); return hr; &#125; &#125; ....... return S_OK;&#125; &emsp;&emsp;最后，修改 DrawModelIndex 方法： 123456789101112131415161718192021222324252627282930313233343536inline HRESULT DrawModelIndex( const UINT drawIndexCount, ID3D11Buffer *pVertexBufferObject, ID3D11Buffer *pIndexBufferObject, ID3D11Buffer *pMatrixDBuffer3D, ID3D11SamplerState *pSamplerState, const INT nNumTex , ID3D11ShaderResourceView **pShaderResourceView, ID3D11VertexShader *pVertexShader, ID3D11PixelShader *pPixelShader, ID3D11InputLayout *pInputLayout, ID3D11DepthStencilView *pDepthStencilView, ID3D11DepthStencilState *pDepthStencilState, ID3D11RenderTargetView **pRenderTargetView, ID3D11DeviceContext **pImmediateContext) &#123; UINT stride = sizeof(Vertex); UINT offset = 0; (*pImmediateContext)-&gt;OMSetDepthStencilState(pDepthStencilState, 1); (*pImmediateContext)-&gt;OMSetRenderTargets(1, pRenderTargetView, pDepthStencilView); (*pImmediateContext)-&gt;IASetVertexBuffers(0, 1, &amp;pVertexBufferObject, &amp;stride, &amp;offset); (*pImmediateContext)-&gt;IASetIndexBuffer(pIndexBufferObject, DXGI_FORMAT_R32_UINT, 0); (*pImmediateContext)-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); (*pImmediateContext)-&gt;VSSetConstantBuffers(0, 1, &amp;pMatrixDBuffer3D); (*pImmediateContext)-&gt;VSSetShader(pVertexShader, 0, 0); (*pImmediateContext)-&gt;PSSetShader(pPixelShader, 0, 0); (*pImmediateContext)-&gt;IASetInputLayout(pInputLayout); (*pImmediateContext)-&gt;PSSetShaderResources(0, nNumTex, pShaderResourceView); //here (*pImmediateContext)-&gt;PSSetSamplers(0, 1, &amp;pSamplerState); (*pImmediateContext)-&gt;DrawIndexed(drawIndexCount, 0, 0); return S_OK;&#125; &emsp;&emsp;之前我们使用 (*pImmediateContext)-&gt;PSSetShaderResources(0, nNumTex, pShaderResourceView); 设置纹理资源，方法的第二个参数就是纹理个数，我们一直设置的 1 ，现在将其改为传进来的纹理个数参数就可以了。 &emsp;&emsp;最后来修改着色器，顶点着色器完全不用动，因为我们要用两张纹理贴图立方体模型，所以修改它的像素着色器就可以了。 1234567891011Texture2D tex[2];SamplerState samp;struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD0;&#125;;float4 main(pixelInputType input) : SV_TARGET&#123; return tex[0].Sample(samp, input.texcoord) * 0.5f + tex[1].Sample(samp, input.texcoord) * 0.5;&#125; &emsp;&emsp;在着色器里，我们更改 tex 为数组变量，然后采样两张纹理并简单的平均混合。 &emsp;&emsp;最后我们去从网上再下载一张照片： &emsp;&emsp;加上我们之前的： &emsp;&emsp;将他们分别改名为 texture2.jpg 和 texture1.jpg 。就可以渲染了，效果如下： &emsp;&emsp;实际上，直接的进行平均后的混合并不是一个很好的办法，在后边我们会提到。也可以去网上了解一下 伽马校正（Gamma Correction）。 &emsp;&emsp;源代码：DX11Tutorial-MultitexturingAndTextureArrays]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】21-视锥裁剪]]></title>
    <url>%2F2018%2F04%2F06%2F%E3%80%90DirectX%E3%80%9121-%E8%A7%86%E9%94%A5%E8%A3%81%E5%89%AA%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 16: Frustum Culling 学习记录&emsp;&emsp;在透视投影（3D投影）中，我们所能看到的区域根本上来看很像是一个锥形。如下： &emsp;&emsp;如图，E 是我们的摄像机位置，摄像机所能观察到的角度则是我们的 FOV ，近截面和远截面则是我们最近和最远所能看到的平面。我们的透视投影矩阵便是拿这些数据来构造： 1XMMatrixPerspectiveFovLH( fov , width / height , near , far); &emsp;&emsp;所以我们的可视区域则是这个锥形体的内部部分。在这个视锥之外的物体则不会被渲染，一般情况下我们将所有要渲染的顶点传入 GPU ，GPU将会检查是否可见，如果不可见将会被剔除。但是将这个任务交给 GPU 的话其效率确实很低。假设我们有渲染数千个物体，而只有十几个是可见的，那么我们需要将数千个物体的顶点信息传递给 GPU 并在渲染时判断，这无疑的十分浪费资源的。因此我们需要在传递数据之前进行判断这个模型是否在我们的视锥体之内，如果没有那么干脆不去发送它。 &emsp;&emsp;首先我们在随机位置，绘制了 5000 个立方体： 12345678910111213141516171819MatrixXD matrix3d = &#123; XMMatrixIdentity() , XMMatrixLookAtLH( XMVectorSet(0.0f, 3.0f , -100.0f , 0.0f), XMVectorSet(0.0f, 0.0f , 0.0f , 0.0f), XMVectorSet(0.0f, 1.0f , 0.0f , 0.0f) ), XMMatrixPerspectiveFovLH(90 ,static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height) , 0.01f , 100.0f)&#125;;const UINT nNumWorldList = 5000;auto *worldList = new XMMATRIX[nNumWorldList];for (int i = 0 ; i &lt; nNumWorldList ; i++) &#123; worldList[i] = matrix3d.world; worldList[i] *= XMMatrixTranslation( (static_cast&lt;float&gt;(rand()) - static_cast&lt;float&gt;(rand())) / RAND_MAX * nNumWorldList / 10, (static_cast&lt;float&gt;(rand()) - static_cast&lt;float&gt;(rand())) / RAND_MAX * nNumWorldList / 10, (static_cast&lt;float&gt;(rand()) - static_cast&lt;float&gt;(rand())) / RAND_MAX * nNumWorldList / 10);&#125; &emsp;&emsp;这五千个坐标由 rand 来生成，我们只是保证了它在一个限定的范围内 -nNumWorldList / 10 -&gt;nNumWorldList / 10 。然后在循环里绘制它们： 12345678910111213141516171819for (int i = 0 ; i &lt; nNumWorldList ; ++i) &#123; matrix3d.world = worldList[i]; Update3DModelPos(matrix3d, pMatrixDBuffer3D, &amp;pD3DImmediateContext); DrawModelIndex( // 绘制 cubeVertexNum, pCubeVertexBufferObject, pCubeIndexBufferObject, pMatrixDBuffer3D, pCubeSamplerState, pCubeShaderResourceView, pCubeVertexShader, pCubePixelShader, pCubeInputLayout, pDepthStencilView, pEnableDepthStencilState, &amp;pD3DRenderTargetView, &amp;pD3DImmediateContext);&#125; &emsp;&emsp;效果如下： &emsp;&emsp;屏幕中随机出现了大量的带纹理立方体，这些立方体是在我们视锥之内的，所以可以看到。GPU 替我们剔除了那些我们不会看到的内容。但是我们也可以看到，左上角的 FPS 已经只剩下了三十左右。仅仅是绘制五千个模型已经让我们的帧数接近了崩溃的边缘。如果是五万呢？ &emsp;&emsp;由于模型的位置分布区域与我们的模型个数有关，而我们的可见区域一直那么大，所以现在在我们的可见区域的模型已经没几个了。然而我们的帧数已经变成个位数，这已经没法正常使用了，这还仅仅只是静态物体的绘制。所以在绘制大量物体的时候，对其进行裁剪就是必须的了。 &emsp;&emsp;关于视锥裁剪这是一个很大的话题，它可以只做最简单的判断（视锥裁剪的过程同样耗费资源），也可以去进行优化。在这里我们只做最简单的部分，相当于做个介绍。如果需要知道更多的视锥裁剪内容，请打开谷歌。 &emsp;&emsp;我们对立方体判断视锥的时候，是判断立方体的每一个点是否在视锥体之内，判断点的方法则是判断这个点是否与视锥体的六个面同向。（可以参考我们判断点在三角形内部的方法） &emsp;&emsp;所以可以先计算视锥体的六个面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546inline HRESULT InitFrustumPlane(const FLOAT depth, const MatrixXD &amp;matrix3D , XMVECTOR *&amp;viewPlane) &#123; const XMMATRIX vip = matrix3D.view * matrix3D.projection; if (viewPlane) &#123; delete[] viewPlane; viewPlane = 0; &#125; viewPlane = new XMVECTOR[6]; //near viewPlane[0].m128_f32[0] = vip.r[0].m128_f32[3] + vip.r[0].m128_f32[2]; viewPlane[0].m128_f32[1] = vip.r[1].m128_f32[3] + vip.r[1].m128_f32[2]; viewPlane[0].m128_f32[2] = vip.r[2].m128_f32[3] + vip.r[2].m128_f32[2]; viewPlane[0].m128_f32[3] = vip.r[3].m128_f32[3] + vip.r[3].m128_f32[2]; viewPlane[0] = XMPlaneNormalize(viewPlane[0]); //far viewPlane[1].m128_f32[0] = vip.r[0].m128_f32[3] - vip.r[0].m128_f32[2]; viewPlane[1].m128_f32[1] = vip.r[1].m128_f32[3] - vip.r[1].m128_f32[2]; viewPlane[1].m128_f32[2] = vip.r[2].m128_f32[3] - vip.r[2].m128_f32[2]; viewPlane[1].m128_f32[3] = vip.r[3].m128_f32[3] - vip.r[3].m128_f32[2]; viewPlane[1] = XMPlaneNormalize(viewPlane[1]); //left viewPlane[2].m128_f32[0] = vip.r[0].m128_f32[3] + vip.r[0].m128_f32[0]; viewPlane[2].m128_f32[1] = vip.r[1].m128_f32[3] + vip.r[1].m128_f32[0]; viewPlane[2].m128_f32[2] = vip.r[2].m128_f32[3] + vip.r[2].m128_f32[0]; viewPlane[2].m128_f32[3] = vip.r[3].m128_f32[3] + vip.r[3].m128_f32[0]; viewPlane[2] = XMPlaneNormalize(viewPlane[2]); //right viewPlane[3].m128_f32[0] = vip.r[0].m128_f32[3] - vip.r[0].m128_f32[0]; viewPlane[3].m128_f32[1] = vip.r[1].m128_f32[3] - vip.r[1].m128_f32[0]; viewPlane[3].m128_f32[2] = vip.r[2].m128_f32[3] - vip.r[2].m128_f32[0]; viewPlane[3].m128_f32[3] = vip.r[3].m128_f32[3] - vip.r[3].m128_f32[0]; viewPlane[3] = XMPlaneNormalize(viewPlane[3]); //top viewPlane[4].m128_f32[0] = vip.r[0].m128_f32[3] - vip.r[0].m128_f32[1]; viewPlane[4].m128_f32[1] = vip.r[1].m128_f32[3] - vip.r[1].m128_f32[1]; viewPlane[4].m128_f32[2] = vip.r[2].m128_f32[3] - vip.r[2].m128_f32[1]; viewPlane[4].m128_f32[3] = vip.r[3].m128_f32[3] - vip.r[3].m128_f32[1]; viewPlane[4] = XMPlaneNormalize(viewPlane[4]); //bottom viewPlane[5].m128_f32[0] = vip.r[0].m128_f32[3] + vip.r[0].m128_f32[1]; viewPlane[5].m128_f32[1] = vip.r[1].m128_f32[3] + vip.r[1].m128_f32[1]; viewPlane[5].m128_f32[2] = vip.r[2].m128_f32[3] + vip.r[2].m128_f32[1]; viewPlane[5].m128_f32[3] = vip.r[3].m128_f32[3] + vip.r[3].m128_f32[1]; viewPlane[5] = XMPlaneNormalize(viewPlane[5]); return S_OK;&#125; &emsp;&emsp;当我们需要在 world space 进行裁剪的时候，我们需要的是 vp（view * projection） 矩阵（请注意这个顺序不能反）。这里有关于计算面的一个问题回答：知乎传送门 &emsp;&emsp;有了视锥体的六个面之后，可以进行判断了。 123456789101112131415inline bool CheckCube(XMVECTOR *&amp;viewPlane , const FLOAT centerX , const FLOAT centerY , const FLOAT centerZ , const FLOAT R) &#123; for (int i = 0 ; i &lt; 6 ; ++i) &#123; float dot; XMStoreFloat(&amp;dot,XMPlaneDotCoord(viewPlane[i],XMVectorSet(centerX + R , centerY + R , centerZ + R , 0.0f)));if (dot &gt; 0.0f) continue; XMStoreFloat(&amp;dot,XMPlaneDotCoord(viewPlane[i],XMVectorSet(centerX + R , centerY + R , centerZ - R , 0.0f)));if (dot &gt; 0.0f) continue; XMStoreFloat(&amp;dot,XMPlaneDotCoord(viewPlane[i],XMVectorSet(centerX + R , centerY - R , centerZ + R , 0.0f)));if (dot &gt; 0.0f) continue; XMStoreFloat(&amp;dot,XMPlaneDotCoord(viewPlane[i],XMVectorSet(centerX + R , centerY - R , centerZ - R , 0.0f)));if (dot &gt; 0.0f) continue; XMStoreFloat(&amp;dot,XMPlaneDotCoord(viewPlane[i],XMVectorSet(centerX - R , centerY + R , centerZ + R , 0.0f)));if (dot &gt; 0.0f) continue; XMStoreFloat(&amp;dot,XMPlaneDotCoord(viewPlane[i],XMVectorSet(centerX - R , centerY + R , centerZ - R , 0.0f)));if (dot &gt; 0.0f) continue; XMStoreFloat(&amp;dot,XMPlaneDotCoord(viewPlane[i],XMVectorSet(centerX - R , centerY - R , centerZ + R , 0.0f)));if (dot &gt; 0.0f) continue; XMStoreFloat(&amp;dot,XMPlaneDotCoord(viewPlane[i],XMVectorSet(centerX - R , centerY - R , centerZ - R , 0.0f)));if (dot &gt; 0.0f) continue; return false; &#125; return true;&#125; &emsp;&emsp;在这里我们并没有直接传入立方体的六个点，而是传入了中心点和它的半径（如果是长方体则需要中心点和长，宽，高）。 &emsp;&emsp;有了这两个方法，我们便可以在主函数里调用以在 Draw 之前判断物体是否在视锥体之内来对物体进行相应剔除。同时我们增加了一个计数显示，使得当前视锥体之内立方体数量可以在屏幕上显示出来。如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const FLOAT snear = 0.01f; const FLOAT sfar = 100.0f; MatrixXD matrix3d = &#123; XMMatrixIdentity() , XMMatrixLookAtLH( XMVectorSet(0.0f, 0.0f , -100.0f , 0.0f), XMVectorSet(0.0f, 0.0f , 0.0f , 0.0f), XMVectorSet(0.0f, 1.0f , 0.0f , 0.0f) ), XMMatrixPerspectiveFovLH(90 ,static_cast&lt;float&gt;(width) / static_cast&lt;float&gt;(height) , snear , sfar)&#125;;XMVECTOR *viewPlanes = nullptr;InitFrustumPlane(sfar , matrix3d, viewPlanes);const UINT nNumWorldTranslateList = 5000;auto *worldTranslateList = new XMFLOAT3[nNumWorldTranslateList];auto *worldList = new XMMATRIX[nNumWorldTranslateList];for (int i = 0 ; i &lt; nNumWorldTranslateList ; i++) &#123; worldTranslateList[i] = XMFLOAT3( (static_cast&lt;float&gt;(rand()) - static_cast&lt;float&gt;(rand())) / RAND_MAX * nNumWorldTranslateList / 10, (static_cast&lt;float&gt;(rand()) - static_cast&lt;float&gt;(rand())) / RAND_MAX * nNumWorldTranslateList / 10, (static_cast&lt;float&gt;(rand()) - static_cast&lt;float&gt;(rand())) / RAND_MAX * nNumWorldTranslateList / 10); worldList[i] = XMMatrixIdentity() * XMMatrixTranslation(worldTranslateList[i].x, worldTranslateList[i].y, worldTranslateList[i].z);&#125;......cube = 0;for (int i = 0; i &lt; nNumWorldTranslateList; ++i) &#123; worldTranslateList[i] = XMFLOAT3(worldTranslateList[i].x , worldTranslateList[i].y , worldTranslateList[i].z + 0.03f); worldList[i] *= XMMatrixTranslation(0.0f , 0.0f , 0.03f); if (CheckCube(viewPlanes, worldTranslateList[i].x, worldTranslateList[i].y, worldTranslateList[i].z, 0.5f)) &#123; matrix3d.world = worldList[i]; Update3DModelWorld(matrix3d, pMatrixDBuffer3D, &amp;pD3DImmediateContext); DrawModelIndex( cubeVertexNum, pCubeVertexBufferObject, pCubeIndexBufferObject, pMatrixDBuffer3D, pCubeSamplerState, pCubeShaderResourceView, pCubeVertexShader, pCubePixelShader, pCubeInputLayout, pDepthStencilView, pEnableDepthStencilState, &amp;pD3DRenderTargetView, &amp;pD3DImmediateContext); ++cube; &#125;&#125; &emsp;&emsp;效果如下： &emsp;&emsp;可以看到，左上的计数那里显示我们有一百多个 cube 被渲染，而屏幕上呈现的部分貌似差不多。。。如果你闲的无聊可以去数数。 &emsp;&emsp;源代码：DX11Tutorial-FrustumCulling]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】20-数据更新]]></title>
    <url>%2F2018%2F04%2F04%2F%E3%80%90DirectX%E3%80%9120-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中，我们将介绍一些比较简单的内容，主要是对于之前代码的一些修改。在之前我们的代码中，例如 【directx】18-fps与cpu使用率 这一篇中。由于帧数和 cpu 使用率的数值是不断变化的，所以我们需要实时的生成不一样的顶点数据，这样程序会在每一帧运行的时候去申请一段空间，然后送给 GPU 。虽然我们也自己处理了一部分的内存释放，例如在申请 vertex 数组前先判断数组是否存在，存在的话先去释放它。但是也还是有很大的改进空间，这篇文章主要就是对这个进行更改。 &emsp;&emsp;在此之前，我们对代码结构进行了部分重构处理。虽然没有去和很早之前一样去设计多个类，但是也将我们的部分代码进行了封装。等会你可以在文章下边提供的源代码网址里看到这些。 &emsp;&emsp;然后，在此对于上边提到的改进，这次我们将不再重新去生成顶点缓冲，而是使用 DX 中提供的缓冲更新方法，我们首先初始化我们用来显示文字的顶点，使用的是 InitSentenceVertexAndIndexBuffer 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990inline HRESULT InitSentenceVertexAndIndexBuffer( const char * sentence, const float drawX, const float drawY, Font * fonts, ID3D11Device * const pDevice, ID3D11Buffer **pVertexBufferObject, ID3D11Buffer **pIndexBufferObject, UINT &amp;nNumVertex, Vertex *&amp;vertices, UINT *&amp;indices) &#123; if (vertices) &#123; delete[] vertices; vertices = nullptr; &#125; if (indices) &#123; delete[] indices; indices = nullptr; &#125; HRESULT hr; nNumVertex = strlen(sentence) * 6; vertices = new Vertex[nNumVertex]; int idx = 0; float posX = drawX; const float posY = drawY; for (auto i = 0; i &lt; nNumVertex / 6; ++i) &#123; const Font letter = fonts[static_cast&lt;int&gt;(sentence[i]) - 32]; if (sentence[i] - 32 == 0) &#123; posX += 3; &#125; else &#123; vertices[idx].pos = XMFLOAT3(posX, posY, 0.0f); // 左上 vertices[idx++].tex = XMFLOAT2(letter.left, 0.0f); vertices[idx].pos = XMFLOAT3(posX + letter.size, posY - 16, 0.0f); // 右下 vertices[idx++].tex = XMFLOAT2(letter.right, 1.0f); vertices[idx].pos = XMFLOAT3(posX, posY - 16, 0.0f); // 左下 vertices[idx++].tex = XMFLOAT2(letter.left, 1.0f); vertices[idx].pos = XMFLOAT3(posX, posY, 0.0f); // 左上 vertices[idx++].tex = XMFLOAT2(letter.left, 0.0f); vertices[idx].pos = XMFLOAT3(posX + letter.size, posY, 0.0f); // 右上 vertices[idx++].tex = XMFLOAT2(letter.right, 0.0f); vertices[idx].pos = XMFLOAT3(posX + letter.size, posY - 16, 0.0f); // 右下 vertices[idx++].tex = XMFLOAT2(letter.right, 1.0f); posX += letter.size + 1.0f; &#125; &#125; D3D11_BUFFER_DESC vertexBufferDesc; ZeroMemory(&amp;vertexBufferDesc, sizeof(vertexBufferDesc)); vertexBufferDesc.Usage = D3D11_USAGE_DYNAMIC; vertexBufferDesc.ByteWidth = sizeof(Vertex) * nNumVertex; vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; D3D11_SUBRESOURCE_DATA verticesSourceData; ZeroMemory(&amp;verticesSourceData, sizeof(D3D11_SUBRESOURCE_DATA)); verticesSourceData.pSysMem = vertices; hr = pDevice-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;verticesSourceData, pVertexBufferObject); if (FAILED(hr)) &#123; return hr; &#125; indices = new UINT[nNumVertex]; for (auto i = 0; i &lt; nNumVertex; ++i) indices[i] = i; D3D11_BUFFER_DESC indexDesc; ZeroMemory(&amp;indexDesc, sizeof(indexDesc)); indexDesc.Usage = D3D11_USAGE_DYNAMIC; indexDesc.BindFlags = D3D11_BIND_INDEX_BUFFER; indexDesc.ByteWidth = sizeof(UINT) * nNumVertex; vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; D3D11_SUBRESOURCE_DATA indexData; ZeroMemory(&amp;indexData, sizeof(indexData)); indexData.pSysMem = indices; hr = pDevice-&gt;CreateBuffer(&amp;indexDesc, &amp;indexData, pIndexBufferObject); if (FAILED(hr)) &#123; return hr; &#125; return S_OK;&#125; &emsp;&emsp;还可以看到的是我们在这个方法里没有去定义顶点缓冲和索引缓冲对象。那是因为我们将它转移到了主函数里，使用二级指针传入进来为其赋值，这样可以使得我们的函数尽量的 “干净” 一些，也可以在主函数里统一的声明和释放指针。 &emsp;&emsp;之前我们是频繁的使用这个方法来生成顶点数据，生成顶点缓冲，然后绑定到立即上下文设备对象中，现在我们设计了一个新方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172inline HRESULT UpdateSentenceVertexAndIndexBuffer( const char * sentence, const float drawX, const float drawY, Font * fonts, ID3D11Buffer **pVertexBufferObject, ID3D11Buffer **pIndexBufferObject, ID3D11DeviceContext **pImmediateContext, UINT &amp;nNumVertex, Vertex *&amp;vertices, UINT *&amp;indices) &#123; if (vertices) &#123; delete[] vertices; vertices = nullptr; &#125; if (indices) &#123; delete[] indices; indices = nullptr; &#125; HRESULT hr; nNumVertex = strlen(sentence) * 6; vertices = new Vertex[nNumVertex]; int idx = 0; float posX = drawX; const float posY = drawY; for (auto i = 0; i &lt; nNumVertex / 6; ++i) &#123; const Font letter = fonts[static_cast&lt;int&gt;(sentence[i]) - 32]; if (sentence[i] - 32 == 0) &#123; posX += 3; &#125; else &#123; vertices[idx].pos = XMFLOAT3(posX, posY, 0.0f); // 左上 vertices[idx++].tex = XMFLOAT2(letter.left, 0.0f); vertices[idx].pos = XMFLOAT3(posX + letter.size, posY - 16, 0.0f); // 右下 vertices[idx++].tex = XMFLOAT2(letter.right, 1.0f); vertices[idx].pos = XMFLOAT3(posX, posY - 16, 0.0f); // 左下 vertices[idx++].tex = XMFLOAT2(letter.left, 1.0f); vertices[idx].pos = XMFLOAT3(posX, posY, 0.0f); // 左上 vertices[idx++].tex = XMFLOAT2(letter.left, 0.0f); vertices[idx].pos = XMFLOAT3(posX + letter.size, posY, 0.0f); // 右上 vertices[idx++].tex = XMFLOAT2(letter.right, 0.0f); vertices[idx].pos = XMFLOAT3(posX + letter.size, posY - 16, 0.0f); // 右下 vertices[idx++].tex = XMFLOAT2(letter.right, 1.0f); posX += letter.size + 1.0f; &#125; &#125; indices = new UINT[nNumVertex]; for (auto i = 0; i &lt; nNumVertex; ++i) indices[i] = i; D3D11_MAPPED_SUBRESOURCE dms; hr = (*pImmediateContext)-&gt;Map(*pVertexBufferObject, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;dms); if (FAILED(hr)) &#123; return hr; &#125; auto *vertexPtr = static_cast&lt;Vertex*&gt;(dms.pData); memcpy(vertexPtr, vertices, sizeof(Vertex) * nNumVertex); (*pImmediateContext)-&gt;Unmap(*pVertexBufferObject, 0); hr = (*pImmediateContext)-&gt;Map(*pIndexBufferObject, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;dms); if (FAILED(hr)) &#123; return hr; &#125; auto *indexPtr = static_cast&lt;UINT*&gt;(dms.pData); memcpy(indexPtr, indices, sizeof(UINT) * nNumVertex); (*pImmediateContext)-&gt;Unmap(*pIndexBufferObject, 0); return S_OK;&#125; &emsp;&emsp;事实上，这两个方法虽然一个为初始化一个为更新，但是内部含有大量的重复代码，这仍然是我们可以优化的一部分，在此我们暂且不对它进行修改，因为这个并不是重点。 &emsp;&emsp;可以看到，下边的方法中我们没有去使用顶点创建缓冲，而是使用上下文对象的方法来将缓冲中数据映射到一个指针上，然后通过拷贝将数据拷贝到缓冲里。通过这样我们可以去实时的修改顶点数据。同时还需要注意的地方是，如果我们需要更新数据，那么在初始化顶点缓冲的时候就需要一定的配置更改了，请注意一下我们上边初始化缓冲的代码： 12vertexBufferDesc.Usage = D3D11_USAGE_DYNAMIC;vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; &emsp;&emsp;我们修改了顶点缓冲描述的 Usage 和 CPUAccessFlags 两个值。 &emsp;&emsp;同时正如上边所说，我们将几乎所有的指针对象的声明和释放都放到了主函数里，这样可以避免很多的函数中内存泄漏。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//////////////////////////////////////// declare //////////////////////////////////////ID3D11RenderTargetView *pD3DRenderTargetView = nullptr;ID3D11Device *pD3DDevice = nullptr;ID3D11DeviceContext *pD3DImmediateContext = nullptr;IDXGISwapChain *pD3DSwapChain = nullptr;ID3D11DepthStencilView *pDepthStencilView = nullptr;ID3D11DepthStencilState *pDisableDepthStencilState = nullptr;ID3D11DepthStencilState *pEnableDepthStencilState = nullptr;const UINT cubeVertexNum = 36;ID3D11SamplerState *pCubeSamplerState = nullptr;ID3D11ShaderResourceView *pCubeShaderResourceView = nullptr;ID3D11Buffer *pCubeVertexBufferObject = nullptr;ID3D11Buffer *pCubeIndexBufferObject = nullptr;ID3D11Buffer *pMatrixDBuffer3D = nullptr;ID3D11Buffer *pMatrixDBuffer2D = nullptr;Vertex *cubeVertice = nullptr;UINT *cubeIndices = nullptr;ID3D11VertexShader *pCubeVertexShader = nullptr;ID3D11PixelShader *pCubePixelShader = nullptr;ID3D11InputLayout *pCubeInputLayout = nullptr;UINT sentenceVertexNum = 0;Font *fonts = nullptr;Vertex *fontVertice = nullptr;UINT *fontIndices = nullptr;ID3D11Buffer *pFontVertexBufferObject = nullptr;ID3D11Buffer *pFontIndexBufferObject = nullptr;ID3D11VertexShader *pFontVertexShader = nullptr;ID3D11PixelShader *pFontPixelShader = nullptr;ID3D11InputLayout *pFontInputLayout = nullptr;ID3D11SamplerState *pFontSamplerState = nullptr;ID3D11ShaderResourceView *pFontShaderResourceView = nullptr;//////////////////////////////////////// use ////////////////////////////////////////////////////////////////////////////////////// release /////////////////////////////////////////if (pD3DRenderTargetView) pD3DRenderTargetView-&gt;Release();if (pD3DDevice) pD3DDevice-&gt;Release();if (pD3DImmediateContext) pD3DImmediateContext-&gt;Release();if (pD3DSwapChain) pD3DSwapChain-&gt;Release();if (pDepthStencilView) pDepthStencilView-&gt;Release();if (pDisableDepthStencilState) pDisableDepthStencilState-&gt;Release();if (pEnableDepthStencilState) pEnableDepthStencilState-&gt;Release();if (pCubeSamplerState) pCubeSamplerState-&gt;Release();if (pCubeShaderResourceView) pCubeShaderResourceView-&gt;Release();if (pCubeVertexBufferObject) pCubeVertexBufferObject-&gt;Release();if (pCubeIndexBufferObject) pCubeIndexBufferObject-&gt;Release();if (pMatrixDBuffer3D) pMatrixDBuffer3D-&gt;Release();if (pMatrixDBuffer2D) pMatrixDBuffer2D-&gt;Release();if (pCubeVertexShader) pCubeVertexShader-&gt;Release();if (pCubePixelShader) pCubePixelShader-&gt;Release();if (pCubeInputLayout) pCubeInputLayout-&gt;Release();if (pFontVertexBufferObject) pFontVertexBufferObject-&gt;Release();if (pFontIndexBufferObject) pFontIndexBufferObject-&gt;Release();if (pFontVertexShader) pFontVertexShader-&gt;Release();if (pFontPixelShader) pFontPixelShader-&gt;Release();if (pFontInputLayout) pFontInputLayout-&gt;Release();if (pFontSamplerState) pFontSamplerState-&gt;Release();if (pFontShaderResourceView) pFontShaderResourceView-&gt;Release();delete fonts;delete[] fontVertice;delete[] fontIndices;delete[] cubeVertice;delete[] cubeIndices;PdhCloseQuery(hQuery); &emsp;&emsp;如此，在程序运行起来后，我们的程序内存始终可以保持在一个可观的地步。下一篇中我们将去绘制及其多的 3d 模型并介绍对于 3d 场景下的视锥裁剪问题。这篇文章的代码也是和它在一起的。 &emsp;&emsp;源代码：DX11Tutorial-FrustumCulling]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jump-Game]]></title>
    <url>%2F2018%2F04%2F04%2FJump-Game%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#55 跳跃游戏 题目描述&emsp;&emsp;给定一个非负整数数组，您最初位于数组的第一个索引处。数组中的每个元素表示您在该位置的最大跳跃长度。确定是否能够到达最后一个索引。 示例：A = [2,3,1,1,4]，返回 true。 A = [3,2,1,0,4]，返回 false。 解题思路&emsp;&emsp;要判断在 i 索引处能不能到达 j 的条件是 i + nums[i] &gt;= j 。所以我们可以维护一个能到达最后一个索引且最小的位置 idx 。从后往前遍历，当 i 能够到达 idx 的时候更新 idx 。 解题代码123456789class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int firstIdx = nums.size()-1; for (int i = nums.size()-2; i &gt;= 0; --i) if(i + nums[i] &gt;= firstIdx) firstIdx = i; return firstIdx == 0; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spiral-Matrix]]></title>
    <url>%2F2018%2F04%2F03%2FSpiral-Matrix%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#54 Spiral Matrix 题目描述&emsp;&emsp;给出一个 m x n 的矩阵（m 行, n 列），请按照顺时针螺旋顺序返回元素。 &emsp;&emsp;例如，给出以下矩阵： 12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] &emsp;&emsp;应该返回 [1,2,3,6,9,8,7,4,5]。 解题思路&emsp;&emsp;递归按照每一圈来取值。 解题代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; void spiral(const vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;int&gt; &amp;result, int idx) &#123; int left = idx; int top = idx; int right = matrix[top].size() - 1 - idx; int bottom = matrix.size() - 1 - idx; if (right &lt; left || bottom &lt; top) return; if (right == left &amp;&amp; bottom == top) &#123; result.push_back(matrix[bottom][right]); return; &#125; for (int i = left; i &lt;= right; ++i) &#123; // A -&gt; B result.push_back(matrix[top][i]); &#125; for (int i = top + 1; i &lt;= bottom; ++i) &#123; // B -&gt; C result.push_back(matrix[i][right]); &#125; for (int i = right - 1; i &gt;= left; --i) &#123; // C -&gt; D result.push_back(matrix[bottom][i]); &#125; for (int i = bottom - 1; i &gt; top; --i) &#123; // D -&gt; A result.push_back(matrix[i][left]); &#125; spiral(matrix, result, idx + 1); &#125;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt; &amp;matrix) &#123; vector&lt;int&gt; result(0); if (matrix.empty()) return result; spiral(matrix, result, 0); return result; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】19-DirectSound]]></title>
    <url>%2F2018%2F04%2F03%2F%E3%80%90DirectX%E3%80%9119-DirectSound%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 14: Direct Sound 学习记录&emsp;&emsp;这篇文章中，我们将主要介绍 DX 中的音频输入 DirectSound 。与之前一样，这篇文章主要简单的介绍它的使用流程和完成一个播放的小例子。在此之前，如果对音频格式不太了解的话，可以看这里：维基百科：音频格式 &emsp;&emsp;在使用 DirectSound 之前，需要包含 dsound.h 头文件以及链接 dsound.lib ，dxguid.lib ，winmm.lib 等库，如下： 1234#include &lt;dsound.h&gt;#pragma comment(lib, "dsound.lib")#pragma comment(lib, "dxguid.lib")#pragma comment(lib, "winmm.lib") &emsp;&emsp;我们这篇文章将会播放一个 .wav 格式的语音文件，大致分为以下步骤： 初始化 DirectSound 设备以及主缓冲 DirectSoundBuffer 读取 .wav 文件并校验 使用文件信息配置辅助缓冲 播放 DirectSoundBuffer &emsp;&emsp;来试试看代码吧： 初始化 DirectSound 设备以及主缓冲 DirectSoundBuffer&emsp;&emsp;首先创建 DirectSound 指针变量且设置其属性： 1234567891011IDirectSound8 * pSoundDevice = nullptr;hr = DirectSoundCreate8(nullptr, &amp;pSoundDevice, nullptr);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateSoundDevice", "ERROR", MB_OK); return hr;&#125;hr = pSoundDevice-&gt;SetCooperativeLevel(hWnd, DSSCL_PRIORITY);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::SetCooperativeLevel", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;这个和 DirectInput 还是比较像的。初始化好设备后，我们可以设置缓冲描述，并使用设备创建缓冲： 123456789101112DSBUFFERDESC bd;ZeroMemory(&amp;bd, sizeof(bd));bd.dwSize = sizeof(DSBUFFERDESC);bd.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLVOLUME;bd.guid3DAlgorithm = GUID_NULL;IDirectSoundBuffer *pSoundPrimaryBuffer = nullptr;hr = pSoundDevice-&gt;CreateSoundBuffer(&amp;bd, &amp;pSoundPrimaryBuffer, nullptr);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreatePrimaryBuffer", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;现在，我们可以配置这个缓冲的格式： 1234567891011121314WAVEFORMATEX wf;ZeroMemory(&amp;wf, sizeof(wf));wf.wFormatTag = WAVE_FORMAT_PCM;wf.nSamplesPerSec = 44100;wf.wBitsPerSample = 16;wf.nChannels = 2;wf.nBlockAlign = wf.wBitsPerSample / 8 * wf.nChannels;wf.nAvgBytesPerSec = wf.nSamplesPerSec * wf.nBlockAlign;wf.cbSize = 0;hr = pSoundPrimaryBuffer-&gt;SetFormat(&amp;wf);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::SoundPrimaryBuffer::SetFormat", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;在这里我们创建了 WAV 文件的描述，并且将其设定为缓冲的格式。现在我们的基本缓冲对象就配置完了，用来存储音频信息的辅助缓冲会在读取和校验具体文件后才会进行。 读取 .wav 文件并校验&emsp;&emsp;在读取文件之前，我们需要创建一个音频的文件头结构体，以方便一会从 .wav 文件头中读取数据然后校验： 12345678910111213141516struct WaveHeader&#123; char chunkId[4]; unsigned long chunkSize; char format[4]; char subChunkId[4]; unsigned long subChunkSize; unsigned short audioFormat; unsigned short numChannels; unsigned long sampleRate; unsigned long bytesPerSecond; unsigned short blockAlign; unsigned short bitsPerSample; char dataChunkId[4]; unsigned long dataSize;&#125;; &emsp;&emsp;这一个结构体可能比较复杂，可以参考维基百科：wav 文件格式 ，有详细介绍 wav 的文件头各个参数，如下图（来自维基百科）： &emsp;&emsp;有了这个结构体，我们可以直接读取文件中的 Header 部分： 123456789101112131415INT error;FILE *filePtr = nullptr;UINT count;WaveHeader waveHeader;error = fopen_s(&amp;filePtr, "./sound.wav", "rb");if (error) &#123; MessageBox(nullptr, "ERROR::OpenWavFile", "ERROR", MB_OK); return false;&#125;count = fread(&amp;waveHeader, sizeof(waveHeader), 1, filePtr);if (count != 1) &#123; MessageBox(nullptr, "ERROR::ReadWavFileHeader", "ERROR", MB_OK); return false;&#125; &emsp;&emsp;我们使用 fread 从内存层面直接将数据赋值到了 waveHeader 上，然后现在可以根据 waveHeader 的各个信息判断是否满足我们的要求： 1234567891011121314151617181920212223242526272829303132if (waveHeader.chunkId[0] != 'R' || waveHeader.chunkId[1] != 'I' || waveHeader.chunkId[2] != 'F' || waveHeader.chunkId[3] != 'F') &#123; MessageBox(nullptr, "ERROR::chunkId != RIFF", "ERROR", MB_OK); return false;&#125;if (waveHeader.format[0] != 'W' || waveHeader.format[1] != 'A' || waveHeader.format[2] != 'V' || waveHeader.format[3] != 'E') &#123; MessageBox(nullptr, "ERROR::format != WAVE", "ERROR", MB_OK); return false;&#125;if (waveHeader.subChunkId[0] != 'f' || waveHeader.subChunkId[1] != 'm' || waveHeader.subChunkId[2] != 't' || waveHeader.subChunkId[3] != ' ') &#123; MessageBox(nullptr, "ERROR::subChunkId != FMT", "ERROR", MB_OK); return false;&#125;if (waveHeader.dataChunkId[0] != 'd' || waveHeader.dataChunkId[1] != 'a' || waveHeader.dataChunkId[2] != 't' || waveHeader.dataChunkId[3] != 'a') &#123; MessageBox(nullptr, "ERROR::dataChunkId != data", "ERROR", MB_OK); return false;&#125;if (waveHeader.audioFormat != WAVE_FORMAT_PCM) &#123; MessageBox(nullptr, "ERROR::audioFormat != PCM", "ERROR", MB_OK); return false;&#125;if (waveHeader.numChannels != 2) &#123; MessageBox(nullptr, "ERROR::numChannels != 2", "ERROR", MB_OK); return false;&#125;if (waveHeader.sampleRate != 44100) &#123; MessageBox(nullptr, "ERROR::sampleRate != 44100", "ERROR", MB_OK); return false;&#125;if (waveHeader.bitsPerSample != 16) &#123; MessageBox(nullptr, "ERROR::bitsPerSample != 16", "ERROR", MB_OK); return false;&#125; &emsp;&emsp;如果符合条件，我们就可以使用这个文件中的数据来创建一个存储信息的辅助缓冲区了。 使用文件信息配置辅助缓冲&emsp;&emsp;首先我们将数据读出来： 12345678910111213fseek(filePtr, sizeof(waveHeader), SEEK_SET);UCHAR *waveData = new UCHAR[waveHeader.dataSize];count = fread(waveData, 1, waveHeader.dataSize, filePtr);if (count != waveHeader.dataSize) &#123; MessageBox(nullptr, "ERROR::ReadSize != waveHeader.dataSize", "ERROR", MB_OK); return false;&#125;error = fclose(filePtr);if (error != 0) &#123; MessageBox(nullptr, "ERROR::CloseFile", "ERROR", MB_OK); return false;&#125; &emsp;&emsp;使用 fseek ，我们将文件指针定位到了 data 段的开始，然后将数据存入了 waveData 里。现在我们可以利用 waveData 创建一个临时缓冲： 123456789101112131415161718192021222324WAVEFORMATEX waveFormatEx;ZeroMemory(&amp;waveFormatEx, sizeof(waveFormatEx));waveFormatEx.wFormatTag = WAVE_FORMAT_PCM;waveFormatEx.nSamplesPerSec = 44100;waveFormatEx.wBitsPerSample = 16;waveFormatEx.nChannels = 2;waveFormatEx.nBlockAlign = waveFormatEx.wBitsPerSample / 8 * waveFormatEx.nChannels;waveFormatEx.nAvgBytesPerSec = waveFormatEx.nSamplesPerSec * waveFormatEx.nBlockAlign;waveFormatEx.cbSize = 0;DSBUFFERDESC bufferDesc;ZeroMemory(&amp;bufferDesc, sizeof(bufferDesc));bufferDesc.dwSize = sizeof(DSBUFFERDESC);bufferDesc.dwFlags = DSBCAPS_CTRLVOLUME;bufferDesc.lpwfxFormat = &amp;waveFormatEx;bufferDesc.dwBufferBytes = waveHeader.dataSize;bufferDesc.guid3DAlgorithm = GUID_NULL;IDirectSoundBuffer *pSoundTmpBuffer = nullptr;hr = pSoundDevice-&gt;CreateSoundBuffer(&amp;bufferDesc, &amp;pSoundTmpBuffer, nullptr);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateSoundTmpBuffer", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;我们调用 pSoundTmpBuffer 的 QueryInterface 方法来创建辅助声音缓冲（在 dx 中，我们需要通过设备对象创建一个主缓冲。还需要至少一个用来存储声音信息的辅助缓冲，DirectSound 把辅助缓冲中的声音混合到主缓冲中）： 123456IDirectSoundBuffer8 *pSoundSecondaryBuffer = nullptr;hr = pSoundTmpBuffer-&gt;QueryInterface(IID_IDirectSoundBuffer8, reinterpret_cast&lt;LPVOID*&gt;(&amp;pSoundSecondaryBuffer));if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::SoundTmpBuffer::QueryInterface", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;现在，我们有了我们的辅助缓冲对象，给它填充数据： 1234567891011121314151617UCHAR *bufferPtr = nullptr;ULONG bufferSize;hr = pSoundSecondaryBuffer-&gt;Lock(0, waveHeader.dataSize, reinterpret_cast&lt;LPVOID*&gt;(&amp;bufferPtr), &amp;bufferSize, nullptr, 0, 0); //Lockif (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::pSoundSecondaryBuffer::Lock", "ERROR", MB_OK); return hr;&#125;memcpy(bufferPtr, waveData, waveHeader.dataSize); //copyhr = pSoundSecondaryBuffer-&gt;Unlock(bufferPtr, bufferSize, nullptr, 0); //UNLockif (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::pSoundSecondaryBuffer::UNLock", "ERROR", MB_OK); return hr;&#125;delete[] waveData;waveData = 0; &emsp;&emsp;这个时候已经可以进行播放了。 播放 DirectSoundBuffer1234567891011121314151617hr = pSoundSecondaryBuffer-&gt;SetCurrentPosition(0);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::pSoundSecondaryBuffer::SetCurrentPosition", "ERROR", MB_OK); return hr;&#125;hr = pSoundSecondaryBuffer-&gt;SetVolume(DSBVOLUME_MAX);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::pSoundSecondaryBuffer::SetVolume", "ERROR", MB_OK); return hr;&#125;hr = pSoundSecondaryBuffer-&gt;Play(0, 0, 0);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::pSoundSecondaryBuffer::Play", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;源代码：DX11Tutorial-DirectSound]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CG】简单的图像后期处理3]]></title>
    <url>%2F2018%2F04%2F02%2F%E3%80%90CG%E3%80%91%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E5%83%8F%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%863%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中主要介绍锐化（sharpening）效果。如果说模糊是一种去中心化，使得像素边缘及灰度跳变的部分趋于平滑，而锐化则是恰恰相反。 &emsp;&emsp;在百度百科，对锐化的描述如下： &emsp;&emsp;图像锐化(image sharpening)是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰，分为空域处理和频域处理两类。 图像锐化是为了突出图像上地物的边缘、轮廓，或某些线性目标要素的特征。 这种滤波方法提高了地物边缘与周围像元之间的反差，因此也被称为边缘增强。 &emsp;&emsp;我们的实现也是颇为简单，在上一篇中我们事先高斯模糊的时候，定义了一个滤波器数组以及一个用来做权重的平滑矩阵，如下： 12345678910111213141516171819202122232425262728float4 doFilter(float3x3 fil , float2 texSize , float2 uv) &#123; float2 posDelta[3][3] = &#123; // 3x3偏移坐标 &#123;float2(-1.0f , -1.0f) , float2(0.0f , -1.0f) , float2(1.0f , -1.0f)&#125; , &#123;float2(-1.0f , 0.0f) , float2(0.0f , 0.0f) , float2(1.0f , 0.0f)&#125;, &#123;float2(-1.0f , 1.0f) , float2(0.0f , 1.0f) , float2(1.0f , 1.0f)&#125; &#125;; float4 color = float4(0.0f, 0.0f, 0.0f, 1.0f); for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; float2 tUV = float2(uv.x + posDelta[i][j].x , uv.y + posDelta[i][j].y); // 加到最终颜色上 color += tex.Sample(samp, tUV / texSize) * fil[i][j]; &#125;; &#125; color.w = 1.0f; // 透明度矫正 return color;&#125;float4 main(pixelInputType input) : SV_TARGET&#123; float2 texSize = float2(1920 , 1200); // 图片的大小 float3x3 fil = float3x3( 1.0f, 2.0f, 1.0f, 2.0f, 4.0f, 2.0f, 1.0f, 2.0f, 1.0f ) / 16; float2 uv = input.texcoord * texSize; return doFilter(fil , texSize , uv); &#125; &emsp;&emsp;在 main 方法里定义的 fil 使得我们单个像素的颜色与周围颜色权值叠加，给一种模糊的效果，而锐化则是将 fil 改为： 12345float3x3 fil = float3x3( -1.0f, -2.0f, -1.0f, -2.0f, 16.0f, -2.0f, -1.0f, -2.0f, -1.0f); &emsp;&emsp;效果如下： &emsp;&emsp;源代码：Post Processing]]></content>
      <tags>
        <tag>Computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】18-FPS与CPU使用率]]></title>
    <url>%2F2018%2F04%2F02%2F%E3%80%90DirectX%E3%80%9118-FPS%E4%B8%8ECPU%E4%BD%BF%E7%94%A8%E7%8E%87%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 15: FPS, CPU Usage, and Timers 学习记录&emsp;&emsp;这篇文章内容不多，主要是趁着前边的 2D 文字渲染印象还好，就顺便学习了关于 3D渲染中 FPS 和 CPU 使用率的显示。 &emsp;&emsp;FPS 的内容我们自己可以通过计数器计算，每一帧对计数器加1，当一秒后将计数器的值赋值给 FPS 的变量同时清零计数器的值以备下一秒的计算。这里我写成了一个方法： 1234567891011inline int GetFPS(unsigned long &amp;startTime , int &amp;fps , int &amp;tc) &#123; const auto time = timeGetTime(); if (time &gt;= (startTime + 1000)) &#123; fps = tc; tc = 0; startTime = timeGetTime(); &#125; else &#123; ++tc; &#125; return fps;&#125; &emsp;&emsp;这样，我们可以制作出一个并不太精准的 FPS 计数器。这里的 timeGetTime() 方法我们需要导入库 Winmm.lib 。 &emsp;&emsp;而 CPU 使用率的话我们则是需要使用一个叫做 pdh 的库，在导入了 pdh.lib 后 ，我们需要去初始化一些变量： 123HQUERY hQuery = nullptr;HCOUNTER hCounter = nullptr;PDH_STATUS status; &emsp;&emsp;HQUERY 是我们的查询器句柄，HCOUNTER 则是计数器句柄。声明变量之后我们需要调用方法来启用他： 12345678status = PdhOpenQuery(nullptr, 0, &amp;hQuery);if (status != ERROR_SUCCESS) &#123; canSample = false;&#125;status = PdhAddCounter(hQuery, TEXT("\\Processor(_Total)\\% processor time"), 0, &amp;hCounter);if (status != ERROR_SUCCESS) &#123; canSample = false;&#125; &emsp;&emsp;第一个为打开查询，第二个则是为查询添加一个计数器，其中的TEXT(&quot;\\Processor(_Total)\\% processor time&quot;) 这一段则是我们的计数器路径。现在查询器和计数器都搞定了之后我们依旧将查询的任务写成一个方法： 1234567891011inline int GetCPUUsage(const bool canSamleUsage , int &amp;usage, unsigned long &amp;lastTime , const HQUERY hQuery , const HCOUNTER hCounter) &#123; const auto time = timeGetTime(); if (canSamleUsage &amp;&amp; time &gt;= (lastTime + 1000)) &#123; PDH_FMT_COUNTERVALUE value; PdhCollectQueryData(hQuery); PdhGetFormattedCounterValue(hCounter, PDH_FMT_LONG, nullptr, &amp;value); usage = value.longValue; lastTime = timeGetTime(); &#125; return usage;&#125; &emsp;&emsp;现在在 Main 里调用： 123456789101112131415161718192021222324252627282930313233343536373839const string fpsText = "FPS : ";int tCount = 0;int fps = 0;unsigned long startTime = timeGetTime();const string cpuText = "CUP : ";unsigned long lastSampleTime = timeGetTime();int cpuUsage = 0;bool canSample = true;HQUERY hQuery = nullptr;HCOUNTER hCounter = nullptr;PDH_STATUS status;status = PdhOpenQuery(nullptr, 0, &amp;hQuery);if (status != ERROR_SUCCESS) &#123; MessageBox(nullptr, "ERROR::OpenQuery", "ERROR", MB_OK); canSample = false;&#125;status = PdhAddCounter(hQuery, TEXT("\\Processor(_Total)\\% processor time"), 0, &amp;hCounter);if (status != ERROR_SUCCESS) &#123; MessageBox(nullptr, "ERROR::AddCounter", "ERROR", MB_OK); canSample = false;&#125;MSG msg;ZeroMemory(&amp;msg, sizeof(MSG));while (msg.message != WM_QUIT) &#123; if (PeekMessage(&amp;msg, nullptr, 0, 0, PM_REMOVE)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; float color[] = &#123; 0.0f , 0.0f , 0.0f , 1.0f &#125;; pImmediateContext-&gt;ClearRenderTargetView(pRenderTargetView, color); // Print PrintText(fpsText + to_string(GetFPS(startTime , fps , tCount)) , -620, 300, fonts , pVertexShader, pPixelShader, pInputLayout, pDevice, &amp;vertices, &amp;pImmediateContext); PrintText(cpuText + to_string(GetCPUUsage(canSample , cpuUsage , lastSampleTime , hQuery , hCounter)) , -620, 240, fonts , pVertexShader, pPixelShader, pInputLayout, pDevice, &amp;vertices, &amp;pImmediateContext); pSwapChain-&gt;Present(0, 0);&#125; &emsp;&emsp;显示如下： &emsp;&emsp;源代码地址：DX11Tutorial-FpsAndCpuUsage]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x的平方根]]></title>
    <url>%2F2018%2F04%2F02%2Fx%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#69 x的平方根 题目描述&emsp;&emsp;实现 int sqrt(int x) 函数。 &emsp;&emsp;计算并返回 x 的平方根。 &emsp;&emsp;x 保证是一个非负整数。 案例 1: 12输入: 4输出: 2 案例 2: 123输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于我们想返回一个整数，小数部分将被舍去。 解题思路&emsp;&emsp;求整数平方根并且是向下取整，那么可以判断当 i^2 &lt;= x &amp;&amp; (i+1)^2 &gt; x 的时候返回 i 。 解题代码123456789101112class Solution &#123;public: int mySqrt(int x) &#123; long i = 0; for (i = 1; i &lt;= x; ++i) &#123; if(i * i &gt; x &amp;&amp; (i-1) * (i-1) &lt;= x) &#123; return i-1; &#125; &#125; return i-1; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】17-DirectInput输入设备]]></title>
    <url>%2F2018%2F04%2F01%2F%E3%80%90DirectX%E3%80%9117-DirectInput%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 13: Direct Input 学习记录&emsp;&emsp;之前的内容几乎一直在学习 D3D ，今天这一篇中我们将学习 DirectInput ，DX 中的输入轮子。这一篇中将实现在屏幕上实时显示屏幕的坐标，以及使用 DirectInput 中的键盘控制来设置 ESC 键退出窗口。 &emsp;&emsp;DirectInput 的使用和 D3D 异曲同工，都是需要先初始化一个设备接口，然后使用这个设备接口来创建具体的设备。不过 DirectInput 常用的内容不多，所以就不会像是 D3D 一样需要分好多篇文章来写。 &emsp;&emsp;使用 DirectInput ，我们需要导入头文件 #include &lt;dinput.h&gt; 和引用 dinput8.lib 和 dxguid.lib 静态库。来看看初始化一个 DirectInput 对象（关于每个方法具体参数参考 MSDN）： 123456IDirectInput8 *pInputDevice = nullptr;hr = DirectInput8Create(hInstance, DIRECTINPUT8_VERSION, IID_IDirectInput8, reinterpret_cast&lt;LPVOID*&gt;(&amp;pInputDevice), nullptr);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateInputDevice", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;有了这个对象之后，我们用它来创建键盘： 1234567IDirectInputDevice8 *pKeyboard = nullptr;IDirectInputDevice8 *pMouse = nullptr;hr = pInputDevice-&gt;CreateDevice(GUID_SysKeyboard, &amp;pKeyboard, nullptr);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateKeyBoard", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;设置键盘对象属性： 12345678910hr = pKeyboard-&gt;SetDataFormat(&amp;c_dfDIKeyboard);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::SetKeyBoardDataFormat", "ERROR", MB_OK); return hr;&#125;hr = pKeyboard-&gt;SetCooperativeLevel(hWnd, DISCL_FOREGROUND | DISCL_EXCLUSIVE); //设置为独占if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::SetKeyBoardCooperativeLevel", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;Acquire 它： 12345hr = pKeyboard-&gt;Acquire();if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::KeyBoardAcquire", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;鼠标的创建以及设置和键盘一致： 1234567891011121314151617181920hr = pInputDevice-&gt;CreateDevice(GUID_SysMouse, &amp;pMouse, nullptr);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateMouse", "ERROR", MB_OK); return hr;&#125;hr = pMouse-&gt;SetDataFormat(&amp;c_dfDIMouse);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::SetMouseDataFormat", "ERROR", MB_OK); return hr;&#125;hr = pMouse-&gt;SetCooperativeLevel(hWnd, DISCL_FOREGROUND | DISCL_NONEXCLUSIVE);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::SetMouseCooperativeLevel", "ERROR", MB_OK); return hr;&#125;hr = pMouse-&gt;Acquire();if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::MouseAcquire", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;现在我们有了键盘和鼠标对象，可以使用它了，首先创建我们需要的数据（键盘为一个 char 数组保存键盘状态，鼠标为 DIMOUSESTATE 和 鼠标位置）： 123char pKeyBoardState[256];DIMOUSESTATE mouseState;int mouseX = 0, mouseY = 0; &emsp;&emsp;在主循环中，我们通过鼠标和键盘对象的 GetDeviceState 函数来获得他们的状态，比如键盘如下： 12345678910hr = pKeyboard-&gt;GetDeviceState(sizeof(pKeyBoardState), static_cast&lt;LPVOID&gt;(&amp;pKeyBoardState));if (FAILED(hr)) &#123; if (hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED) &#123; pKeyboard-&gt;Acquire(); &#125; else &#123; MessageBox(nullptr, "ERROR::GetKeyBoardState", "ERROR", MB_OK); return hr; &#125;&#125; &emsp;&emsp;这里有个地方需要注意，我们在 GetDeviceState 返回异常后，并没有直接返回，而是先判断了一下异常内容，当它因为未获得或者失去焦点的时候，我们尝试重新取 Acquire 它，如果不是这两个问题的话，自然就直接返回了。 &emsp;&emsp;鼠标和键盘基本一样，他的坐标则是用我们声明的坐标去加设备对象返回给我们的偏移量： 123456789101112hr = pMouse-&gt;GetDeviceState(sizeof(DIMOUSESTATE), static_cast&lt;LPVOID&gt;(&amp;mouseState));if (FAILED(hr)) &#123; if (hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED) &#123; pMouse-&gt;Acquire(); &#125; else &#123; MessageBox(nullptr, "ERROR::GetMouseState", "ERROR", MB_OK); return hr; &#125;&#125;mouseX += mouseState.lX;mouseY += mouseState.lY; &emsp;&emsp;现在，我们已经完整的获得了鼠标和键盘的对象，可以分别根据它的内容做一些其他的事情了，当键盘的 ESC 键按下时，发送一个 QUIT 的消息： 123if (pKeyBoardState[DIK_ESCAPE] &amp; 0x80) &#123; PostQuitMessage(0);&#125; &emsp;&emsp;同时我们可以在每帧里绘制当前的坐标位置，我们设计了一个方法去在屏幕上打印这个坐标： 12345678910111213141516171819202122inline HRESULT PrintMousePos( const int mouseX , // 鼠标坐标 x const int mouseY , // 鼠标坐标 y Font *fonts, ID3D11VertexShader *pVertexShader , ID3D11PixelShader *pPixelShader , ID3D11InputLayout *pInputLayout, ID3D11Device *pDevice , ID3D11DeviceContext **pImmediateContext) &#123; string xyStr = "Mouse X = " + to_string(mouseX) + " Y = " + to_string(mouseY); Vertex *vertices = nullptr; int nNumVertices = 0; InitVertex(pDevice , xyStr.c_str() , -800 , 400 , fonts , pImmediateContext , &amp;nNumVertices , &amp;vertices); (*pImmediateContext)-&gt;VSSetShader(pVertexShader, 0, 0); (*pImmediateContext)-&gt;PSSetShader(pPixelShader, 0, 0); (*pImmediateContext)-&gt;IASetInputLayout(pInputLayout); (*pImmediateContext)-&gt;Draw(nNumVertices * 6, 0); return S_OK;&#125; &emsp;&emsp;我们可以在循环里去绘制，这样每帧都会生成不同的顶点数组并且去渲染它。当然这样是非常非常不理智的，如果要实际运用，一般会使用动态的更新顶点缓冲里的数据而非每一次循环单独生成。我这样的话你会发现运行一会后就炸了，因为一直在申请内存来存储顶点。。。。。。。。。。。。。。。。。。。 &emsp;&emsp;最终效果如下：]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[唯一摩尔斯密码词]]></title>
    <url>%2F2018%2F04%2F01%2F%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#804 唯一摩尔斯密码词 题目描述&emsp;&emsp;国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: &quot;a&quot; 对应 &quot;.-&quot;, &quot;b&quot;对应 &quot;-...&quot;, &quot;c&quot; 对应 &quot;-.-.&quot;, 等等。 &emsp;&emsp;为了方便，所有26个英文字母对应摩尔斯密码表如下： 1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] &emsp;&emsp;给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-.-….-“，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。 &emsp;&emsp;返回我们可以获得所有词不同单词翻译的数量。 1234567891011例如:输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]输出: 2解释: 各单词翻译如下:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;. 注意: 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 解题思路&emsp;&emsp;将给定所有单词的摩斯码值使用 Set 存储，自然就是不重复的。 解题代码123456789101112131415161718class Solution &#123;public: int uniqueMorseRepresentations(vector&lt;string&gt; &amp;words) &#123; vector&lt;string&gt; codes = &#123; ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.." &#125;; unordered_set&lt;string&gt; set; for(auto word : words)&#123; string tmp(""); for (auto letter : word)&#123; tmp += codes[(int)letter - 97]; &#125; set.insert(tmp); &#125; return set.size(); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】16-渲染字体]]></title>
    <url>%2F2018%2F03%2F31%2F%E3%80%90DirectX%E3%80%9116-%E6%B8%B2%E6%9F%93%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[参考教程Tutorial 12: Font Engine 学习记录&emsp;&emsp;这篇文章中，我们将去实现文字的渲染。在渲染文字这方面，一直有很多解决方案，也都是有利有弊吧。这里我们介绍的是使用文字贴图来实现。 &emsp;&emsp;使用文字贴图渲染，也就是说将文字的显示放在一张纹理图片上，我们根据需要渲染的字来选择对应的纹理来渲染。这种方法虽然方便，但是也有很多局限，比如中文数千个字，要保存起来就比较麻烦了。虽然局限性比较大，但是对于简单的文本渲染来说还是可以使用的。 &emsp;&emsp;首先，我们需要一张文字纹理贴图和一个纹理索引文件，纹理贴图和纹理索引文件一会可以到源代码网址里下载。纹理索引文件格式如下： 12345678910111213141516171819202122239533 ! 0.0 0.000976563 134 " 0.00195313 0.00488281 335 # 0.00585938 0.0136719 836 $ 0.0146484 0.0195313 537 % 0.0205078 0.0302734 1038 &amp; 0.03125 0.0390625 839 ' 0.0400391 0.0410156 140 ( 0.0419922 0.0449219 341 ) 0.0458984 0.0488281 342 * 0.0498047 0.0546875 543 + 0.0556641 0.0625 744 , 0.0634766 0.0644531 145 - 0.0654297 0.0683594 346 . 0.0693359 0.0703125 147 / 0.0712891 0.0751953 448 0 0.0761719 0.0820313 649 1 0.0830078 0.0859375 350 2 0.0869141 0.0927734 651 3 0.09375 0.0996094 652 4 0.100586 0.106445 653 5 0.107422 0.113281 6... &emsp;&emsp;这只是其中的一部分数据，第一行的数字是文件里字符的个数，剩下每一行代表一个字符，每一行的第一个数字是 ascii 值，第二个是显示字符，第三个是纹理的 u 坐标，第四个是纹理的 v 坐标，最后一个是这个字的大小。 &emsp;&emsp;现在，我们来创建一个字体的结构体： 1234struct Font &#123; float left, right; int size;&#125;; &emsp;&emsp;这个结构体包含了每个字的纹理坐标的左右点和大小，事实上我们还可以自定义它的大小来让我们显示的时候能够显示更多样式的字体。 &emsp;&emsp;有了结构体，我们试着将文件里的数字读入一个 Font 数组： 12Font *fonts = nullptr;LoadFontData("./fontdata.txt", &amp;fonts); &emsp;&emsp;这里我们创建了一个方法，来看看这个方法的具体实现： 12345678910111213141516171819bool LoadFontData(const char* path , Font **fontData) &#123; ifstream ifs(path); if (!ifs.is_open()) return false; int fontCount = 0; ifs &gt;&gt; fontCount; *fontData = new Font[fontCount]; if (!(*fontData)) return false; for (int i = 0 ; i &lt; fontCount ; ++i) &#123; int ascii; char letter; ifs &gt;&gt; ascii &gt;&gt; letter &gt;&gt; (*fontData)[i].left &gt;&gt; (*fontData)[i].right &gt;&gt; (*fontData)[i].size; &#125; ifs.close(); return true;&#125; &emsp;&emsp;这里读入文件里的第一个字符，得到字符的个数，然后为传进来的指针创建数组，并且赋值。 &emsp;&emsp;得到了字符数组之后，我们就可以使用这个数组来实现我们的字符显示了。在我们使用文字贴图这种方法渲染文字时，我们会为需要渲染的每一个文字创建一个小矩形，即两个三角形。并为每个三角形赋值他的坐标和 UV 坐标。 &emsp;&emsp;来看看我们的实现： 12345Vertex *vertices = nullptr;char sentence[] = "hello";const int n = strlen(sentence);float drawX = 0.0f , drawY = 0.0f;GetFontsVertex(fonts, sentence ,n, drawX, drawY, &amp;vertices); &emsp;&emsp;我们创建了 Vertex 指针传入到 GetFontsVertex 方法中，同时传入的还有我们想要渲染的句子和句子长度以及我们想要渲染文字的起点坐标。这个方法实现如下： 123456789101112131415161718192021222324252627void GetFontsVertex(const Font *fontData , const char* sentence , const int n , const float x , const float y , Vertex **vertices) &#123; (*vertices) = new Vertex[n * 6]; int idx = 0; float posX = x; const float posY = y; for (auto i = 0 ; i &lt; n; ++i) &#123; const int let = static_cast&lt;int&gt;(sentence[i]) - 32; const Font letter = fontData[let]; if (sentence[i] - 32 == 0) &#123; posX += 3; &#125; else &#123; (*vertices)[idx].pos = XMFLOAT3(posX, posY, 0.0f); // 左上 (*vertices)[idx++].tex = XMFLOAT2(letter.left, 0.0f); (*vertices)[idx].pos = XMFLOAT3(posX + letter.size, posY - 16, 0.0f); // 右下 (*vertices)[idx++].tex = XMFLOAT2(letter.right, 1.0f); (*vertices)[idx].pos = XMFLOAT3(posX, posY - 16, 0.0f); // 左下 (*vertices)[idx++].tex = XMFLOAT2(letter.left, 1.0f); (*vertices)[idx].pos = XMFLOAT3(posX, posY, 0.0f); // 左上 (*vertices)[idx++].tex = XMFLOAT2(letter.left, 0.0f); (*vertices)[idx].pos = XMFLOAT3(posX + letter.size, posY, 0.0f); // 右上 (*vertices)[idx++].tex = XMFLOAT2(letter.right, 0.0f); (*vertices)[idx].pos = XMFLOAT3(posX + letter.size, posY - 16, 0.0f); // 右下 (*vertices)[idx++].tex = XMFLOAT2(letter.right, 1.0f); posX += letter.size + 1.0f; &#125; &#125;&#125; &emsp;&emsp;在这个方法里，我们通过遍历句子得到要渲染的每一个字符，然后为其创建一个矩形（六个顶点），最后加到我们传进来的顶点数组里。 &emsp;&emsp;有了顶点数组，我们只要将纹理改成文字贴图就可以实现正常的渲染了。 &emsp;&emsp;源代码地址在这里：DX11Tutorial Font]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】15-2D渲染与正交矩阵]]></title>
    <url>%2F2018%2F03%2F31%2F%E3%80%90DirectX%E3%80%9115-2D%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 11: 2D Rendering 学习记录&emsp;&emsp;这篇文章中主要介绍在 DX 中对于 2D 的渲染，这篇内容其实不多，也没啥营养。本来不想写的，但是因为之后要进行字体渲染什么的，干脆在之前把这个先写了吧。 &emsp;&emsp;在 2D 坐标系中，我们只有 x,y 概念而没有 z 轴，所以在此之前我们需要关闭 z 轴，即禁用深度缓冲。禁用之后我们的绘制将会以画家算法为准，先绘制的物体会被后绘制的遮挡。首先使用深度模板缓冲，将是否启用设置为 false。 1234567891011121314151617181920212223D3D11_DEPTH_STENCIL_DESC ddDisableStencilopDesc;ZeroMemory(&amp;ddDisableStencilopDesc, sizeof(ddDisableStencilopDesc));ddDisableStencilopDesc.DepthEnable = false; //////////////////////////////// 2D中禁用深度 //////////////////////////////////////////////////////////////////////ddDisableStencilopDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;ddDisableStencilopDesc.DepthFunc = D3D11_COMPARISON_LESS;ddDisableStencilopDesc.StencilEnable = true;ddDisableStencilopDesc.StencilReadMask = 0xFF;ddDisableStencilopDesc.StencilWriteMask = 0xFF;ddDisableStencilopDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;ddDisableStencilopDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;ddDisableStencilopDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;ddDisableStencilopDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;ddDisableStencilopDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;ddDisableStencilopDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;ddDisableStencilopDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;ddDisableStencilopDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;ID3D11DepthStencilState *pDisableDepthStencilState = nullptr;hr = pDevice-&gt;CreateDepthStencilState(&amp;ddDisableStencilopDesc, &amp;pDisableDepthStencilState);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateDepthStencilState", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;这个和 3D 中的是一样的，如果我们需要 3D 的缓冲可以直接将 false 改为 true 。接着在立即上下文对象中设置它： 1pImmediateContext-&gt;OMSetDepthStencilState(pDisableDepthStencilState, 1); &emsp;&emsp;现在来创建深度模板测试视图并启用： 123456789101112D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;ZeroMemory(&amp;depthStencilViewDesc, sizeof(depthStencilViewDesc));depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;depthStencilViewDesc.Texture2D.MipSlice = 0;ID3D11DepthStencilView *pDepthStencilView = nullptr;hr = pDevice-&gt;CreateDepthStencilView(pDepthBuffer, &amp;depthStencilViewDesc, &amp;pDepthStencilView);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateDepthStencilView", "ERROR", MB_OK); return hr;&#125;pImmediateContext-&gt;OMSetRenderTargets(1, &amp;pRenderTargetView, pDepthStencilView); &emsp;&emsp;除了对 Z 的禁用之外，我们需要使用正交投影矩阵来代替 3D 的投影矩阵，创建出新的坐标系统矩阵： 123456789MatrixXD matrix2d = &#123; XMMatrixIdentity() , XMMatrixLookAtLH( XMVectorSet(0.0f, 0.0f , -100.0f , 0.0f), XMVectorSet(0.0f, 0.0f , 0.0f , 0.0f), XMVectorSet(0.0f, 1.0f , 0.0f , 0.0f) ), XMMatrixOrthographicLH(static_cast&lt;float&gt;(width) , static_cast&lt;float&gt;(height) , 0.01f , 100.0f)&#125;; &emsp;&emsp;在使用了正交投影后，我们对我们的举行坐标进行修改，现在他们的范围与屏幕大小有关，且原点在屏幕中央。现在我们将矩形设置为中心在原点边长为200的一个正方形： 123456789Vertex vertices[] =&#123; &#123; DirectX::XMFLOAT3(-100.0f, -100.0f, 0.0f) , DirectX::XMFLOAT2(0.0f,1.0f) &#125;, &#123; DirectX::XMFLOAT3(-100.0f, 100.0f, 0.0f) , DirectX::XMFLOAT2(0.0f,0.0f) &#125;, &#123; DirectX::XMFLOAT3(100.0f, 100.0f, 0.0f) , DirectX::XMFLOAT2(1.0f,0.0f) &#125;, &#123; DirectX::XMFLOAT3(-100.0f, -100.0f, 0.0f) , DirectX::XMFLOAT2(0.0f,1.0f) &#125;, &#123; DirectX::XMFLOAT3(100.0f, 100.0f, 0.0f) , DirectX::XMFLOAT2(1.0f,0.0f) &#125;, &#123; DirectX::XMFLOAT3(100.0f, -100.0f, 0.0f) , DirectX::XMFLOAT2(1.0f,1.0f) &#125;&#125;; &emsp;&emsp;其他基本一致，现在编译运行程序我们应该可以看到一个 200 * 200 的图片： &emsp;&emsp;源代码：DX11Tutorial：2D Render]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子序和]]></title>
    <url>%2F2018%2F03%2F30%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#53 最大子序和 题目描述&emsp;&emsp;给定一个序列（至少含有 1 个数），从该序列中寻找一个连续的子序列，使得子序列的和最大。 例如，给定序列 [-2,1,-3,4,-1,2,1,-5,4]，连续子序列 [4,-1,2,1] 的和最大，为 6。 解题思路&emsp;&emsp;这是一道很经典的题了，共有 O(n^3) ，O(n^2) ，O(nlogn) ，O(n) 几种解法，具体的随便一搜就出来。我这里是直接 O(n^2) 暴力解决。 解题思路1234567891011121314151617class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; long maxSum = INT_MIN; for (int i = 0; i &lt; nums.size(); i++) &#123; long thisSum = 0; for (int j = i; j &lt; nums.size(); j++) &#123; thisSum += nums[j]; if (thisSum &gt; maxSum) maxSum = thisSum; &#125; &#125; return maxSum; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CG】简单的图像后期处理2]]></title>
    <url>%2F2018%2F03%2F30%2F%E3%80%90CG%E3%80%91%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E5%83%8F%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%862%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中，我们将介绍高斯模糊（Gaussian Blur）以及在 HLSL 中实现这个效果。这个东西虽然听起来比较高端，但其实并不复杂，首先介绍一下他的概念： &emsp;&emsp;高斯模糊（英语：Gaussian Blur），也叫高斯平滑，是在Adobe Photoshop、GIMP以及Paint.NET等图像处理软件中广泛使用的处理效果，通常用它来减少图像噪声以及降低细节层次。这种模糊技术生成的图像，其视觉效果就像是经过一个半透明屏幕在观察图像，这与镜头焦外成像效果散景以及普通照明阴影中的效果都明显不同。高斯平滑也用于计算机视觉算法中的预先处理阶段，以增强图像在不同比例大小下的图像效果（参见尺度空间表示以及尺度空间实现）。 从数学的角度来看，图像的高斯模糊过程就是图像与正态分布做卷积。由于正态分布又叫作高斯分布，所以这项技术就叫作高斯模糊。图像与圆形方框模糊做卷积将会生成更加精确的焦外成像效果。由于高斯函数的傅立叶变换是另外一个高斯函数，所以高斯模糊对于图像来说就是一个低通滤波器。 &emsp;&emsp;他的实现原理是对进行模糊的像素进行去中心化，每个像素的值都是周围相邻像素的加权平均，而他本身的值有着最大的高斯分布值，相邻元素随着和要进行模糊的像素的距离变远而权值变低。在二维空间内的高斯分布方程如下： G(x,y)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-(x^2+y^2)/(2\sigma^2)}&emsp;&emsp;这些东西如果有兴趣的话可以去看 正态分布 。再次不多介绍，主要来看看我们将要去实现的内容，在 HLSL 中实现模糊。 &emsp;&emsp;前边已经说过，要实现这个效果是取这个像素和周围像素的颜色值进行加权平均，而我们可以取周围纹理坐标的值来进行计算。 &emsp;&emsp;首先我们定义一个权值矩阵： 12345float3x3 fil = float3x3( 1.0f, 2.0f, 1.0f, 2.0f, 4.0f, 2.0f, 1.0f, 2.0f, 1.0f ) / 16; &emsp;&emsp;fil[1][1] 则是我们要求的像素的值，可以看到确实是距离目标像素距离越近权值越大。由于最终权值是要为1，所以除以16。 &emsp;&emsp;现在，我们来定义偏移坐标： 12345float2 posDelta[3][3] = &#123; // 3x3偏移UV坐标 &#123;float2(-1.0f , -1.0f) , float2(0.0f , -1.0f) , float2(1.0f , -1.0f)&#125; , &#123;float2(-1.0f , 0.0f) , float2(0.0f , 0.0f) , float2(1.0f , 0.0f)&#125;, &#123;float2(-1.0f , 1.0f) , float2(0.0f , 1.0f) , float2(1.0f , 1.0f)&#125;&#125;; &emsp;&emsp;取的值也是在我们要求的像素的周围的位置。然后根据偏移坐标求出偏移后坐标的值，并使用采样器采取颜色，乘以权值，最终叠加到最终的颜色上： 12345678float4 color = float4(0.0f, 0.0f, 0.0f, 1.0f);for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; float2 tUV = float2(uv.x + posDelta[i][j].x , uv.y + posDelta[i][j].y); // 加到最终颜色上 color += tex.Sample(samp, tUV / texSize) * fil[i][j]; &#125;;&#125; &emsp;&emsp;对于我们的透明度，并不会去做计算，所以我们修正透明度，且返回颜色： 12color.w = 1.0f; // 透明度矫正return color; &emsp;&emsp;完整代码如下： 123456789101112131415161718192021222324252627282930float4 doFilter(float3x3 fil , float2 texSize , float2 uv) &#123; float2 posDelta[3][3] = &#123; // 3x3偏移坐标 &#123;float2(-1.0f , -1.0f) , float2(0.0f , -1.0f) , float2(1.0f , -1.0f)&#125; , &#123;float2(-1.0f , 0.0f) , float2(0.0f , 0.0f) , float2(1.0f , 0.0f)&#125;, &#123;float2(-1.0f , 1.0f) , float2(0.0f , 1.0f) , float2(1.0f , 1.0f)&#125; &#125;; float4 color = float4(0.0f, 0.0f, 0.0f, 1.0f); for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; float2 tUV = float2(uv.x + posDelta[i][j].x , uv.y + posDelta[i][j].y); // 加到最终颜色上 color += tex.Sample(samp, tUV / texSize) * fil[i][j]; &#125;; &#125; color.w = 1.0f; // 透明度矫正 return color;&#125;float4 main(pixelInputType input) : SV_TARGET&#123; float2 texSize = float2(1920 , 1200); // 图片的大小 float3x3 fil = float3x3( 1.0f, 2.0f, 1.0f, 2.0f, 4.0f, 2.0f, 1.0f, 2.0f, 1.0f ) / 16; float2 uv = input.texcoord * texSize; return doFilter(fil , texSize , uv); &#125; &emsp;&emsp;这里需要注意的是 texSize 属性，我们的 UV 坐标取值是 0 到 1 的，所以我们会将纹理的位置映射到 UV 坐标上。 &emsp;&emsp;效果如下： &emsp;&emsp;和我们之前的图片比较： &emsp;&emsp;还是很明显的，在这里我们只是使用了周围一圈的像素来做加权平均，如果可以使用更多的话效果会更好。]]></content>
      <tags>
        <tag>Computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CG】简单的图像后期处理1]]></title>
    <url>%2F2018%2F03%2F29%2F%E3%80%90CG%E3%80%91%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E5%83%8F%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%861%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这两天不知道为什么总是类的不行，累到看个书都看不进去。今天折腾我的破手机，给换了个 rom 和体验各种好玩的应用花去了不少时间，感觉自己又在浪的边缘慢慢试探了。 &emsp;&emsp;这篇文章又是一个新坑的开始，在这个系列里将使用 HLSL 对纹理实现一些常见的比较简单的后期处理效果，像什么反相，模糊这种。这篇主要是开个坑和实现最简单的反相和灰度。 &emsp;&emsp;我们首先构建一个覆盖整个显示窗口的矩形并为其贴上一张图片，这里简单的贴上顶点的坐标位置和纹理位置： 1234567891011121314struct Vertex &#123; DirectX::XMFLOAT3 pos; DirectX::XMFLOAT2 tex;&#125;;Vertex vertices[] =&#123; &#123; DirectX::XMFLOAT3(-1.0f, -1.0f, 0.5f) , DirectX::XMFLOAT2(0.0f,1.0f) &#125;, &#123; DirectX::XMFLOAT3(-1.0f, 1.0f, 0.5f) , DirectX::XMFLOAT2(0.0f,0.0f) &#125;, &#123; DirectX::XMFLOAT3(1.0f, 1.0f, 0.5f) , DirectX::XMFLOAT2(1.0f,0.0f) &#125;, &#123; DirectX::XMFLOAT3(-1.0f, -1.0f, 0.5f) , DirectX::XMFLOAT2(0.0f,1.0f) &#125;, &#123; DirectX::XMFLOAT3(1.0f, 1.0f, 0.5f) , DirectX::XMFLOAT2(1.0f,0.0f) &#125;, &#123; DirectX::XMFLOAT3(1.0f, -1.0f, 0.5f) , DirectX::XMFLOAT2(1.0f,1.0f) &#125;&#125;; &emsp;&emsp;我们贴图后应该是这个样子的： &emsp;&emsp;请无视掉那个必应的 LOGO ！ &emsp;&emsp;现在，我们来看看反相(Inversion)：反相，即颜色取反，我们对其每个像素的颜色 s 做 s = 1-s 的计算。HLSL 代码中，我们定义一个方法对其反相。 12345678float4 Inversion(float4 color) &#123; return float4(1.0f , 1.0f , 1.0f , 1.0f) - color;&#125;float4 main(pixelInputType input) : SV_TARGET&#123; float4 color = tex.Sample(samp, input.texcoord); return Inversion(color); &#125; &emsp;&emsp;现在来试试对部分图片反相，我们在 main 方法里加个判断，对屏幕右半部分反相处理： 12345float4 main(pixelInputType input) : SV_TARGET&#123; float4 color = tex.Sample(samp, input.texcoord); if (input.pos.x &gt; 960) return Inversion(color); //窗口大小为1920 else return color; &#125; &emsp;&emsp;这里只是做个实验，所以直接依照我当前的窗口大小将数字写死了。效果如下： &emsp;&emsp;现在来看看我们的第二个效果，灰度化(Grayscale)： &emsp;&emsp;灰度化的计算也比较简单，由于是去掉除了黑白灰的其他颜色，所以我们可以简单的将 RGB 做一个平均或者加权平均，这取决于我们的标准和感官，在这里我们简单的平均一下： 123456789float4 Grayscale(float4 color) &#123; float rgbValue = (color.x + color.y + color.z) / 3; return float4(rgbValue, rgbValue, rgbValue, 1.0f);&#125;float4 main(pixelInputType input) : SV_TARGET&#123; float4 color = tex.Sample(samp, input.texcoord); return Grayscale(color);&#125; &emsp;&emsp;现在，我们对刚才一半反相的那张照片添加下半部分灰度的效果： 12345678910float4 main(pixelInputType input) : SV_TARGET&#123; float4 color = tex.Sample(samp, input.texcoord); if (input.pos.y &gt; 540) &#123; color = Grayscale(color); &#125; if (input.pos.x &gt; 960) &#123; color = Inversion(color); &#125; return color;&#125; &emsp;&emsp;看看效果： &emsp;&emsp;下一篇将看心情实现高斯模糊（Gaussian Blur）。本系列文章源代码在这里：PostProcessing]]></content>
      <tags>
        <tag>Computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树后序遍历（非递归）]]></title>
    <url>%2F2018%2F03%2F29%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#145 二叉树后序遍历-非递归 题目描述&emsp;&emsp;给定一棵二叉树，返回其节点值的后序遍历。 例如：给定二叉树 [1,null,2,3]， 123451 \ 2 /3 返回 [3,2,1]。 注意: 递归方法很简单，你可以使用迭代方法来解决吗？ 解题思路&emsp;&emsp;后序遍历的非递归实现 解题代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; TreeNode *p = root , *tmp = nullptr; vector&lt;int&gt; res(0); while (p || !s.empty())&#123; while (p) &#123;s.push(p); p = p-&gt;left;&#125; if (!s.empty())&#123; p = s.top(); if (!p-&gt;right || p-&gt;right == tmp)&#123; s.pop(); tmp = p; res.push_back(p-&gt;val); p = 0; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】14-使用Mesh为单元绘制]]></title>
    <url>%2F2018%2F03%2F28%2F%E3%80%90DirectX%E3%80%9114-%E4%BD%BF%E7%94%A8Mesh%E4%B8%BA%E5%8D%95%E5%85%83%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇文章中，我们使用了 Assimp 导入了一个模型，然后将其的顶点和索引全部提取出来并成功在屏幕上渲染。但是这样做有个很明显的问题，我们没法贴图。因为大部分模型的贴图都是针对单个 Mesh 来创建的，我们将所有顶点提出来一起渲染，自然是没有办法做这个了，所以最后我们得到的是一个纯色的蜘蛛。 &emsp;&emsp;而这一篇中我们将针对 Mesh 进行渲染，并且对其贴图。 &emsp;&emsp;首先我们会创建一个 Mesh 类 ，这个类将实现对单个网格的渲染，来看看这个类的声明。 123456789101112131415161718192021222324252627class Mesh &#123; ID3D11Buffer *pIndexBufferObject; ID3D11Buffer *pVertexBufferObject; ID3D11VertexShader *pVertexShaderObject; ID3D11PixelShader *pPixelShaderObject; ID3D11InputLayout *pInputLayout; ID3D11SamplerState *pSamplerState; ID3D11ShaderResourceView *pShaderResourceView;public: Vertex * vertices; UINT *indices; vector&lt;std::string&gt; texturePaths; UINT vertexCount; UINT indexCount; Mesh(); Mesh(const UINT vertexCount, const UINT indexCount); HRESULT Init(ID3D11Device **pDevice , const char* vertexShaderPath , const char* pixelShaderPath); void Draw(ID3D11DeviceContext **pImmediateContext); void Release();&#125;; &emsp;&emsp;我们这个类设定的比较简单，并没有太多的功能，一个初始化，一个绘制，一个释放指针。来看看实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697HRESULT Init(ID3D11Device **pDevice , const char* vertexShaderPath , const char* pixelShaderPath) &#123; HRESULT hr; D3D11_BUFFER_DESC vertexBufferDesc; ZeroMemory(&amp;vertexBufferDesc, sizeof(vertexBufferDesc)); vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT; vertexBufferDesc.ByteWidth = sizeof(Vertex) * vertexCount; vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; D3D11_SUBRESOURCE_DATA verticesSourceData; ZeroMemory(&amp;verticesSourceData, sizeof(D3D11_SUBRESOURCE_DATA)); verticesSourceData.pSysMem = vertices; D3D11_BUFFER_DESC indexDesc; ZeroMemory(&amp;indexDesc, sizeof(indexDesc)); indexDesc.Usage = D3D11_USAGE_IMMUTABLE; indexDesc.BindFlags = D3D11_BIND_INDEX_BUFFER; indexDesc.ByteWidth = sizeof(UINT) * indexCount; D3D11_SUBRESOURCE_DATA indexData; ZeroMemory(&amp;indexData, sizeof(indexData)); indexData.pSysMem = indices; hr = (*pDevice)-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;verticesSourceData, &amp;pVertexBufferObject); if (FAILED(hr)) &#123; return hr; &#125; hr = (*pDevice)-&gt;CreateBuffer(&amp;indexDesc, &amp;indexData, &amp;pIndexBufferObject); if (FAILED(hr)) &#123; return hr; &#125; ID3D10Blob* pErrorMessage = nullptr; ID3D10Blob* pVertexShaderBlob = nullptr; ID3D10Blob* pPixelShaderBlob = nullptr; hr = D3DX11CompileFromFile(vertexShaderPath, nullptr, nullptr, "main", "vs_5_0", D3DCOMPILER_STRIP_DEBUG_INFO, 0, nullptr, &amp;pVertexShaderBlob, &amp;pErrorMessage, nullptr); if (FAILED(hr)) &#123; if (pErrorMessage) MessageBox(NULL, static_cast&lt;CHAR*&gt;(pErrorMessage-&gt;GetBufferPointer()), "Error", MB_OK); else MessageBox(NULL, "vertexShader File Not Found", "Error", MB_OK); return hr; &#125; hr = D3DX11CompileFromFile(pixelShaderPath, nullptr, nullptr, "main", "ps_5_0", D3DCOMPILER_STRIP_DEBUG_INFO, 0, nullptr, &amp;pPixelShaderBlob, &amp;pErrorMessage, nullptr); if (FAILED(hr)) &#123; if (pErrorMessage) MessageBox(NULL, static_cast&lt;CHAR*&gt;(pErrorMessage-&gt;GetBufferPointer()), "Error", MB_OK); else MessageBox(NULL, "pixelShader File Not Found", "Error", MB_OK); return hr; &#125; hr = (*pDevice)-&gt;CreateVertexShader(pVertexShaderBlob-&gt;GetBufferPointer(), pVertexShaderBlob-&gt;GetBufferSize(), nullptr, &amp;pVertexShaderObject); if (FAILED(hr)) &#123; MessageBox(NULL, "ERROR::CreateVertexShader", "Error", MB_OK); return hr; &#125; hr = (*pDevice)-&gt;CreatePixelShader(pPixelShaderBlob-&gt;GetBufferPointer(), pPixelShaderBlob-&gt;GetBufferSize(), nullptr, &amp;pPixelShaderObject); if (FAILED(hr)) &#123; MessageBox(NULL, "ERROR::CreatePixelShader", "Error", MB_OK); return hr; &#125; D3D11_SAMPLER_DESC samplerDesc; samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR; samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP; samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP; samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP; samplerDesc.MipLODBias = 0.0f; samplerDesc.MaxAnisotropy = 1; samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS; samplerDesc.BorderColor[0] = 0; samplerDesc.BorderColor[1] = 0; samplerDesc.BorderColor[2] = 0; samplerDesc.BorderColor[3] = 0; samplerDesc.MinLOD = 0; samplerDesc.MaxLOD = D3D11_FLOAT32_MAX; hr = (*pDevice)-&gt;CreateSamplerState(&amp;samplerDesc, &amp;pSamplerState); if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateSampler", "Error", MB_OK); return hr; &#125; hr = D3DX11CreateShaderResourceViewFromFile(*pDevice, texturePaths[0].c_str() , nullptr, nullptr, &amp;pShaderResourceView, nullptr); if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateShaderResourceView", "Error", MB_OK); return hr; &#125; D3D11_INPUT_ELEMENT_DESC layout[] = &#123; &#123; "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 &#125; , &#123; "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 &#125; , &#123; "NORMAL", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 &#125; &#125;; hr = (*pDevice)-&gt;CreateInputLayout(layout, ARRAYSIZE(layout), pVertexShaderBlob-&gt;GetBufferPointer(), pVertexShaderBlob-&gt;GetBufferSize(), &amp;pInputLayout); if (FAILED(hr)) &#123; MessageBox(NULL, "ERROR::CreateInputLayout", "Error", MB_OK); return hr; &#125; pVertexShaderBlob-&gt;Release(); pPixelShaderBlob-&gt;Release(); if (pErrorMessage) &#123; pErrorMessage-&gt;Release(); &#125;&#125; &emsp;&emsp;其实也就是将我们之前渲染的代码移进来了而已，其他的也差不多： 12345678910111213141516171819202122void Draw(ID3D11DeviceContext **pImmediateContext) &#123; UINT stride = sizeof(Vertex); UINT offset = 0; (*pImmediateContext)-&gt;IASetVertexBuffers(0, 1, &amp;pVertexBufferObject, &amp;stride, &amp;offset); (*pImmediateContext)-&gt;IASetIndexBuffer(pIndexBufferObject, DXGI_FORMAT_R32_UINT, 0); (*pImmediateContext)-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); (*pImmediateContext)-&gt;PSSetShaderResources(0, 1, &amp;pShaderResourceView); (*pImmediateContext)-&gt;PSSetSamplers(0, 1, &amp;pSamplerState); (*pImmediateContext)-&gt;VSSetShader(pVertexShaderObject, nullptr, 0); (*pImmediateContext)-&gt;PSSetShader(pPixelShaderObject, nullptr, 0); (*pImmediateContext)-&gt;IASetInputLayout(pInputLayout); (*pImmediateContext)-&gt;DrawIndexed(indexCount, 0, 0);&#125;void Release() &#123; delete[] vertices; vertices = 0; delete[] indices; indices = 0; pIndexBufferObject-&gt;Release(); pVertexBufferObject-&gt;Release();&#125; &emsp;&emsp;现在我们看看对于模型的读取： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vector&lt;Mesh&gt; LoadModelUsingAssimp(const char* path) &#123; Importer imp; const aiScene *scene = imp.ReadFile(path, aiProcess_GenNormals | aiProcess_Triangulate | aiProcess_FixInfacingNormals | aiProcess_FlipWindingOrder | aiProcess_GenUVCoords | aiProcess_FlipUVs); if (!scene) &#123; MessageBox(nullptr, "ERROR::ReadOBJ", "ERROR", MB_OK); return vector&lt;Mesh&gt;(); &#125; vector&lt;Mesh&gt; meshes(scene-&gt;mNumMeshes); for (unsigned i = 0; i &lt; scene-&gt;mNumMeshes ; ++i) &#123; auto &amp;mesh = meshes[i]; const auto aiMesh = scene-&gt;mMeshes[i]; mesh = Mesh(aiMesh-&gt;mNumVertices, aiMesh-&gt;mNumFaces * 3); for (size_t j = 0; j &lt; aiMesh-&gt;mNumVertices; ++j) &#123; mesh.vertices[j].pos = XMFLOAT3(aiMesh-&gt;mVertices[j].x, aiMesh-&gt;mVertices[j].y, aiMesh-&gt;mVertices[j].z); if (aiMesh-&gt;HasTextureCoords(0)) &#123; mesh.vertices[j].texcoord = XMFLOAT2(aiMesh-&gt;mTextureCoords[0][j].x, aiMesh-&gt;mTextureCoords[0][j].y); &#125; else &#123; mesh.vertices[j].texcoord = XMFLOAT2(0.0f, 0.0f); &#125; if (aiMesh-&gt;HasNormals()) &#123; mesh.vertices[j].normal = XMFLOAT3(aiMesh-&gt;mNormals[j].x, aiMesh-&gt;mNormals[j].y, aiMesh-&gt;mNormals[j].z); &#125; else &#123; mesh.vertices[j].normal = XMFLOAT3(0.0f, 0.0f, -1.0f); &#125; &#125; for (size_t j = 0; j &lt; aiMesh-&gt;mNumFaces; ++j) &#123; for (size_t l = 0; l &lt; aiMesh-&gt;mFaces[j].mNumIndices; ++l) &#123; mesh.indices[j * aiMesh-&gt;mFaces[j].mNumIndices + l] = aiMesh-&gt;mFaces[j].mIndices[l]; &#125; &#125; const auto material = scene-&gt;mMaterials[aiMesh-&gt;mMaterialIndex]; mesh.texturePaths = vector&lt;std::string&gt;(material-&gt;GetTextureCount(aiTextureType_DIFFUSE) , std::string("./Resources/Low-Poly\ Spider/textures/")); for (auto&amp; str : mesh.texturePaths) &#123; aiString aiStr; material-&gt;GetTexture(aiTextureType_DIFFUSE, 0, &amp;aiStr); str += aiStr.C_Str(); &#125; &#125; return meshes;&#125; &emsp;&emsp;在这里，我们并未将顶点和索引等数据扔到总数组里，而是创建了一个 Mesh 数组，为单个 Mesh 填充数据，包括纹理。（这里的纹理人家不是这么用的，只是我比较懒！！！） &emsp;&emsp;OK，现在可以调用这些方法了，首先填充 Mesh 数组和初始化每个 Mesh： 12vector&lt;Mesh&gt; meshes = LoadModelUsingAssimp("./Resources/Low-Poly\ Spider/spider.x");for (auto&amp; mesh : meshes) mesh.Init(&amp;pDevice , "./vertexShader.hlsl" , "./pixelShader.hlsl"); &emsp;&emsp;在消息循环里调用 Draw 方法： 1for (auto&amp; mesh : meshes) mesh.Draw(&amp;pImmediateContext); &emsp;&emsp;最终效果如下： &emsp;&emsp;源代码地址：DX11Tutorial-RenderMesh]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Champagne-Tower]]></title>
    <url>%2F2018%2F03%2F28%2FChampagne-Tower%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#799 Champagne Tower 题目描述&emsp;&emsp;We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup (250ml) of champagne. &emsp;&emsp;Then, some champagne is poured in the first glass at the top. When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has it’s excess champagne fall on the floor.) &emsp;&emsp;For example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below. Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.) 123456789Example 1:Input: poured = 1, query_glass = 1, query_row = 1Output: 0.0Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.Example 2:Input: poured = 2, query_glass = 1, query_row = 1Output: 0.5Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange. Note: poured will be in the range of [0, 10 ^ 9]. query_glass and query_row will be in the range of [0, 99]. 解题思路&emsp;&emsp;这道题可以使用 DP 求解，DP 每个单位保存的值为经过当前酒杯的酒熟练总合（留在当前酒杯的酒+从当前酒杯流下去的酒），所以递推公式为： dp_{[i][j]} = dp_{[i-1][j]} + dp_{[i-1][j+1]}解题代码12345678910111213141516171819class Solution &#123;public: double champagneTower(int poured, int query_row, int query_glass) &#123; vector&lt;vector&lt;double&gt;&gt; dp(0); for (int i = 0; i &lt; query_row+1; ++i) &#123; dp.push_back(vector&lt;double&gt;(i+1 , 0)); &#125; dp[0][0] = poured; for (int i = 1; i &lt;= query_row; ++i) &#123; for (int j = 0; j &lt; dp[i].size(); ++j) &#123; if (j &gt; 0) dp[i][j] += max(0.0 ,(dp[i-1][j-1] - 1)) / 2; if (j &lt; dp[i].size()-1) dp[i][j] += max(0.0 ,(dp[i-1][j] - 1) / 2); &#125; &#125; return min(1.0 , dp[query_row][query_glass]); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第N个数字（中国区试试水）]]></title>
    <url>%2F2018%2F03%2F27%2F%E7%AC%ACN%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%AD%E5%9B%BD%E5%8C%BA%E8%AF%95%E8%AF%95%E6%B0%B4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天中午提交申请转移到中国区，今天下午就发邮件提示成功了，来试试水。不过感觉有点坑啊，后悔了。。。 题目地址LeetCode#400 第N个数字 题目描述&emsp;&emsp;在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。 注意:n 是正数且在32为整形范围内 ( n &lt; 231)。 示例 1: 12345输入:3输出:3 示例 2: 12345678输入:11输出:0说明:第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。 解题思路&emsp;&emsp;这道题意思是把数字当字符串来处理，比如 12 相当于两个字符，最后查找第 N 个数字值。 &emsp;&emsp;我们可以很简单的想到，数字为 1 位的共有 9 个，数字为 2 位的有 90 个，3 位的有 900 个。所以可以先行判断数字落到的区间，最后查值就可以了。 解题代码123456789101112131415class Solution &#123;public: int findNthDigit(int n) &#123; long long len = 1, cnt = 9, start = 1; while (n &gt; len * cnt) &#123; n -= len * cnt; ++len; cnt *= 10; start *= 10; &#125; start += (n - 1) / len; string t = to_string(start); return t[(n - 1) % len] - '0'; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】13-Assimp库]]></title>
    <url>%2F2018%2F03%2F27%2F%E3%80%90DirectX%E3%80%9113-Assimp%E5%BA%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中，我们将使用 Assimp 库导入一个 3D 模型。 &emsp;&emsp;在以往的代码中，我们使用硬编码来定义顶点坐标，可以很简单的输出一些顶点较少的模型，但是当某个模型比较复杂的时候，这样做就显得不太现实了。所以一般情况下我们是在 3D 建模工具下建模，然后导出为模型文件，通过代码导入。这篇文章便来介绍 Assimp 在 DX 下的使用。 &emsp;&emsp;关于 Mesh 的介绍可以看这里：杂杂碎碎的常识第二弹-网格与模型 &emsp;&emsp;关于 Assimp 的介绍可以看这里：【OpenGL】12-模型与Assimp库 &emsp;&emsp;在这次的代码中，我们并不会去和 OpenGL 中一样建立类来对网格等数据结构进行组织，以网格为单元来渲染。我们简单的使用 Assimp 读取模型文件后，将其顶点和索引提取出来放在数组里，使用我们之前比较熟悉的代码来渲染。 &emsp;&emsp;首先定义一个 Vertex 数组（和我们之前的一样）。 123456struct Vertex&#123; XMFLOAT3 pos; XMFLOAT2 texcoord; XMFLOAT3 normal;&#125;; &emsp;&emsp;现在，我们使用 Assimp 库来读取模型： 123456Importer imp;const aiScene *scene = imp.ReadFile("model.x", aiProcess_GenNormals | aiProcess_Triangulate | aiProcess_FixInfacingNormals | aiProcess_FlipWindingOrder );if (!scene) &#123; MessageBox(nullptr, "ERROR::ReadOBJ", "ERROR", MB_OK); return -1;&#125; &emsp;&emsp;如果你不太清楚这个 aiScene 对象的结构的话，可以去看上边关于 Assimp 介绍的链接。 &emsp;&emsp;接下来，我们定义两个 int 数据来表示顶点和索引的个数： 12int vertexCount = 0;int indexCount = 0; &emsp;&emsp;下来是对 scene 对象的第一次遍历，用来获取 scene 中所有 Mesh 对象的顶点和索引之和： 1234for (unsigned i = 0; i &lt; scene-&gt;mNumMeshes; ++i) &#123; vertexCount += scene-&gt;mMeshes[i]-&gt;mNumVertices; indexCount += scene-&gt;mMeshes[i]-&gt;mNumFaces * scene-&gt;mMeshes[i]-&gt;mFaces-&gt;mNumIndices;&#125; &emsp;&emsp;现在我们可以创建顶点和索引数组了： 12auto *vertices = new Vertex[vertexCount];auto *indices = new UINT[indexCount]; &emsp;&emsp;接下来，我们第二次遍历 scene 对象，为我们的顶点数组和索引数组填充数据： 12345678910111213141516171819202122232425UINT idx1 = 0, idx2 = 0;for (unsigned i = 0; i &lt; scene-&gt;mNumMeshes; ++i) &#123; const auto mesh = scene-&gt;mMeshes[i]; for (unsigned j = 0; j &lt; mesh-&gt;mNumVertices; ++j) &#123; vertices[idx1].pos = XMFLOAT3(mesh-&gt;mVertices[j].x, mesh-&gt;mVertices[j].y, mesh-&gt;mVertices[j].z); if (mesh-&gt;HasNormals()) &#123; vertices[idx1].normal = XMFLOAT3(mesh-&gt;mNormals[j].x, mesh-&gt;mNormals[j].y, mesh-&gt;mNormals[j].z); &#125; else &#123; vertices[idx1].normal = XMFLOAT3(0.0f, 0.0f, 1.0f); &#125; if (mesh-&gt;HasTextureCoords(j)) &#123; vertices[idx1].texcoord = XMFLOAT2(mesh-&gt;mTextureCoords[j]-&gt;x, mesh-&gt;mTextureCoords[j]-&gt;y); &#125; else &#123; vertices[idx1].texcoord = XMFLOAT2(0.0f, 0.0f); &#125; ++idx1; &#125; for (unsigned j = 0; j &lt; mesh-&gt;mNumFaces; ++j) &#123; assert(mesh-&gt;mFaces[j].mNumIndices == 3); indices[idx2++] = mesh-&gt;mFaces[j].mIndices[0]; indices[idx2++] = mesh-&gt;mFaces[j].mIndices[1]; indices[idx2++] = mesh-&gt;mFaces[j].mIndices[2]; &#125;&#125; &emsp;&emsp;上边这一段中，我们首先遍历所有 Mesh ，然后对每个 Mesh 执行以下操作： 获取 Mesh 的顶点数组，并将其保存到我们的顶点数组中。 获取 Mesh 的 Face 数组，并将构成其的索引保存到我们的索引数组中。 &emsp;&emsp;之后的创建缓冲等操作和之前就是完全一样了。我在我的代码中导入了一个蜘蛛的模型，下来看看效果： &emsp;&emsp;貌似还不错吧。 &emsp;&emsp;程序源码地址：DX11Tutorial-UsingAssimp]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】12-HLSL实现漫反射光照]]></title>
    <url>%2F2018%2F03%2F27%2F%E3%80%90DirectX%E3%80%9112-HLSL%E5%AE%9E%E7%8E%B0%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中，我们将实现在 HLSL 下的漫反射光照绘制。漫反射的原理我们在 OpenGL 学习笔记中已经详细提及，这里就省下篇幅了。 &emsp;&emsp;首先我们修改之前的立方体代码来给漫反射光照做准备。我们将绘制一个缓慢转动的立方体模型并为他贴图，然后我们需要一个光源，使用一个比较小的白色立方体代替。 &emsp;&emsp;重新定义顶点数据结构： 123456struct Vertex&#123; XMFLOAT3 pos; XMFLOAT2 texcoord; XMFLOAT3 normal; // 计算漫反射光需要用到法线&#125;; &emsp;&emsp;之后，我们更改立方体的顶点（由于法线的原因，导致我们会将顶点的个数扩展到24个），并且更新索引： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 Vertex vertices[] = &#123; // 正面 &#123; XMFLOAT3(-0.5f, -0.5f, -0.5f), XMFLOAT2(0, 1) , XMFLOAT3(0.0f , 0.0f , -1.0f)&#125;, &#123; XMFLOAT3(-0.5f, +0.5f, -0.5f), XMFLOAT2(0, 0) , XMFLOAT3(0.0f , 0.0f , -1.0f)&#125;, &#123; XMFLOAT3(+0.5f, +0.5f, -0.5f), XMFLOAT2(1, 0) , XMFLOAT3(0.0f , 0.0f , -1.0f)&#125;, &#123; XMFLOAT3(+0.5f, -0.5f, -0.5f), XMFLOAT2(1, 1) , XMFLOAT3(0.0f , 0.0f , -1.0f)&#125;, // 背面 &#123; XMFLOAT3(-0.5f, -0.5f, +0.5f), XMFLOAT2(1, 1) , XMFLOAT3(0.0f , 0.0f , +1.0f)&#125;, &#123; XMFLOAT3(-0.5f, +0.5f, +0.5f), XMFLOAT2(1, 0) , XMFLOAT3(0.0f , 0.0f , +1.0f)&#125;, &#123; XMFLOAT3(+0.5f, +0.5f, +0.5f), XMFLOAT2(0, 0) , XMFLOAT3(0.0f , 0.0f , +1.0f)&#125;, &#123; XMFLOAT3(+0.5f, -0.5f, +0.5f), XMFLOAT2(0, 1) , XMFLOAT3(0.0f , 0.0f , +1.0f)&#125;, // 上面 &#123; XMFLOAT3(-0.5f, +0.5f, -0.5f), XMFLOAT2(0, 1) , XMFLOAT3(0.0f , +1.0f , 0.0f)&#125;, &#123; XMFLOAT3(-0.5f, +0.5f, +0.5f), XMFLOAT2(0, 0) , XMFLOAT3(0.0f , +1.0f , 0.0f)&#125;, &#123; XMFLOAT3(+0.5f, +0.5f, +0.5f), XMFLOAT2(1, 0) , XMFLOAT3(0.0f , +1.0f , 0.0f)&#125;, &#123; XMFLOAT3(+0.5f, +0.5f, -0.5f), XMFLOAT2(1, 1) , XMFLOAT3(0.0f , +1.0f , 0.0f)&#125;, // 下面 &#123; XMFLOAT3(-0.5f, -0.5f, -0.5f), XMFLOAT2(1, 1) , XMFLOAT3(0.0f , -1.0f , 0.0f)&#125;, &#123; XMFLOAT3(-0.5f, -0.5f, +0.5f), XMFLOAT2(1, 0) , XMFLOAT3(0.0f , -1.0f , 0.0f)&#125;, &#123; XMFLOAT3(+0.5f, -0.5f, +0.5f), XMFLOAT2(0, 0) , XMFLOAT3(0.0f , -1.0f , 0.0f)&#125;, &#123; XMFLOAT3(+0.5f, -0.5f, -0.5f), XMFLOAT2(0, 1) , XMFLOAT3(0.0f , -1.0f , 0.0f)&#125;, // 左侧 &#123; XMFLOAT3(-0.5f, -0.5f, +0.5f), XMFLOAT2(0, 1) , XMFLOAT3(-1.0f , 0.0f , 0.0f)&#125;, &#123; XMFLOAT3(-0.5f, +0.5f, +0.5f), XMFLOAT2(0, 0) , XMFLOAT3(-1.0f , 0.0f , 0.0f)&#125;, &#123; XMFLOAT3(-0.5f, +0.5f, -0.5f), XMFLOAT2(1, 0) , XMFLOAT3(-1.0f , 0.0f , 0.0f)&#125;, &#123; XMFLOAT3(-0.5f, -0.5f, -0.5f), XMFLOAT2(1, 1) , XMFLOAT3(-1.0f , 0.0f , 0.0f)&#125;, // 右侧 &#123; XMFLOAT3(+0.5f, -0.5f, -0.5f), XMFLOAT2(0, 1) , XMFLOAT3(+1.0f , 0.0f , 0.0f)&#125;, &#123; XMFLOAT3(+0.5f, +0.5f, -0.5f), XMFLOAT2(0, 0) , XMFLOAT3(+1.0f , 0.0f , 0.0f)&#125;, &#123; XMFLOAT3(+0.5f, +0.5f, +0.5f), XMFLOAT2(1, 0) , XMFLOAT3(+1.0f , 0.0f , 0.0f)&#125;, &#123; XMFLOAT3(+0.5f, -0.5f, +0.5f), XMFLOAT2(1, 1) , XMFLOAT3(+1.0f , 0.0f , 0.0f)&#125;, &#125;;UINT indices[] = &#123; // 前 0, 1, 2, 0, 2, 3, // 后 4, 6, 5, 4, 7, 6, // 左 16, 17, 18, 16, 18, 19, // 右 20, 21, 22, 20, 22, 23, // 上 8, 9, 10, 8, 10, 11, // 下 12, 14, 13, 12, 15, 14 &#125;; &emsp;&emsp;这是我们绘制立方体的时候使用的新的数据（具体绘制过程有兴趣的可以去看源码），由于我们需要绘制光源，所以需要简单的光源立方体使用的着色器程序，如下： 12345678910111213141516171819202122// lightVertexShader.hlslcbuffer ConstantBuffer : register(b0) &#123; matrix world; matrix view; matrix projection;&#125;float4 main( float4 pos : POSITION ) : SV_POSITION&#123; pos = mul(pos , world); pos = mul(pos , view); pos = mul(pos , projection); return pos;&#125;//lightPixelShader.hlslstruct pixelInputType &#123; float4 pos : SV_POSITION;&#125;;float4 main(float4 pos : SV_POSITION) : SV_TARGET&#123; return float4(1.0f,1.0f,1.0f,1.0f);&#125; &emsp;&emsp;现在，进行绘制，同时使用 XMMatrixRotation 方法使其旋转： 123456789101112131415161718cubeWorld = cubeWorld * XMMatrixRotationX(0.0001f) * XMMatrixRotationY(0.0001f) * XMMatrixRotationZ(0.0001f);cb.world = XMMatrixTranspose(cubeWorld);pImmediateContext-&gt;UpdateSubresource(pConstantBuffer, 0, nullptr, &amp;cb, 0, 0);pImmediateContext-&gt;VSSetConstantBuffers(0, 1, &amp;pConstantBuffer);pImmediateContext-&gt;PSSetShaderResources(0, 1, &amp;pShaderResourceView);pImmediateContext-&gt;PSSetSamplers(0, 1, &amp;pSamplerState);pImmediateContext-&gt;IASetInputLayout(pCubeInputLayout);pImmediateContext-&gt;VSSetShader(pCubeVertexShader, nullptr, 0);pImmediateContext-&gt;PSSetShader(pCubePixelShader, nullptr, 0);pImmediateContext-&gt;DrawIndexed(36, 0, 0);cb.world = XMMatrixTranspose(lightWorld * XMMatrixTranslation(0.0f, 3.0f, 0.0f));pImmediateContext-&gt;UpdateSubresource(pConstantBuffer, 0, nullptr, &amp;cb, 0, 0);pImmediateContext-&gt;VSSetConstantBuffers(0, 1, &amp;pConstantBuffer);pImmediateContext-&gt;IASetInputLayout(pLightInputLayout);pImmediateContext-&gt;VSSetShader(pLightVertexShader, nullptr, 0);pImmediateContext-&gt;PSSetShader(pLightPixelShader, nullptr, 0);pImmediateContext-&gt;DrawIndexed(36, 0, 0); &emsp;&emsp;现在你应该看到的是一个旋转的立方体和一个在立方体上方的光源，如下： &emsp;&emsp;接下来就是 HLSL 中的代码了。首先修改顶点着色器的数据结构： 123456789101112struct vertexInputType &#123; float4 pos : POSITION; float2 texcoord : TEXCOORD0; float3 normal : NORMAL;&#125;;struct pixelInputType &#123; float4 pos : SV_POSITION; float4 posw : POSITION1; // 使用这个坐标来计算光方向向量 float2 texcoord : TEXCOORD0; float3 normal : NORMAL;&#125;; &emsp;&emsp;同时在对顶点着色器中变换坐标的同时也变换法线坐标： 12345678910pixelInputType main( vertexInputType input )&#123; pixelInputType output; output.pos = input.pos; output.pos = mul(output.pos , world); output.pos = mul(output.pos , view); output.pos = mul(output.pos , projection); output.texcoord = input.texcoord; output.normal = mul(input.normal , (float3x3)world); // normal return output;&#125; &emsp;&emsp;有了法线之后，我们可以在像素着色器中根据法线与光照方向的夹角 cos 值来计算颜色了。首先我们使用硬编码写好光源位置和环境光大小： 12float ambient = 0.1f;float3 lightPos = float3(0.0f, 3.0f, 0.0f); &emsp;&emsp;之后计算光照方向： 1float3 lightDir = - lightPos; &emsp;&emsp;最后，使用光照方向的反向量来和法线向量点乘获得 cos 值： 1float diffuse = saturate(dot(normalize(input.normal), normalize(-lightDir))); // staturate 将其值限制在 0 1 区间内 &emsp;&emsp;配合纹理颜色和环境光颜色来计算最终颜色： 1return tex.Sample(samp , input.texcoord) * (ambient + diffuse); &emsp;&emsp;最终效果如下： &emsp;&emsp;源代码地址：DX11Tutorial DiffuseLighting]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary-Tree-Level-Order-Traversal-II]]></title>
    <url>%2F2018%2F03%2F27%2FBinary-Tree-Level-Order-Traversal-II%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#107 Binary Tree Level Order Traversal II &emsp;&emsp;简直了，今天一进 LeetCode 网站，就弹出提示让我迁移到 LeetCode 国区，没想到竟然有中文版了？？？（而且中文版名字贼丑，力扣）是不是这是最后一个在 LeetCode 外区做的题了？ 题目描述&emsp;&emsp;Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] 解题思路&emsp;&emsp;这道题就是换了个存储方法而已，和之前的那道 Binary Tree Level Order Traversal没啥区别。 解题代码123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res(0); if(!root) return res; res.insert(res.begin(),vector&lt;int&gt;(0)); queue&lt;TreeNode*&gt; q; q.push(root); q.push(nullptr); while (q.size() &gt; 1)&#123; auto p = q.front(); q.pop(); if (!p) &#123; res.insert(res.begin(), vector&lt;int&gt;(0)); q.push(nullptr); &#125; else &#123; if(p-&gt;left) q.push(p-&gt;left); if(p-&gt;right) q.push(p-&gt;right); res[0].push_back(p-&gt;val); &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】11-3DRender]]></title>
    <url>%2F2018%2F03%2F26%2F%E3%80%90DirectX%E3%80%9111-3DRender%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 7: 3D Model Rendering 学习记录&emsp;&emsp;渲染 3D 图形的话和 2D 视角不同，我们必须使用 3D 摄像机视角，如果对摄像机以及矩阵作用不太懂的话可以看这里：【OpenGL】10-摄像机 。 &emsp;&emsp;首先我们先渲染出来一个三角形，修改顶点以及使用索引绘制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct Vertex&#123; XMFLOAT3 pos; XMFLOAT4 color;&#125;;///////////// Vertex ////////////////////////////Vertex vertices[] =&#123; &#123; XMFLOAT3(-0.5f, -0.5f, -0.5f), XMFLOAT4(0, 0, 1, 1) &#125;, &#123; XMFLOAT3(-0.5f, +0.5f, -0.5f), XMFLOAT4(0, 0, 0, 1) &#125;, &#123; XMFLOAT3(+0.5f, +0.5f, -0.5f), XMFLOAT4(1, 0, 0, 1) &#125;, &#123; XMFLOAT3(+0.5f, -0.5f, -0.5f), XMFLOAT4(0, 1, 0, 1) &#125;, &#123; XMFLOAT3(-0.5f, -0.5f, +0.5f), XMFLOAT4(0, 0, 1, 1) &#125;, &#123; XMFLOAT3(-0.5f, +0.5f, +0.5f), XMFLOAT4(1, 1, 0, 1) &#125;, &#123; XMFLOAT3(+0.5f, +0.5f, +0.5f), XMFLOAT4(0, 1, 1, 1) &#125;, &#123; XMFLOAT3(+0.5f, -0.5f, +0.5f), XMFLOAT4(1, 0, 1, 1) &#125;&#125;;D3D11_BUFFER_DESC vertexBufferDesc;ZeroMemory(&amp;vertexBufferDesc, sizeof(vertexBufferDesc));vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;vertexBufferDesc.ByteWidth = sizeof(Vertex) * 8;vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;D3D11_SUBRESOURCE_DATA verticesSourceData;ZeroMemory(&amp;verticesSourceData, sizeof(D3D11_SUBRESOURCE_DATA));verticesSourceData.pSysMem = vertices;ID3D11Buffer *pVertexBufferObject = nullptr;pDevice-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;verticesSourceData, &amp;pVertexBufferObject);UINT stride = sizeof(Vertex);UINT offset = 0;pImmediateContext-&gt;IASetVertexBuffers(0, 1, &amp;pVertexBufferObject, &amp;stride, &amp;offset);pImmediateContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);///////////////////////// index /////////////////////////////UINT indices[] = &#123; 0, 1, 2, 0, 2, 3, 4, 6, 5, 4, 7, 6, 4, 5, 1, 4, 1, 0, 3, 2, 6, 3, 6, 7, 1, 5, 6, 1, 6, 2, 4, 0, 3, 4, 3, 7&#125;;D3D11_BUFFER_DESC indexDesc;ZeroMemory(&amp;indexDesc, sizeof(indexDesc));indexDesc.Usage = D3D11_USAGE_IMMUTABLE;indexDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;indexDesc.ByteWidth = sizeof(UINT)* 36;D3D11_SUBRESOURCE_DATA indexData;ZeroMemory(&amp;indexData, sizeof(indexData));indexData.pSysMem = indices;ID3D11Buffer *pIndexBufferObject = nullptr;hr = pDevice-&gt;CreateBuffer(&amp;indexDesc, &amp;indexData, &amp;pIndexBufferObject);if (FAILED(hr))&#123; return false;&#125;pImmediateContext-&gt;IASetIndexBuffer(pIndexBufferObject, DXGI_FORMAT_R32_UINT , 0); &emsp;&emsp;然后修改消息循环里的绘制方法为：pImmediateContext-&gt;DrawIndexed(36, 0 , 0); 。 &emsp;&emsp;现在创建我们的 world view projection 三个矩阵，首先定义结构体： 12345struct Constant &#123; XMMATRIX world; XMMATRIX view; XMMATRIX projection;&#125;; &emsp;&emsp;我们使用 DX 中提供的几个方法来创建这个三个矩阵： 123456789Constant cb = &#123; XMMatrixTranspose(XMMatrixIdentity()) , XMMatrixTranspose(XMMatrixLookAtLH( XMVectorSet(0.0f, 1.0f, -1.0f, 0.0f), XMVectorSet(0.0f, 0.0f, 0.0f, 0.0f), XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f) )), XMMatrixTranspose(XMMatrixPerspectiveFovLH(90, static_cast&lt;FLOAT&gt;(width) / height, 0.1f, 100.0f))&#125;; &emsp;&emsp;这里我直接将这些放在了一块创建了结构体，分开写是这样： 1234567891011121314151617Constant cb;auto world = DirectX::XMMatrixIdentity();auto View = DirectX::XMMatrixLookAtLH( DirectX::XMVectorSet(0.0f, 1.0f, -1.0f, 0.0f), // Eye DirectX::XMVectorSet(0.0f, 0.0f, 0.0f, 0.0f), // Focus DirectX::XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f) // Up );auto projection = DirectX::XMMatrixPerspectiveFovLH(90, static_cast&lt;FLOAT&gt;(width) / height, 0.1f, 100.0f);cb.world = world;cb.view = view;cb.projection = projection;cb.world = DirectX::XMMatrixTranspose(cb.world);cb.view = DirectX::XMMatrixTranspose(cb.view);cb.projection = DirectX::XMMatrixTranspose(cb.projection); &emsp;&emsp;（是不是和 opengl 很像） &emsp;&emsp;之后，我们创建 Constant 的缓冲对象并且创建好缓冲： 12345678910111213141516D3D11_BUFFER_DESC constantBufferDesc;ZeroMemory(&amp;constantBufferDesc, sizeof(constantBufferDesc));constantBufferDesc.Usage = D3D11_USAGE_DEFAULT;constantBufferDesc.BindFlags = D3D10_BIND_CONSTANT_BUFFER;constantBufferDesc.ByteWidth = sizeof(Constant);D3D11_SUBRESOURCE_DATA constantSourceData;ZeroMemory(&amp;constantSourceData, sizeof(D3D11_SUBRESOURCE_DATA));constantSourceData.pSysMem = &amp;cb;ID3D11Buffer *pConstantBuffer = nullptr;hr = pDevice-&gt;CreateBuffer(&amp;constantBufferDesc, &amp;constantSourceData, &amp;pConstantBuffer);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateConstantBuffer", "ERROR", MB_OK); return hr;&#125; &emsp;&emsp;设置设备上下文： 1pImmediateContext-&gt;VSSetConstantBuffers(0, 1, &amp;pConstantBuffer); &emsp;&emsp;在 DX 代码里需要修改的内容差不多就这些了，接下来看看 HLSL 代码，在顶点着色器里我们需要对 POSITION 来乘这三个矩阵，首先定义一个全局变量： 12345cbuffer ConstantBuffer : register(b0) &#123; matrix world; matrix view; matrix projection;&#125; &emsp;&emsp;在 main 函数里相乘： 12345678910pixelInputType main( vertexInputType input )&#123; pixelInputType output; output.pos = input.pos; output.pos = mul(output.pos , world); output.pos = mul(output.pos , view); output.pos = mul(output.pos , projection); output.color = input.color; return output;&#125; &emsp;&emsp;接下来运行程序，应该可以看到这个： &emsp;&emsp;源代码在这里：DX11Tutorial-3DRender]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chunks-To-Make-Sorted-II]]></title>
    <url>%2F2018%2F03%2F26%2FChunks-To-Make-Sorted-II%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#768 Max Chunks To Make Sorted II 题目描述&emsp;&emsp;This question is the same as “Max Chunks to Make Sorted” except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8. &emsp;&emsp;Given an array arr of integers (not necessarily distinct), we split the array into some number of “chunks” (partitions), and individually sort each chunk. After concatenating them, the result equals the sorted array. &emsp;&emsp;What is the most number of chunks we could have made? Example 1: 12345Input: arr = [5,4,3,2,1]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn&apos;t sorted. Example 2: 12345Input: arr = [2,1,3,4,4]Output: 4Explanation:We can split into two chunks, such as [2, 1], [3, 4, 4].However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible. Note: arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8]. 解题思路&emsp;&emsp;题目要求我们将给定数组分块，满足每一块内部排序后连接在一起总数组有序。也就是说满足第 N 个块的最小数据大于第 N-1 块的最大数据。 &emsp;&emsp;我们维护一个当前块的最大值索引位置，然后遍历数组，当遍历到的数字大于当前最大的时候，我们遍历它后边的所有数字，只有后边的所有数字都大于我们所保存的当前最大值的时候，才可以算作新的块。可以给 chunkCount 加一。 &emsp;&emsp;可以优化的部分是当在后边能找到比保存的当前最大值小的数字时，我们可以更新保存的当前最大值，同时更新遍历的索引 i 。 解题代码123456789101112131415161718192021222324252627class Solution &#123;public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) &#123; if (arr.empty()) return 0; int chunkCount = 1; int chunkMaxIdx = 0; for (int i = 1; i &lt; arr.size(); ++i) &#123; if (arr[i] &gt;= arr[chunkMaxIdx])&#123; int tMax = chunkMaxIdx; int j = i; for (; j &lt; arr.size(); ++j) &#123; if (arr[j] &gt; arr[tMax]) tMax = j; if (arr[j] &lt; arr[chunkMaxIdx])&#123; chunkMaxIdx = tMax; i = j; break; &#125; &#125; if( j == arr.size() ) &#123; chunkCount++; chunkMaxIdx = i; &#125; &#125; &#125; return chunkCount; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lexicographical-Numbers]]></title>
    <url>%2F2018%2F03%2F25%2FLexicographical-Numbers%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#386 Lexicographical Numbers 题目描述&emsp;&emsp;Given an integer n, return 1 - n in lexicographical order. &emsp;&emsp;For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9]. &emsp;&emsp;Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000. 解题思路&emsp;&emsp;要求按照字典顺序对从 0-n 的数字进行排序，我试了一下先生成数字然后用 sort() 但是直接 TEL 了，所以只能在生成数字的时候就有序。那么就直接递归进行生成数字。 解题代码12345678910111213141516class Solution &#123; void addNumber(int num, int target, vector&lt;int&gt; &amp;res) &#123; if (num &gt; target) return; res.push_back(num); addNumber(num * 10, target, res); if (num % 10 == 9) return; addNumber(num + 1, target, res); &#125;public: vector&lt;int&gt; lexicalOrder(int n) &#123; vector&lt;int&gt; res(0); addNumber(1 , n , res); return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】10-纹理]]></title>
    <url>%2F2018%2F03%2F25%2F%E3%80%90DirectX%E3%80%9110-%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;这篇文章开始不再以教程中的框架代码为示例，因为我发现本身在学习 DirectX 基本语法当中，多写几遍能加深印象是其一，其二是对那些 API 理解并非太深刻的时候实现较为复杂的内容的时候会导致难以去 Debug ，同时也丧失了基本的学习效果。 前置内容&emsp;&emsp;我们使用我们之前做过的简单的三角形那个例子，将其代码拷贝过来（再写一遍最好，虽然说写重复代码比较愚蠢，但是蠢有蠢的好处），用来实现这篇文章要实现的内容。 &emsp;&emsp;我们这篇文章将学习纹理的用法，之后在我们之前的纯色三角形上贴一张好看图片 教程地址Tutorial 5: Texturing 学习记录&emsp;&emsp;纹理（Texture）的概念我想就不用介绍了，在 OpenGL 中我们使用过很多次。这篇文章主要是介绍 DX 中纹理的加载操作。首先我们修改着色器程序： 123456789101112131415161718// file : triangleVertexShader.hlslstruct vertexInputType &#123; float4 pos : POSITION; float2 texcoord : TEXCOORD0;&#125;;struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD0;&#125;;pixelInputType main( vertexInputType input )&#123; pixelInputType output; output.pos = input.pos; output.texcoord = input.texcoord; return output;&#125; &emsp;&emsp;我们在顶点着色器中定义了结构体用于传递数据，结构体包括 position 和 texcoord 数据（即 UV 坐标）。 &emsp;&emsp;在像素着色器中，我们定义了 Texture2D 变量和 SamplerState 采样器变量，用于从纹理上采样颜色。 12345678910111213// file: trianglePixelShader.hlslTexture2D tex;SamplerState samplerType; struct pixelInputType &#123; float4 pos : SV_POSITION; float2 texcoord : TEXCOORD0;&#125;;float4 main(pixelInputType input) : SV_TARGET&#123; return tex.Sample(samplerType, input.texcoord);&#125; &emsp;&emsp;而在 DX 代码中，我们首先修改 Vertex 结构体和顶点坐标集合，现在 Vertex 结构体应当包含一个 UV 坐标： 1234567891011struct Vertex &#123; DirectX::XMFLOAT3 pos; DirectX::XMFLOAT2 tex;&#125;;Vertex vertices[] =&#123; &#123; DirectX::XMFLOAT3(0.0f, 0.5f, 0.5f) , DirectX::XMFLOAT2(0.0f,1.0f) &#125;, &#123; DirectX::XMFLOAT3(0.5f, -0.5f, 0.5f) , DirectX::XMFLOAT2(1.0f,-1.0f) &#125;, &#123; DirectX::XMFLOAT3(-0.5f, -0.5f, 0.5f) , DirectX::XMFLOAT2(-1.0f,1.0f) &#125;&#125;; &emsp;&emsp;现在创建一个采样器描述并为他赋值： 1234567891011121314D3D11_SAMPLER_DESC samplerDesc;samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;samplerDesc.MipLODBias = 0.0f;samplerDesc.MaxAnisotropy = 1;samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;samplerDesc.BorderColor[0] = 0;samplerDesc.BorderColor[1] = 0;samplerDesc.BorderColor[2] = 0;samplerDesc.BorderColor[3] = 0;samplerDesc.MinLOD = 0;samplerDesc.MaxLOD = D3D11_FLOAT32_MAX; &emsp;&emsp;关于这个结构体的各个属性可以看 MSDN 。（我懒） &emsp;&emsp;使用采样器描述创建一个指针对象： 123456ID3D11SamplerState *pSamplerState = nullptr;hr = pDevice-&gt;CreateSamplerState(&amp;samplerDesc, &amp;pSamplerState);if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateSampler", "Error", MB_OK); return hr;&#125; &emsp;&emsp;从文件创建一个渲染视图： 123456ID3D11ShaderResourceView *pShaderResourceView;hr = D3DX11CreateShaderResourceViewFromFile(pDevice, "./triangle.jpg", nullptr, nullptr, &amp;pShaderResourceView, nullptr); if (FAILED(hr)) &#123; MessageBox(nullptr, "ERROR::CreateShaderResourceView", "Error", MB_OK); return hr; &#125; &emsp;&emsp;为立即上下文对象赋值渲染视图和采样器： 12pImmediateContext-&gt;PSSetShaderResources(0, 1, &amp;pShaderResourceView);pImmediateContext-&gt;PSSetSamplers(0, 1, &amp;pSamplerState); &emsp;&emsp;这时，我们还需要修改布局描述： 1234D3D11_INPUT_ELEMENT_DESC layout[] = &#123; &#123; "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 &#125; , &#123; "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 &#125; &#125;; &emsp;&emsp;在 POSITION 的基础上我们需要添加一个 TEXCOORD ，其他的代码都不需要修改，现在点击运行，就可以看到我们的三角形了。 &emsp;&emsp;完整代码请看：Github : DX11Tutorial texture triangle]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】9-代码框架-CModel和CCamera]]></title>
    <url>%2F2018%2F03%2F25%2F%E3%80%90DirectX%E3%80%919-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-CModel%E5%92%8CCCamera%2F</url>
    <content type="text"><![CDATA[教程地址教程 4: 缓冲区、着色器和 HLSL 学习记录&emsp;&emsp;这篇文章中，我们将更新我们框架代码中的 CModel 和 CCamera 。前者用来描绘我们世界坐标系空间中的某个物体，而后者则描述我们的摄像机，则我们的观察者。 &emsp;&emsp;之后我们的框架将会变为这样（是很丑，但我懒得再去画了！）： &emsp;&emsp;先来看看 CModel 类，这个类描述了我们的一个实体模型，并提供了渲染接口，他的声明如下： 12345678910111213141516171819202122232425class CModel &#123;private: struct Vertex &#123; DirectX::XMFLOAT3 position; DirectX::XMFLOAT3 color; &#125;;public: CModel(); CModel(CModel&amp; cm); ~CModel(); bool Initialize(ID3D11Device*); void Shutdown(); void Render(ID3D11DeviceContext*); int GetIndexCount();private: bool InitializeModel(ID3D11Device*); void ShutdownModel(); void RenderModel(ID3D11DeviceContext*); ID3D11Buffer *mVertexBuffer_&#123;&#125;, *mIndexBuffer_&#123;&#125;; int mVertexCount&#123;&#125;, mIndexCount&#123;&#125;;&#125;; &emsp;&emsp;这些都是比较简单能理解的，在初始化和销毁的函数里，我们对几个成员变量进行初始化和销毁操作。而公开接口里都是直接调用私有函数，如下： 12345678910111213141516171819202122232425CModel::CModel() : mVertexBuffer_(nullptr), mIndexBuffer_(nullptr), mVertexCount(0), mIndexCount(0) &#123;&#125;CModel::CModel(CModel&amp; cm) &#123; *this = cm;&#125;CModel::~CModel() = default;bool CModel::Initialize(ID3D11Device* device) &#123; return InitializeModel(device);&#125;void CModel::Shutdown() &#123; ShutdownModel();&#125;void CModel::Render(ID3D11DeviceContext* mDeviceContext) &#123; RenderModel(mDeviceContext);&#125;int CModel::GetIndexCount() const &#123; return mIndexCount;&#125; &emsp;&emsp;之后，在 InitializeModel 函数里，我们对我们的模型进行初始化，在我们之前的三角形那一篇里我们进行过这些操作（【directx】3-d3d三角形），这里也基本一样（不同的是这里我们将使用索引缓冲）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354bool CModel::InitializeModel(ID3D11Device* device) &#123; Vertex *vertices; unsigned long *indices; D3D11_BUFFER_DESC vertexBufferDesc, indexBufferDesc; D3D11_SUBRESOURCE_DATA vertexData, indexData; HRESULT hr; // 定义数组保存顶点和索引 mVertexCount = 3; mIndexCount = 3; vertices = new Vertex[mVertexCount]&#123; &#123;DirectX::XMFLOAT3(-1.0f , -1.0f , 0.0f) , DirectX::XMFLOAT4(0.0f , 0.0f , 1.0f , 1.0f)&#125; , &#123;DirectX::XMFLOAT3(0.0f , 1.0f , 0.0f) , DirectX::XMFLOAT4(0.0f , 0.0f , 1.0f , 1.0f)&#125; , &#123;DirectX::XMFLOAT3(1.0f , -1.0f , 0.0f) , DirectX::XMFLOAT4(0.0f , 0.0f , 1.0f , 1.0f)&#125; , &#125;; if (!vertices) &#123; return false; &#125; indices = new unsigned long[mIndexCount] &#123; 0, 1, 2 &#125;; if (!indices) &#123; return false; &#125; // 填写缓冲区描述并且创建缓冲 ZeroMemory(&amp;vertexBufferDesc, sizeof(vertexBufferDesc)); vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT; vertexBufferDesc.ByteWidth = sizeof(Vertex) * mVertexCount; vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; ZeroMemory(&amp;indexBufferDesc, sizeof(indexBufferDesc)); vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT; vertexBufferDesc.ByteWidth = sizeof(unsigned long) * mIndexCount; vertexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER; hr = device-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;vertexData, &amp;mVertexBuffer_); if (FAILED(hr)) &#123; return hr; &#125; hr = device-&gt;CreateBuffer(&amp;indexBufferDesc, &amp;indexData, &amp;mIndexBuffer_); if (FAILED(hr)) &#123; return hr; &#125; // 删除无用数据 delete[] vertices; vertices = 0; delete[] indices; indices = 0; return true;&#125; &emsp;&emsp;最后在 Render 方法里，我们对设备上下文对象进行配置。 12345678void CModel::RenderModel(ID3D11DeviceContext* deviceContext) const &#123; unsigned int stride , offset; stride = sizeof(Vertex); offset = 0; deviceContext-&gt;IASetVertexBuffers(0, 1, &amp;mVertexBuffer_, &amp;stride, &amp;offset); deviceContext-&gt;IASetIndexBuffer(mIndexBuffer_, DXGI_FORMAT_R32_UINT, 0); deviceContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);&#125; &emsp;&emsp;这样，我们就实现了 CModel 类，接下来看 CCamera 。 &emsp;&emsp;首先来看声明： 12345678910111213141516171819class CCamera &#123;public: CCamera(); CCamera(CCamera&amp; cc); void SetPosition(float, float, float); // x y z void SetRotation(float, float, float); // pitch yaw roll DirectX::XMFLOAT3 GetPosition() const; DirectX::XMFLOAT3 GetRotation() const; void Render(); void GetViewMatrix(DirectX::XMMATRIX&amp;) const;private: DirectX::XMFLOAT3 mPosition&#123;&#125;; DirectX::XMFLOAT3 mRotation&#123;&#125;; DirectX::XMMATRIX mViewMatrix&#123;&#125;;&#125;; &emsp;&emsp;在这个类里我们保存着摄像机的坐标和朝向以及一个观察矩阵。那几个 Set Get 函数都比较简单，只是赋值性操作而已。如下： 123456789101112131415161718192021222324252627282930313233CCamera::CCamera() &#123; mPosition = DirectX::XMFLOAT3(); mRotation = DirectX::XMFLOAT3(); mViewMatrix = DirectX::XMMATRIX();&#125;CCamera::CCamera(CCamera&amp; cc) &#123; *this = cc;&#125;void CCamera::SetPosition(const float x , const float y , const float z) &#123; mPosition.x = x; mPosition.y = y; mPosition.z = z;&#125;void CCamera::SetRotation(const float pitch, const float yaw, const float roll) &#123; mRotation.x = pitch; mRotation.y = yaw; mRotation.z = roll;&#125;DirectX::XMFLOAT3 CCamera::GetPosition() const &#123; return mPosition;&#125;DirectX::XMFLOAT3 CCamera::GetRotation() const &#123; return mRotation;&#125;void CCamera::GetViewMatrix(DirectX::XMMATRIX&amp; view) const &#123; view = mViewMatrix;&#125; &emsp;&emsp;最后是 Render 函数，在这个函数里我们将使用 mPosition 变量和 mRotation 变量来更新观察矩阵，即用坐标和朝向来更新观察矩阵： 12345678910111213141516171819202122232425void CCamera::Render() &#123; DirectX::XMVECTOR positionVec, lookAtVec, upVec; DirectX::XMFLOAT3 positionFo3, lookAtFo3, upFo3; DirectX::XMMATRIX rotationMatrix; positionFo3 = mPosition; upFo3 = DirectX::XMFLOAT3(0.0f, 1.0f, 0.0f); lookAtFo3 = DirectX::XMFLOAT3(0.0f, 0.0f,1.0f); positionVec = DirectX::XMLoadFloat3(&amp;positionFo3); upVec = DirectX::XMLoadFloat3(&amp;upFo3); lookAtVec = DirectX::XMLoadFloat3(&amp;lookAtFo3); // 使用 rotation 来创建 rotationMatrix rotationMatrix = DirectX::XMMatrixRotationRollPitchYaw(mRotation.x * 0.0174532925f, mRotation.y * 0.0174532925f, mRotation.z * 0.0174532925f); // 使用 rotation 矩阵更新 lookAt 和 up 向量 upVec = DirectX::XMVector2TransformCoord(upVec, rotationMatrix); lookAtVec = DirectX::XMVector2TransformCoord(lookAtVec, rotationMatrix); lookAtVec = DirectX::XMVectorAdd(positionVec, lookAtVec); // 使用 pos , lookat , up 来创建观察矩阵 mViewMatrix = DirectX::XMMatrixLookAtLH(positionVec, lookAtVec, upVec);&#125; &emsp;&emsp;这样，我们的摄像机类也结束了。现在可以往上一层的 CGraphics 类来添加内容了。首先在声明里增加这两个变量： 12CModel *mModel_;CCamera *mCamera_; &emsp;&emsp;初始化什么的和其他一样： 1234567891011121314151617181920212223242526272829303132333435363738394041bool CGraphics::Initialize(const int screenWidth, const int screenHeight, const HWND hwnd) &#123; HRESULT hr; char vsFileName[] = "vs.vs"; char psFileName[] = "ps.ps"; char* vsFile = vsFileName; char* psFile = psFileName; mDirect3D_ = new CDirect3D; if (!mDirect3D_) &#123; return false; &#125; hr = mDirect3D_-&gt;Initialize(screenWidth, screenHeight, VSYNC_ENABLED, hwnd, FULL_SCREEN, SCREEN_DEPTH, SCREEN_NEAR); if (FAILED(hr)) &#123; return false; &#125; mCamera_ = new CCamera; if (!mCamera_) &#123; return false; &#125; mCamera_-&gt;SetPosition(0.0f, 0.0f, 3.0f); mModel_ = new CModel; if (!mModel_) &#123; return false; &#125; mModel_-&gt;Initialize(mDirect3D_-&gt;GetDevice()); mShader_ = new CShader; if (!mShader_) &#123; return false; &#125; hr = mShader_-&gt;Initialize(mDirect3D_-&gt;GetDevice(), hwnd, vsFile , psFile); if (FAILED(hr)) &#123; return false; &#125; return this-&gt;InitializeGraphics();&#125; &emsp;&emsp;最后，是增加内容后的 RenderGraphics 函数。 12345678910111213141516171819202122bool CGraphics::RenderGraphics(const float r , const float g , const float b , const float a) &#123; DirectX::XMMATRIX world, view, projection; mDirect3D_-&gt;BeginScene(r, g, b, a); mCamera_-&gt;Render(); mDirect3D_-&gt;GetWorldMatrix(world); mCamera_-&gt;GetViewMatrix(view); mDirect3D_-&gt;GetProjectionMatrix(projection); mModel_-&gt;Render(mDirect3D_-&gt;GetDeviceContext()); const bool result = mShader_-&gt;Render(mDirect3D_-&gt;GetDeviceContext() , mModel_-&gt;GetIndexCount() , world , view, projection); if (!result) &#123; return false; &#125; mDirect3D_-&gt;EndScene(); return true;&#125; &emsp;&emsp;需要注意的是，我们更新了数学库，使用 DirectXMath 中的 XMFloat 和 XMMatrix 等，所以之前的代码也需要去修改。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典光照模型之漫反射与Lambert模型]]></title>
    <url>%2F2018%2F03%2F24%2F%E7%BB%8F%E5%85%B8%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E4%B9%8BPhong%E6%A8%A1%E5%9E%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[参考资料 《GPU编程与CG语言之阳春白雪与下里巴人》 《Introduction to 3D Game Programming with Directx11》 漫反射&emsp;&emsp;光的反射我们都是很清楚的，其反射如下： &emsp;&emsp;通常情况下，我们计算某个面的颜色可以根据定向光线到这个面上的入射角来计算。 &emsp;&emsp;但是粗糙的物体表面向各个方向等强度地反射光，这种等同地向各个方向散射的现象称为光的漫反射(diffuse reflection)。产生光的漫反射现象的物体表面称为理想漫反射体，也称为朗伯(Lambert)反射体。 &emsp;&emsp;下面这张图片描述了一个粗糙的表面对于入射光线的发射情况： &emsp;&emsp;可以看到，在面对一个粗糙的物体时，因为各个小平面的法线不一样，所以我们必须对于各个小平面来计算颜色。 &emsp;&emsp;对于仅暴露在环境光下的朗伯反射体，可以用公式(9-1)表示某点处漫反射的光强: I_{ambdiff} = k_{d} I_{a}&emsp;&emsp;其中 I_a 表示环境光强度(简称光强)，k_d (0< k_d]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest-Continuous-Increasing-Subsequence]]></title>
    <url>%2F2018%2F03%2F24%2FLongest-Continuous-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#674 Longest Continuous Increasing Subsequence 题目描述&emsp;&emsp;Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). Example 1: 1234Input: [1,3,5,4,7]Output: 3Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4. Example 2: 123Input: [2,2,2,2,2]Output: 1Explanation: The longest continuous increasing subsequence is [2], its length is 1. Note: Length of the array will not exceed 10,000. 解题思路&emsp;&emsp;直接遍历，当连续增长中断的时候更新最大值。 解题代码12345678910111213141516class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int res = 1 , cot = 1; for (int i = 1; i &lt; nums.size(); ++i) &#123; if(nums[i] &gt; nums[i-1]) cot++; else &#123; res = max(cot , res); cot = 1; &#125; &#125; res = max(cot , res); return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary-Tree-Level-Order-Traversal]]></title>
    <url>%2F2018%2F03%2F24%2FBinary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#102 Binary Tree Level Order Traversal 题目描述&emsp;&emsp;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 解题思路&emsp;&emsp;树的层次遍历，队列实现。 解题代码123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res(0); if(!root) return res; res.push_back(vector&lt;int&gt;(0)); queue&lt;TreeNode*&gt; q; q.push(root); q.push(nullptr); while (q.size() &gt; 1)&#123; auto p = q.front(); q.pop(); if (!p) &#123; res.push_back(vector&lt;int&gt;(0)); q.push(nullptr); &#125; else &#123; if(p-&gt;left) q.push(p-&gt;left); if(p-&gt;right) q.push(p-&gt;right); res[res.size()-1].push_back(p-&gt;val); &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂杂碎碎的常识第二弹-网格与模型]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%9D%82%E6%9D%82%E7%A2%8E%E7%A2%8E%E7%9A%84%E5%B8%B8%E8%AF%86%E7%AC%AC%E4%BA%8C%E5%BC%B9-%E7%BD%91%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;这篇文章是我在着手准备实现物理渲染的时候在为项目搭框架的时候想到要写的。在之前的学习中，虽然也是接触了模型以及模型导入库 Assimp 但是却没有太多的概念。虽然知道网格，也知道网格的实现以及原理，但是并未多次用过，所以在这里准备好好复习一遍。 Mesh&emsp;&emsp;首先甩上一个概念：Mesh（网格） 。在维基百科中被这样定义： &emsp;&emsp;多边形网格（Polygon mesh）是三维计算机图形学中表示多面体形状的顶点与多边形的集合，它也叫作非结构网格。 &emsp;&emsp;这些网格通常由三角形、四边形或者其它的简单凸多边形组成，这样可以简化渲染过程。但是，网格也可以包括带有空洞的普通多边形组成的物体。 &emsp;&emsp;我们这篇文章中要介绍的就是 Mesh 以及 Model 。 &emsp;&emsp;我们在不管是 OpenGL 还是 Direct3D 的学习教程中，都是使用基本图元（primitive）来进行绘制，或者是一个三角形，一个矩形或者一个三维的立方体。这些东西都比较简单，我们可以很简单的描述他。比如我们使用两个三角形组成一个平面矩形，使用十二个三角形组成一个三维立方体，两个三角形组成一个面。我们很容易想象得到这个立方体。 &emsp;&emsp;但是如果非常复杂，比如一个人，一辆坦克。如果我们说他由几千个三角形组成，有几十个几百个面等等。能想象得到吗？ &emsp;&emsp;在这里我们会将使用一个封装的数据类型来描述比较复杂的物体，就是 Mesh 。我们一般由一个 Mesh 来代表一个网格，这个 Mesh 会封装相当多的数据，比如顶点、边、面，而且包含了顶点坐标，纹理坐标，法向量，材质属性等属性。下面是维基百科上的一个例子： &emsp;&emsp;Mesh可以包含多个Face，一个Face是Mesh中一个可绘制的基本图元，例如三角形，多边形，点。要想模型更加逼真，一般需要增加更多图元使Mesh更加精细，当然这也会受到硬件处理能力的限制，例如PC游戏的处理能力要强于移动设备。由于多边形都可以划分为三角形，而三角形是图形处理器中都支持的基本图元，因此使用得较多的就是三角形网格来建模。 &emsp;&emsp;其实我们在学习模型那一节的时候，实现过一个 Mesh 的类，也调用了 Assimp 库来导入模型，可以看这里：【OpenGL】13-Mesh与Model类 。 Model&emsp;&emsp;接下来我们来看看模型（OBJ文件） 。 &emsp;&emsp;OBJ (or .OBJ) is a geometry definition file format first developed by Wavefront Technologies for its Advanced Visualizer animation package. The file format is open and has been adopted by other 3D graphics application vendors. &emsp;&emsp;The OBJ file format is a simple data-format that represents 3D geometry alone — namely, the position of each vertex), the UV position of each texture coordinate vertex, vertex normals, and the faces that make each polygon defined as a list of vertices, and texture vertices. Vertices are stored in a counter-clockwise order by default, making explicit declaration of face normals unnecessary. OBJ coordinates have no units, but OBJ files can contain scale information in a human readable comment line. &emsp;&emsp;简单来说，OBJ 文件就是定义模型的文件。在 OpenGL 中我们使用 Assimp 库来导入 OBJ 文件，OBJ 文件则可以通过各种 3D 建模工具进行导出。OBJ 本质上是一个文本文件： OBJ文件特点 （1）OBJ是一种3D模型文件，因此不包含动画、材质特性、贴图路径、动力学、粒子等信息。 （2）OBJ文件主要支持多边形(Polygons)模型。 虽然OBJ文件也支持曲线(Curves)、表面(Surfaces)、点组材质(Point Group Materials)，但Maya导出的OBJ文件并不包括这些信息。 （3）OBJ文件支持三个点以上的面，这一点很有用。 （4）OBJ文件支持法线和贴图坐标。 在其它软件中调整好贴图后，贴图坐标信息可以存入OBJ文件中，这样文件导入Maya后只需指定一下贴图文件路径就行了，不需要再调整贴图坐标了。 （5）OBJ文件不支持有孔的多边形面。 （6）OBJ文件不包含面的颜色定义信息，不过可以引用材质库，材质库信息储存在一个后缀是”.mtl”的独立文件中。关键字”mtllib”即材质库的意思。 OBJ文件的前缀 OBJ文件以纯文本的形式存储了模型的顶点、法线和纹理坐标和材质使用信息。 在OBJ文件中，每行的格式如下：前缀 参数1 参数2 参数3 … （前缀标识了这一行所存储的信息类型。参数则是具体的数据。） OBJ文件的前缀可以有： v 表示本行指定一个顶点。此前缀后跟着3个单精度浮点数，分别表示该定点的X、Y、Z坐标值 vt 表示本行指定一个纹理坐标。此前缀后跟着两个单精度浮点数。分别表示此纹理坐标的U、V值 vn 表示本行指定一个法线向量。此前缀后跟着3个单精度浮点数，分别表示该法向量的X、Y、Z坐标值 f 表示本行指定一个表面(Face)。一个表面实际上就是一个三角形图元。此前缀行的参数格式后面将详细介绍。 usemtl 此前缀后只跟着一个参数。该参数指定了从此行之后到下一个以usemtl开头的行之间的所有表面所使用的材质名称。该材质可以在此OBJ文件所附属的MTL文件中找到具体信息。 mtllib 此前缀后只跟着一个参数。该参数指定了此OBJ文件所使用的材质库文件(*.mtl)的文件路径 以“#”开头的表示注释的前缀，以g开头的表示组的前缀。这些前缀并不影响模型的外观，可以忽略它们。 ​ 来自：http://www.cnblogs.com/zsclucien/p/3573396.html]]></content>
      <tags>
        <tag>Computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary-Tree-Right-Side-View]]></title>
    <url>%2F2018%2F03%2F23%2FBinary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#199 Binary Tree Right Side View 题目描述&emsp;&emsp;Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. For example:Given the following binary tree, 12345 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- You should return [1, 3, 4]. 解题思路&emsp;&emsp;这道题要求求出二叉树每一层最右边的值。那么我们只需要先序遍历，然后每一层依次更新就可以了。 解题代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; void recv(TreeNode *root, int level, vector&lt;int&gt; &amp;res) &#123; if (!root) return; if (level &gt;= res.size()) res.push_back(root-&gt;val); else res[level] = root-&gt;val; recv(root-&gt;left, level + 1, res); recv(root-&gt;right, level + 1, res); &#125;public: vector&lt;int&gt; rightSideView(TreeNode *root) &#123; vector&lt;int&gt; res(0); recv(root, 0, res); return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】8-代码框架5-Shader]]></title>
    <url>%2F2018%2F03%2F22%2F%E3%80%90DirectX%E3%80%918-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B65-Shader%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 4: Buffers, Shaders, and HLSL 学习记录&emsp;&emsp;这一篇文章，我们将继续完善 CGraphics 的框架类，我们将为框架加上 CShader 类。这个类的目的是封装着色器的部分内容，我们在之前的三角形教程中已经用过了 HLSL ，所以这一篇不会很困难。 &emsp;&emsp;这个类完善后，我们的框架将会更新为： &emsp;&emsp;首先我们来看看这个类的声明： 1234567891011121314151617181920212223242526272829class CShader &#123; struct MatrixBufferType &#123; D3DXMATRIX world; D3DXMATRIX view; D3DXMATRIX projection; &#125;;public: CShader(); CShader(CShader&amp; cs); ~CShader(); bool Initialize(ID3D11Device*, HWND , PCHAR , PCHAR); void Shutdown(); bool Render(ID3D11DeviceContext*, int, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX);private: bool InitializeShader(ID3D11Device*, HWND, PCHAR, PCHAR); void ShutdownShader(); void OutputShaderErrorMessage(ID3D10Blob*, HWND, WCHAR*); bool SetShaderParameters(ID3D11DeviceContext*, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX); void RenderShader(ID3D11DeviceContext*, int); ID3D11VertexShader* mVertexShader_; ID3D11PixelShader* mPixelShader_; ID3D11InputLayout* mLayout_; ID3D11Buffer* mMatrixBuffer_;&#125;; &emsp;&emsp;构造方法和析构方法就是初始化和最后的删除： 12345678910111213141516171819202122232425CShader::CShader() &#123; mVertexShader_ = 0; mMatrixBuffer_ = 0; mLayout_ = 0; mPixelShader_ = 0;&#125;void CShader::ShutdownShader() &#123; if (mVertexShader_) &#123; mVertexShader_-&gt;Release(); mVertexShader_ = 0; &#125; if (mMatrixBuffer_) &#123; mMatrixBuffer_-&gt;Release(); mMatrixBuffer_ = 0; &#125; if (mPixelShader_) &#123; mPixelShader_-&gt;Release(); mPixelShader_ = 0; &#125; if (mLayout_) &#123; mLayout_-&gt;Release(); mLayout_ = 0; &#125;&#125; &emsp;&emsp;在 Initialize() 方法中我们直接调用 InitializeShader() 方法，所以直接来看这个： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869bool CShader::InitializeShader(ID3D11Device* device, HWND hwnd, PCHAR vsFilePath, PCHAR psFilePath) &#123; HRESULT hr; ID3D10Blob* errorMessage; ID3D10Blob* vertexShaderBuffer; ID3D10Blob* pixelShaderBuffer; unsigned int numElements; hr = D3DX11CompileFromFile(vsFilePath, NULL, NULL, "Main", "vs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, NULL,&amp;vertexShaderBuffer , &amp;errorMessage , nullptr); if (FAILED(hr)) &#123; if (errorMessage) &#123; OutputShaderErrorMessage(errorMessage, hwnd, vsFilePath); &#125; else &#123; return hr; &#125; &#125; hr = D3DX11CompileFromFile(psFilePath, NULL, NULL, "Main", "ps_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, NULL, &amp;pixelShaderBuffer, &amp;errorMessage, nullptr); if (FAILED(hr)) &#123; if (errorMessage) &#123; OutputShaderErrorMessage(errorMessage, hwnd, vsFilePath); &#125; else &#123; return hr; &#125; &#125; hr = device-&gt;CreateVertexShader(vertexShaderBuffer-&gt;GetBufferPointer(), vertexShaderBuffer-&gt;GetBufferSize(), NULL, &amp;mVertexShader_); if (FAILED(hr)) &#123; return hr; &#125; hr = device-&gt;CreatePixelShader(pixelShaderBuffer-&gt;GetBufferPointer(), pixelShaderBuffer-&gt;GetBufferSize(), NULL, &amp;mPixelShader_); if (FAILED(hr)) &#123; return hr; &#125; D3D11_INPUT_ELEMENT_DESC polygonLayout[2] = &#123; &#123;"POSITION" , 0 , DXGI_FORMAT_R32G32B32A32_FLOAT , 0 , 0 , D3D11_INPUT_PER_VERTEX_DATA , 0&#125; , &#123;"COLOR" , 0 , DXGI_FORMAT_R32G32B32A32_FLOAT , 0 , D3D11_APPEND_ALIGNED_ELEMENT , D3D11_INPUT_PER_VERTEX_DATA , 0&#125; &#125;; numElements = sizeof(polygonLayout) / sizeof(polygonLayout[0]); hr = device-&gt;CreateInputLayout(polygonLayout, numElements, vertexShaderBuffer-&gt;GetBufferPointer(), vertexShaderBuffer-&gt;GetBufferSize(), &amp;mLayout_); if (FAILED(hr)) &#123; return false; &#125; vertexShaderBuffer-&gt;Release(); vertexShaderBuffer = 0; pixelShaderBuffer-&gt;Release(); pixelShaderBuffer = 0; D3D11_BUFFER_DESC matrixBufferDesc; matrixBufferDesc.Usage = D3D11_USAGE_DYNAMIC; matrixBufferDesc.ByteWidth = sizeof(MatrixBufferType); matrixBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER; matrixBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; matrixBufferDesc.MiscFlags = 0; matrixBufferDesc.StructureByteStride = 0; hr = device-&gt;CreateBuffer(&amp;matrixBufferDesc, NULL, &amp;mMatrixBuffer_); if (FAILED(hr)) &#123; return hr; &#125; return true;&#125; &emsp;&emsp;&emsp;&emsp;（这段代码我们之前见过的，所以就不仔细讲了） &emsp;&emsp;OutShaderErrorMessage() 如下： 12345678910111213141516void CShader::OutputShaderErrorMessage(ID3D10Blob* errorMessage, HWND hwnd, PCHAR fileName) const &#123; char* error; unsigned long bufferSize; std::ofstream out; error = static_cast&lt;char*&gt;(errorMessage-&gt;GetBufferPointer()); bufferSize = errorMessage-&gt;GetBufferSize(); out.open("log.txt"); for (auto i = 0 ; i &lt; bufferSize ; ++i) &#123; out &lt;&lt; error[i]; &#125; out.close(); errorMessage-&gt;Release(); errorMessage = 0; delete error;&#125; &emsp;&emsp;在这里我们将编译出错的出错信息打印到 log.txt 里。 &emsp;&emsp;之后，我们使用 CShader::SetShaderParameters 方法来填充 mMatrixBuffer 。 123456789101112131415161718192021222324bool CShader::SetShaderParameters(ID3D11DeviceContext* deviceContext, D3DXMATRIX world, D3DXMATRIX view, D3DXMATRIX projection) const &#123; HRESULT hr; D3D11_MAPPED_SUBRESOURCE mappedSubResource; MatrixBufferType* dataPtr; D3DXMatrixTranspose(&amp;world, &amp;world); D3DXMatrixTranspose(&amp;view, &amp;view); D3DXMatrixTranspose(&amp;projection, &amp;projection); // 填充矩阵缓冲 hr = deviceContext-&gt;Map(mMatrixBuffer_, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedSubResource); if(FAILED(hr)) &#123; return hr; &#125; dataPtr = static_cast&lt;MatrixBufferType*&gt;(mappedSubResource.pData); dataPtr-&gt;world = world; dataPtr-&gt;projection = projection; dataPtr-&gt;view = view; deviceContext-&gt;Unmap(mMatrixBuffer_, 0); deviceContext-&gt;VSSetConstantBuffers(0, 1, &amp;mMatrixBuffer_); return true;&#125; &emsp;&emsp;最后在 RenderShader() 里绘制： 123456void CShader::RenderShader(ID3D11DeviceContext* deviceContext, const int indexCount) const &#123; deviceContext-&gt;IASetInputLayout(mLayout_); deviceContext-&gt;VSSetShader(mVertexShader_, nullptr, 0); deviceContext-&gt;PSSetShader(mPixelShader_, nullptr, 0); deviceContext-&gt;DrawIndexed(indexCount, 0, 0);&#125; &emsp;&emsp;在我们对外的 Render() 接口里调用 SetShaderParameters 和 RenderShader ： 123456789bool CShader::Render(ID3D11DeviceContext* deviceContext, const int index, const D3DXMATRIX world, const D3DXMATRIX view, const D3DXMATRIX projection) const &#123; HRESULT hr; hr = SetShaderParameters(deviceContext, world, view, projection); if (FAILED(hr)) &#123; return false; &#125; RenderShader(deviceContext, index); return true;&#125; &emsp;&emsp;这样我们的 CShaper 类就搞定了，这个类的内容我们之前的代码里都说过，所以这里比较简单。现在可以去更新上层的 CGraphics 类了。 &emsp;&emsp;仍然是在声明里创建指针对象，在初始化方法里初始化： 12345678910111213141516171819202122232425CShader *mShader_&#123;&#125;;bool CGraphics::Initialize(const int screenWidth, const int screenHeight, const HWND hwnd) &#123; HRESULT hr; mShader_ = new CShader; if (!mShader_) &#123; return false; &#125; hr = mShader_-&gt;Initialize(mDirect3D_-&gt;GetDevice(), hwnd, "vs.vsh", "ps.psh"); if (FAILED(hr)) &#123; return false; &#125; return this-&gt;InitializeGraphics();&#125;void CGraphics::Shutdown() &#123; if (mDirect3D_) &#123; mDirect3D_-&gt;Shutdown(); delete mDirect3D_; mDirect3D_ = 0; &#125;&#125; &emsp;&emsp;在 CGraphics::RenderGraphics 方法里，我们调用这个渲染： 1234567bool CGraphics::RenderGraphics(const float r , const float g , const float b , const float a) &#123; mDirect3D_-&gt;BeginScene(r, g, b, a); mShader_-&gt;Render(mDirect3D_-&gt;GetDeviceContext() , 0 , NULL, NULL, NULL); mDirect3D_-&gt;EndScene(); return true;&#125; &emsp;&emsp;由于我们还没有完成 CCamera 和 CModel ，所以我们在 CShader 对象的接口里的矩阵参数暂时置空。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gray-Code]]></title>
    <url>%2F2018%2F03%2F22%2FGray-Code%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#89 Gray Code 题目描述&emsp;&emsp;The gray code is a binary numeral system where two successive values differ in only one bit. &emsp;&emsp;Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. &emsp;&emsp;For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 123400 - 001 - 111 - 310 - 2 Note:For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 解题思路&emsp;&emsp;思路比较简单，直接遍历就可以了，看代码。 解题代码12345678910111213141516class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; ret(0); ret.push_back(0); if (n == 0) return ret; ret.push_back(1); for (int i = 1; i &lt; n; ++i) &#123; int size = ret.size(); for (int j = size - 1; j &gt;= 0; --j) &#123; ret.push_back(static_cast&lt;int &amp;&amp;&gt;(ret[j] + pow(2 , i))); &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】7-代码框架4-CDirect3D类]]></title>
    <url>%2F2018%2F03%2F21%2F%E3%80%90DirectX%E3%80%917-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B64-CDirect3D%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 3: Initializing DirectX 11 学习记录&emsp;&emsp;在之前的文章中，我们简单的将我们的框架下的 CInput 填充了以下，实现了 CKeyboard 和 CMouse 两个基础类。输入貌似就可以暂时这样了，现在我们来看输出。也就是我们 CSystem 类下的另一个 CGraphics 。这篇文章中要实现的是对于 D3D 系统函数的封装，将其命名为 CDirect3D 。 &emsp;&emsp;更新 CDirect3D 之后我们的框架如下： &emsp;&emsp;之前我们实现了很多个类，但是都算是很简单的。而这一篇就比较复杂了，我们之前写过 dx 的初始化代码，也是大致清楚都需要做什么，先来看看这个类的声明。 123456789101112131415161718192021222324252627282930313233343536class CDirect3D &#123;public: CDirect3D(); CDirect3D(CDirect3D&amp; cd); ~CDirect3D(); bool Initialize(int, int, bool, HWND, bool, float, float); void Shutdown(); void BeginScene(float, float, float, float) const; void EndScene() const; ID3D11Device* GetDevice() const; ID3D11DeviceContext* GetDeviceContext() const; void GetProjectionMatrix(D3DXMATRIX&amp;) const; void GetWorldMatrix(D3DXMATRIX&amp;) const; void GetOrthoMatrix(D3DXMATRIX&amp;) const; void GetVideoCardInfo(char*, int&amp;) const;private: bool mVsyncEnabled_&#123;&#125;; int mVideoCardMemory_&#123;&#125;; char mVideoCardDescription_[128]&#123;&#125;; IDXGISwapChain* mSwapChain_&#123;&#125;; ID3D11Device* mDevice_&#123;&#125;; ID3D11DeviceContext* mDeviceContext_&#123;&#125;; ID3D11RenderTargetView* mRenderTargetView_&#123;&#125;; ID3D11Texture2D* mDepthStencilBuffer_&#123;&#125;; ID3D11DepthStencilState* mDepthStencilState_&#123;&#125;; ID3D11DepthStencilView* mDepthStencilView_&#123;&#125;; ID3D11RasterizerState* mRasterState_&#123;&#125;; D3DXMATRIX mProjectionMatrix_; D3DXMATRIX mWorldMatrix_; D3DXMATRIX mOrthoMatrix_;&#125;; &emsp;&emsp;嗯，看着确实很绝望了，这个类包括了大量的变量定义与函数声明。不过这里边的大部分的变量我们都见过（IDXGISWapChain ，ID3D11Device 等等），剩下的几个例如深度模板的变量我们在 OpenGL 中也是见过的（如果你没有学过，请忽略这个或者翻一下 OpenGL 的学习笔记）。 &emsp;&emsp;那么来看看这个类的实现吧，首先在构造函数里我们初始化这几个指针变量为空。 12345678910CDirect3D::CDirect3D() &#123; mSwapChain_ = 0; mDevice_ = 0; mDeviceContext_ = 0; mRenderTargetView_ = 0; mDepthStencilBuffer_ = 0; mDepthStencilState_ = 0; mDepthStencilView_ = 0; mRasterState_ = 0;&#125; &emsp;&emsp;现在来看看我们的 Initialize() 函数，这将是我们这个类中最重要的函数。 The screenWidth and screenHeight variables that are given to this function are the width and height of the window we created in the SystemClass.Direct3D will use these to initialize and use the same window dimensions.The hwnd variable is a handle to the window. Direct3D will need this handle to access the window previously created.The fullscreen variable is whether we are running in windowed mode or fullscreen. Direct3D needs this as well for creating the window with the correct settings.The screenDepth and screenNear variables are the depth settings for our 3D environment that will be rendered in the window.The vsync variable indicates if we want Direct3D to render according to the users monitor refresh rate or to just go as fast as possible. ​ ——（教程原文中对于 initialize 方法的参数的描述） &emsp;&emsp;在 Initialize() 中，我们首先声明了初始化我们成员变量所需要的一些东西。在我们初始化 D3D 之前，我们从显卡 / 显示器上获得刷新率，这样我们可以根据不同的计算机屏幕刷新率不同实现自适应。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061IDXGIFactory* factory;IDXGIAdapter* adapter;IDXGIOutput* adapterOutput;unsigned int numModes, i, numerator = 0, denominator = 0, stringLength;DXGI_MODE_DESC* displayModeList;DXGI_ADAPTER_DESC adapterDesc;int error;// 创建一个 DXGI 工厂类实例HRESULT result = CreateDXGIFactory(__uuidof(IDXGIFactory), reinterpret_cast&lt;void**&gt;(&amp;factory));if (FAILED(result))&#123; return false;&#125;// 使用工厂对象来创建一个显卡适配器result = factory-&gt;EnumAdapters(0, &amp;adapter);if (FAILED(result))&#123; return false;&#125;// 枚举出一个输出适配器result = adapter-&gt;EnumOutputs(0, &amp;adapterOutput);if (FAILED(result))&#123; return false;&#125;// 获取适合输出的显示格式的数量result = adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, NULL);if (FAILED(result))&#123; return false;&#125;// 创建 List 用来保存显示模式displayModeList = new DXGI_MODE_DESC[numModes];if (!displayModeList)&#123; return false;&#125;// 填充显示模式数组result = adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, displayModeList);if (FAILED(result))&#123; return false;&#125;for (i = 0; i &lt; numModes; i++)&#123; if (displayModeList[i].Width == static_cast&lt;unsigned int&gt;(screenWidth)) &#123; if (displayModeList[i].Height == static_cast&lt;unsigned int&gt;(screenHeight)) &#123; numerator = displayModeList[i].RefreshRate.Numerator; denominator = displayModeList[i].RefreshRate.Denominator; &#125; &#125;&#125; &emsp;&emsp;可以看到我们调用了两次 GetDisplayModeList ，第一次为 numModes 赋值，之后我们有了显示模式的个数之后可以创建数组，之后才会将数组也传入进去用来保存显示模式列表。最后，我们遍历数组并且匹配我们所传入进来的 width 和 height 。最终得到合适的 numerator 和 denominator 值，用于我们最后在创建交换链的时候赋值。 12345678910111213141516// Get the adapter (video card) description.result = adapter-&gt;GetDesc(&amp;adapterDesc);if (FAILED(result))&#123; return false;&#125;// Store the dedicated video card memory in megabytes.mVideoCardMemory_ = static_cast&lt;int&gt;(adapterDesc.DedicatedVideoMemory / 1024 / 1024);// Convert the name of the video card to a character array and store it.error = wcstombs_s(&amp;stringLength, mVideoCardDescription_, 128, adapterDesc.Description, 128);if (error != 0)&#123; return false;&#125; &emsp;&emsp;做完这些后，我们再来获得显卡的内存，保存在 mVideoCardMemory_ 里。当我们得到了这些数据后，就可以开始创建交换链那些东西了（我们之前做过的）。 &emsp;&emsp;先释放掉刚才为了获得显卡显示器数据创建的指针对象。 123456789101112131415// Release the display mode list.delete[] displayModeList;displayModeList = 0;// Release the adapter output.adapterOutput-&gt;Release();adapterOutput = 0;// Release the adapter.adapter-&gt;Release();adapter = 0;// Release the factory.factory-&gt;Release();factory = 0; &emsp;&emsp;之后，初始化交换链描述： 123456789101112131415161718192021222324252627DXGI_SWAP_CHAIN_DESC swapChainDesc;// Initialize the swap chain description.ZeroMemory(&amp;swapChainDesc, sizeof(swapChainDesc));swapChainDesc.BufferCount = 1;swapChainDesc.BufferDesc.Width = screenWidth;swapChainDesc.BufferDesc.Height = screenHeight;swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;if (mVsyncEnabled_)&#123; swapChainDesc.BufferDesc.RefreshRate.Numerator = numerator; swapChainDesc.BufferDesc.RefreshRate.Denominator = denominator;&#125;else&#123; swapChainDesc.BufferDesc.RefreshRate.Numerator = 0; swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;&#125;swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;swapChainDesc.OutputWindow = hwnd;swapChainDesc.SampleDesc.Count = 1;swapChainDesc.SampleDesc.Quality = 0;if (fullscreen) swapChainDesc.Windowed = false;else swapChainDesc.Windowed = true;swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;swapChainDesc.Flags = 0; &emsp;&emsp;初始化完了之后就可以直接创建了，然后是创建 RenderTargetView 这些。 123456789101112131415161718192021222324252627// Set the feature level to DirectX 11.D3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL_11_0;// Create the swap chain, Direct3D device, and Direct3D device context.result = D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0, &amp;featureLevel, 1,D3D11_SDK_VERSION, &amp;swapChainDesc, &amp;mSwapChain_, &amp;mDevice_, NULL, &amp;mDeviceContext_);if (FAILED(result))&#123; return false;&#125;// Get the pointer to the back buffer.result = mSwapChain_-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast&lt;LPVOID*&gt;(&amp;backBufferPtr));if (FAILED(result))&#123; return false;&#125;// Create the render target view with the back buffer pointer.result = mDevice_-&gt;CreateRenderTargetView(backBufferPtr, NULL, &amp;mRenderTargetView_);if (FAILED(result))&#123; return false;&#125;// Release pointer to the back buffer as we no longer need it.backBufferPtr-&gt;Release();backBufferPtr = 0; &emsp;&emsp;现在我们来创建深度缓冲描述，用它来创建深度缓冲，并且附加一个深度模板。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Initialize the description of the depth buffer.ZeroMemory(&amp;depthBufferDesc, sizeof(depthBufferDesc));// Set up the description of the depth buffer.depthBufferDesc.Width = screenWidth;depthBufferDesc.Height = screenHeight;depthBufferDesc.MipLevels = 1;depthBufferDesc.ArraySize = 1;depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;depthBufferDesc.SampleDesc.Count = 1;depthBufferDesc.SampleDesc.Quality = 0;depthBufferDesc.Usage = D3D11_USAGE_DEFAULT;depthBufferDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;depthBufferDesc.CPUAccessFlags = 0;depthBufferDesc.MiscFlags = 0;// Create the texture for the depth buffer using the filled out description.result = mDevice_-&gt;CreateTexture2D(&amp;depthBufferDesc, NULL, &amp;mDepthStencilBuffer_);if (FAILED(result))&#123; return false;&#125;// Initialize the description of the stencil state.ZeroMemory(&amp;depthStencilDesc, sizeof(depthStencilDesc));// Set up the description of the stencil state.depthStencilDesc.DepthEnable = true;depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS;depthStencilDesc.StencilEnable = true;depthStencilDesc.StencilReadMask = 0xFF;depthStencilDesc.StencilWriteMask = 0xFF;// Stencil operations if pixel is front-facing.depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;// Stencil operations if pixel is back-facing.depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;// Create the depth stencil state.result = mDevice_-&gt;CreateDepthStencilState(&amp;depthStencilDesc, &amp;mDepthStencilState_);if (FAILED(result))&#123; return false;&#125;// Set the depth stencil state.mDeviceContext_-&gt;OMSetDepthStencilState(mDepthStencilState_, 1);// Initailze the depth stencil view.ZeroMemory(&amp;depthStencilViewDesc, sizeof(depthStencilViewDesc));// Set up the depth stencil view description.depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;depthStencilViewDesc.Texture2D.MipSlice = 0;// Create the depth stencil view.result = mDevice_-&gt;CreateDepthStencilView(mDepthStencilBuffer_, &amp;depthStencilViewDesc, &amp;mDepthStencilView_);if (FAILED(result))&#123; return false;&#125;// Bind the render target view and depth stencil buffer to the output render pipeline.mDeviceContext_-&gt;OMSetRenderTargets(1, &amp;mRenderTargetView_, mDepthStencilView_); &emsp;&emsp;完成这个，我们来创建一个 Raster ： 1234567891011121314151617181920rasterDesc.AntialiasedLineEnable = false;rasterDesc.CullMode = D3D11_CULL_BACK;rasterDesc.DepthBias = 0;rasterDesc.DepthBiasClamp = 0.0f;rasterDesc.DepthClipEnable = true;rasterDesc.FillMode = D3D11_FILL_SOLID;rasterDesc.FrontCounterClockwise = false;rasterDesc.MultisampleEnable = false;rasterDesc.ScissorEnable = false;rasterDesc.SlopeScaledDepthBias = 0.0f;// Create the rasterizer state from the description we just filled out.result = mDevice_-&gt;CreateRasterizerState(&amp;rasterDesc, &amp;mRasterState_);if (FAILED(result))&#123; return false;&#125;// Now set the rasterizer state.mDeviceContext_-&gt;RSSetState(mRasterState_); &emsp;&emsp;Now that the render targets are setup we can continue on to some extra functions that will give us more control over our scenes for future tutorials.First thing is we’ll create is a rasterizer state. This will give us control over how polygons are rendered.&emsp;&emsp;We can do things like make our scenes render in wireframe mode or have DirectX draw both the front and back faces of polygons.&emsp;&emsp;By default DirectX already has a rasterizer state set up and working the exact same as the one below but you have no control to change it unless you set up one yourself. &emsp;&emsp;我们自定义光栅化可以使得我们实现更多的效果。 &emsp;&emsp;最后，创建 ViewPort 以及初始化那几个矩阵（可以看到我们并没有 ViewMatrix，这个准备封装在摄像机类里 CCamera）。 1234567891011121314151617181920212223// Setup the viewport for rendering.viewport.Width = static_cast&lt;float&gt;(screenWidth);viewport.Height = static_cast&lt;float&gt;(screenHeight);viewport.MinDepth = 0.0f;viewport.MaxDepth = 1.0f;viewport.TopLeftX = 0.0f;viewport.TopLeftY = 0.0f;// Create the viewport.mDeviceContext_-&gt;RSSetViewports(1, &amp;viewport);// Setup the projection matrix.const float fieldOfView = static_cast&lt;float&gt;(D3DX_PI) / 4.0f;const float screenAspect = static_cast&lt;float&gt;(screenWidth) / static_cast&lt;float&gt;(screenHeight);// Create the projection matrix for 3D rendering.D3DXMatrixPerspectiveFovLH(&amp;mProjectionMatrix_, fieldOfView, screenAspect, screenNear, screenDepth);// Initialize the world matrix to the identity matrix.D3DXMatrixIdentity(&amp;mWorldMatrix_);// Create an orthographic projection matrix for 2D rendering.D3DXMatrixOrthoLH(&amp;mOrthoMatrix_, static_cast&lt;float&gt;(screenWidth), static_cast&lt;float&gt;(screenHeight), screenNear, screenDepth); &emsp;&emsp;终于，我们的初始化方法结束了（好长），可以看到是非常麻烦的。幸好我们实际编程中是不会去专注于这里。 &emsp;&emsp;解决了初始化，剩下的就简单的多了。Shutdown 方法中我们将 delete 掉成员变量指针。 12345678910111213141516171819202122232425262728293031323334void CDirect3D::Shutdown() &#123; if (mSwapChain_) &#123; mSwapChain_-&gt;Release(); mSwapChain_ = 0; &#125; if (mRasterState_) &#123; mRasterState_-&gt;Release(); mRasterState_ = 0; &#125; if (mDevice_) &#123; mDevice_-&gt;Release(); mDevice_ = 0; &#125; if (mDeviceContext_) &#123; mDeviceContext_-&gt;Release(); mDeviceContext_ = 0; &#125; if (mRenderTargetView_) &#123; mRenderTargetView_-&gt;Release(); mRenderTargetView_ = 0; &#125; if (mDepthStencilBuffer_) &#123; mDepthStencilBuffer_-&gt;Release(); mDepthStencilBuffer_ = 0; &#125; if (mDepthStencilState_) &#123; mDepthStencilState_-&gt;Release(); mDepthStencilState_ = 0; &#125; if (mDepthStencilView_) &#123; mDepthStencilView_-&gt;Release(); mDepthStencilView_ = 0; &#125;&#125; &emsp;&emsp;在 BeginScene 和 EndScene 中我们实现缓冲清空（颜色和深度）和交换。 12345678910111213void CDirect3D::BeginScene(const float r, const float g, const float b , const float a) const &#123; float color[] = &#123; r , g , b , a &#125;; mDeviceContext_-&gt;ClearRenderTargetView(mRenderTargetView_, color); mDeviceContext_-&gt;ClearDepthStencilView(mDepthStencilView_, D3D11_CLEAR_DEPTH, 1.0f, 0);&#125;void CDirect3D::EndScene() const &#123; if (mVsyncEnabled_) &#123; mSwapChain_-&gt;Present(1, 0); &#125; else &#123; mSwapChain_-&gt;Present(0, 0); &#125;&#125; &emsp;&emsp;剩下的方法则是简单的赋值了： 123456789101112131415161718192021222324ID3D11Device* CDirect3D::GetDevice() const &#123; return mDevice_;&#125;ID3D11DeviceContext* CDirect3D::GetDeviceContext() const &#123; return mDeviceContext_;&#125;void CDirect3D::GetProjectionMatrix(D3DXMATRIX&amp; projectionMatrix) const &#123; projectionMatrix = mProjectionMatrix_;&#125;void CDirect3D::GetWorldMatrix(D3DXMATRIX&amp; worldMatrix) const &#123; worldMatrix = mWorldMatrix_;&#125;void CDirect3D::GetOrthoMatrix(D3DXMATRIX&amp; orthoMatrix) const &#123; orthoMatrix = mOrthoMatrix_;&#125;void CDirect3D::GetVideoCardInfo(char* cardName, int&amp; memory) const &#123; strcpy(cardName, mVideoCardDescription_); memory = mVideoCardMemory_;&#125; &emsp;&emsp;终于，我们实现了 CDirect3D 类。现在来修改 CSystem 使得它调用 CDirect3D 。比如初始化或者删除，还有在 Render() 方法的修改： 1234567891011121314151617181920212223242526272829303132bool CGraphics::Initialize(const int screenWidth, const int screenHeight, const HWND hwnd) &#123; mDirect3D_ = new CDirect3D; if (!mDirect3D_) &#123; return false; &#125; const HRESULT hr = mDirect3D_-&gt;Initialize(screenWidth, screenHeight, VSYNC_ENABLED, hwnd, FULL_SCREEN, SCREEN_DEPTH, SCREEN_NEAR); if (FAILED(hr)) &#123; return false; &#125; return this-&gt;InitializeGraphics();&#125;void CGraphics::Shutdown() &#123; if (mDirect3D_) &#123; mDirect3D_-&gt;Shutdown(); delete mDirect3D_; mDirect3D_ = 0; &#125; this-&gt;ShutdownGraphics();&#125;bool CGraphics::RenderGraphics(const float r , const float g , const float b , const float a) &#123; mDirect3D_-&gt;BeginScene(r, g, b, a); mDirect3D_-&gt;EndScene(); return true;&#125; &emsp;&emsp;这里，我们的 Initialize 需要增加 rgba 的参数。 &emsp;&emsp;这一篇很长，写的时候也比较乱，之后若是有时间的话可能会进行修改。实现框架并不是我们最终的目的，在这个过程中我们介绍它的实现的过程才是最终需要学习的内容。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Evaluate-Division]]></title>
    <url>%2F2018%2F03%2F21%2FEvaluate-Division%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#399 Evaluate Division 题目描述&emsp;&emsp;Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example:Given a / b = 2.0, b / c = 3.0.queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries, where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector&lt;double&gt;. According to the example above: 123equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],values = [2.0, 3.0],queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ]. &emsp;&emsp;The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction. 解题思路&emsp;&emsp;原解来自这里 ，DFS 解法。 解题代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;private: unordered_map&lt;string, vector&lt;pair&lt;string, double&gt;&gt;&gt; children; // adjacency list pair&lt;bool, double&gt; search(string&amp; a, string&amp; b, unordered_set&lt;string&gt;&amp; visited, double val) &#123; if (visited.count(a) == 0) &#123; visited.insert(a); // mark a as visited for (auto p : children[a]) &#123; double temp = val * p.second; // potential result if (p.first == b) &#123; return make_pair(true, temp); &#125; // found result auto result = search(p.first, b, visited, temp); if (result.first) &#123; return result; &#125; &#125; &#125; return make_pair(false, -1.0); &#125;public: vector&lt;double&gt; calcEquation(vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries) &#123; vector&lt;double&gt; ans; for (int i = 0; i &lt; equations.size(); i++) &#123; children[equations[i].first].push_back(make_pair(equations[i].second, values[i])); // build graph list a-&gt;b children[equations[i].second].push_back(make_pair(equations[i].first, 1.0 / values[i]));// build graph list b-&gt;a &#125; for (auto p : queries) &#123; unordered_set&lt;string&gt; visited; // to record visited nodes // p.first == p.second is special case ans.push_back(p.first == p.second &amp;&amp; children.count(p.first) ? 1.0 : search(p.first, p.second, visited, 1.0).second); &#125; return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】6-代码框架3-键盘与鼠标]]></title>
    <url>%2F2018%2F03%2F20%2F%E3%80%90DirectX%E3%80%916-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B63-%E9%94%AE%E7%9B%98%E4%B8%8E%E9%BC%A0%E6%A0%87%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 2: Creating a Framework and Window 学习记录&emsp;&emsp;上一篇文章 中我们新增了 CInput 和 CGraphics ，但是两个里边都没有实际内容。所以只是填充了框架，而这一篇中我们来完善 CInput 类的分支：CKeyboard 和 CMouse 。 &emsp;&emsp;这一篇之后，我们的框架结构如下： &emsp;&emsp;我们的 CKeyboard 用来提供基本的键盘操作，我们会使用一个 keys 数组来保存每一个键位的值。当某个键位按下时，我们更该这个位置的值。除此之外我们需要给出一个或者某个键值的方法，这就是我们这个 Keyboard 类最主要的功能（在原教程中，它的 InputClass 类直接提供了这些方法，但我将其提出作为单独的键盘类使用）。来看看这个类的声明： 1234567891011121314151617class CKeyboard &#123;public: CKeyboard(); CKeyboard(CKeyboard&amp; keyboard); ~CKeyboard(); bool Initialize(); void Shutdown(); void KeyDown(unsigned int key); void KeyUp(unsigned int key); bool IsKeyDown(unsigned int key); unsigned int keyCount = 1024;private: bool InitializeKeyboard(); void ShutdownKeyboard(); std::vector&lt;bool&gt; keys;&#125;; &emsp;&emsp;每个按键都有其对应的值，所以我们设定了一个 keys 数组用以保存这个键位是否被按下。Initialize() 这些方法和其他类都一样暂且不提，我们的 Keydown() 和 Keyup() 方法会更新 keys 的值，而 IsKeyDown() 则返回一个布尔值。实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243CKeyboard::CKeyboard() &#123; this-&gt;Initialize();&#125;CKeyboard::CKeyboard(CKeyboard&amp; keyboard) &#123; *this = keyboard; this-&gt;Initialize();&#125;CKeyboard::~CKeyboard() &#123;&#125;bool CKeyboard::Initialize() &#123; return this-&gt;InitializeKeyboard();&#125;void CKeyboard::Shutdown() &#123; this-&gt;ShutdownKeyboard();&#125;void CKeyboard::ShutdownKeyboard() &#123;&#125;void CKeyboard::KeyDown(const unsigned key) &#123; keys[key] = true;&#125;void CKeyboard::KeyUp(const unsigned key) &#123; keys[key] = false;&#125;bool CKeyboard::IsKeyDown(const unsigned key) &#123; return keys[key];&#125;bool CKeyboard::InitializeKeyboard() &#123; keys = std::vector&lt;bool&gt;(keyCount, false); return true;&#125; &emsp;&emsp;这个也比较简单，然后当我们做完这些后，可以向上给 CInput 中添加内容了。在 CInput 中我们添加了一个 CKeyboard 对象并在 Initialize() 中初始化。 123456789101112131415161718192021222324class CInput &#123;public: ... CKeyboard *mKeyboard_; ...&#125;;bool CInput::Initialize() &#123; mKeyboard_ = new CKeyboard; if (!mKeyboard_) &#123; return false; &#125; this-&gt;InitializeInput(); return true;&#125;void CInput::Shutdown() &#123; if (mKeyboard_) &#123; mKeyboard_-&gt;Shutdown(); delete mKeyboard_; mKeyboard_ = 0; &#125; this-&gt;ShutdownInput();&#125; &emsp;&emsp;而再往上一层，我们可以在 CSystem 类的消息处理函数中更新他们对于键盘的操作了。 123456789101112LRESULT CSystem::MessageHandler(const HWND hwnd, const UINT umsg, const WPARAM wparam, const LPARAM lparam) &#123; switch (umsg) &#123; case WM_KEYDOWN: mInput_-&gt;mKeyboard_-&gt;KeyDown(static_cast&lt;unsigned int&gt;(wparam)); break; case WM_KEYUP: mInput_-&gt;mKeyboard_-&gt;KeyUp(static_cast&lt;unsigned int&gt;(wparam)); break; default: break; &#125; return DefWindowProc(hwnd, umsg, wparam, lparam);&#125; &emsp;&emsp;这样，我们的 CKeyboard 算是完全的添加了进去，接下来看 CMouse 。事实上，DX 中有专门的输入设备 DXInput ，不过我们还没学到。 CMouse 我们暂时只给了获得和设置鼠标位置的方法。 1234567891011121314class CMouse &#123; CMouse(); CMouse(CMouse&amp; mouse); ~CMouse(); bool Initialize(); void Shutdown(); void SetPos(); void GetPos();private: bool InitializeMouse(); void ShutdownMouse();&#125;; &emsp;&emsp;初始化那些方法暂且不表。在 SetPos() 中我们设置光标位置，GetPos() 自然就是读取了。我们会在这两个方法里使用 WINAPI 来获得或者设置数据，等到我们接触了 DXInput 之后会将其代替。 12345678910void CMouse::SetPos(const unsigned int&amp; x, const unsigned int&amp; y) &#123; SetCursorPos(x, y);&#125;void CMouse::GetPos(unsigned int&amp; x, unsigned int&amp; y) &#123; auto*point = new POINT; GetCursorPos(point); x = point-&gt;x; y = point-&gt;y;&#125; &emsp;&emsp;(关于键盘与鼠标这里，只是暂时的这样封装。之后会用 DXInput 来实现 CInput 这个类。)]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂杂碎碎的常识第一弹-C函数指针]]></title>
    <url>%2F2018%2F03%2F20%2F%E6%9D%82%E6%9D%82%E7%A2%8E%E7%A2%8E%E7%9A%84%E5%B8%B8%E8%AF%86%E7%AC%AC%E4%B8%80%E5%BC%B9-C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;闲着无聊不想敲代码，那就没事复复习吧。突然想到这个的原因是因为想起来自己之前看过的一个东西，首先来看这么一个 C 语言语句。 1(*(void(*)())0)(); &emsp;&emsp;如果你之前并没有了解过或者了解函数指针的话，那么肯定会和我刚开始看到一样是懵逼的，这篇文章将围绕这个来介绍函数指针。 &emsp;&emsp;首先说清楚，这是一个函数的调用，算是一个经典的例子，并且和那种纠结于 ++i 和 i++ 的 i++++++i 这种例子不同，这是一个在微处理器上比较常用的语句。某些微处理器我们需要从 0 地址启动，或者有时需要模拟开机启动的情形，需要去设计这么一条语句用来执行 0 地址的内存里的内容（所以这条语句不是为了秀操作而来的哦）。 &emsp;&emsp;在此我假设你对函数指针有一定的概念，或者对指针有一定的概念。 &emsp;&emsp;函数指针，即指向函数的指针。一般定义语句如下： 1void (*pFun)(param); &emsp;&emsp;我们定义函数是 void fun(param) ，函数指针也只是加了一个指针符号而已。而我们定义了函数指针之后，调用如下： 1(*pFun)(param); &emsp;&emsp;现在我们来看我们的神奇语句： (*(void(*)())0)(); ，这是一个函数调用，所以我们可以将其分为两部分，我们以上边的函数调用为例将其看成 (*pFun)(param) ，那么其实 (void(*)())0 其实就是我们 pFun 的部分。 &emsp;&emsp;那么 (void(*)())0 这一串看起来很让人不爽的又是该如何理解呢，如果你还没看出来的话可以试着想想，有什么东西是 (...).. 的形式呢？ &emsp;&emsp;这是一个强制转换的语句，我们刚才说了，这个例子是用来执行 0 地址的内存的内容，如果直接写的话应该是这样： 1(*0)(); &emsp;&emsp;这就是调用 0 地址里边的内容执行的语句，但是函数指针变量又不能是个常数，我们需要对其进行转换，与时就成了 (*(void(*)())0)() 这个样子。所以这个语句的意思就分析出来了，其实是将一个 0 地址强制转换成 void(*)() 函数指针的形式，然后去执行。 &emsp;&emsp;现在，我们将其改成比较简单可以理解的形式： 12typedef void(*pFun)(); // 为 void(*)() 定义别名 pFun;(*(pFun)0)(); &emsp;&emsp;这样，应该可以看得很清楚了。如果你没懂 typedef void(*pFun)(); ，建议去看看 typedef 在 C 语言中的用法。]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Task-Scheduler]]></title>
    <url>%2F2018%2F03%2F20%2FTask-Scheduler%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#621 Task Scheduler 题目描述&emsp;&emsp;Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. &emsp;&emsp;However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. &emsp;&emsp;You need to return the least number of intervals the CPU will take to finish all the given tasks. Example 1: 123Input: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2Output: 8Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. Note: The number of tasks is in the range [1, 10000]. The integer n is in the range [0, 100]. 解题思路&emsp;&emsp;刚开始会错了题意。。。。。浪费了好久的时间，最后还是看了别人的博客才明白过来。 &emsp;&emsp;这道题给定了你一个任务集合，一个代表着每两个相同任务之前必须间隔的时间。所以我们可以出现次数最多的任务来求。假设出现任务最多的是 A ，出现了 K 次，他们每个之间必须间隔 N 个，所以最基础的解就是 (K - 1) * (N + 1)（K 次则代表他们总共有 K-1 处间隔，每个间隔为 N 个，我们将他和 A 任务本身绑定在一起就是 N + 1 个一组，总共有 (k-1) 组和剩下的最后一个）。举个例子，最多的是 A ，出现 3 次，题目给定的是相同任务间隔 2 个。 1A··A··A // (3-1) * (2+1) + 1 &emsp;&emsp;但是如果出现最多的不止一个呢，比如 A , B 同时出现3次最多，那么应该如下： 1AB·AB·AB // (3-1) * (2+1) + 2 &emsp;&emsp;可以看出来，我们最后的解应该如下（ k 为最多次数， n 为相同任务最小间隔，count 为出现最多次数的任务个数）：1result = (k-1) * (n+1) + count; &emsp;&emsp;问题到此并没有结束，这个表达式仅仅是当我们其他的任务可以塞进这些间隔中来计算的。加入其他的任务有很多，除了这些之外还有很多剩余的任务没有完成。我们还应该加上他们，即12result = (k-1) * (n+1) + count + abs( taskCount - (k-1) *((n+1) + count); // 即result = max( (k-1) * (n+1) + count , taskCount); 解题代码【.CPP】12345678910111213141516class Solution &#123;public: int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123; vector&lt;int&gt; taskTimes(26); for (const auto&amp; task : tasks) &#123; ++taskTimes[task - 'A']; &#125; sort(taskTimes.begin() , taskTimes.end() , [](int a , int b)&#123;return a &gt; b;&#125;); int most = 1; for (auto i = 1 ; i &lt; taskTimes.size() ; ++i)&#123; if (taskTimes[i] &lt; taskTimes[i-1]) break; ++most; &#125; return max((taskTimes[0]-1) * (n+1) + most , (int)tasks.size()); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】5-代码框架2-CInput与CGraphics]]></title>
    <url>%2F2018%2F03%2F20%2F%E3%80%90DirectX%E3%80%915-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B62-CInput%E4%B8%8ECGraphics%2F</url>
    <content type="text"><![CDATA[教程地址Tutorial 2: Creating a Framework and Window 学习记录&emsp;&emsp;上一篇文章中，我们构建了一个用于窗口创建的类 CSystem ，并成功使用它启动了窗口。可以看到，在我们封装之后，它的使用及其的方便。而这篇文章中，我们将对其进行扩展，在我们创建窗口后，我们将在主循环中写入程序逻辑。包括我们的鼠标键盘输入以及对应的程序输出，因此，我们将实现 CInput 和 CGraphics 类（之所以不以 COutput 是因为我们的程序不仅仅包含图形一种输出，但我们现在只实现这一种）。在完成今天的两个类后，我们的框架结果将会变为下图的样式 。 &emsp;&emsp;我们的 CInput 类将包含鼠标键盘的处理，鼠标与键盘将成为子类来设计，所以这里的 CInput 类简直简单的可怕。 1234567891011class CInput &#123;public: CInput(); CInput(CInput&amp; input); ~CInput(); bool Initialize(); void Shutdown();private: bool InitializeInput(); void ShutdownInput();&#125;; &emsp;&emsp;这将是我们的 CInput 类声明，它仅仅包含了 Initialize() ， 以及Shutdown()函数，以及构造和析构函数。我们将在之后为这个类添加键盘处理 CKeyboard 和鼠标处理 CMouse 类（下一篇文章再谈）。 &emsp;&emsp;CInput 类的构造方法中我们调用 Initialize() ，而在 Initialize() 中调用 InitializeInput() ，在 Shutdown() 方法里调用 ShutdownInput() 方法。 &emsp;&emsp;现在我们已经有了 CInput 类，则准备在 CSystem 里添加对应的元素 。在 CSystem 的声明里为它添加一个 CInput 的指针对象： 1CInput *mInput_; &emsp;&emsp;在 CSystem 的 Initialize() 里我们将初始化 CInput 指针对象，最后在析构函数里释放掉它。 1234567891011121314bool CSystem::Initialize() &#123; ... this-&gt;mInput_ = new CInput; if (!mInput_) &#123; return false; &#125; ... return true;&#125;void CSystem::Shutdown() &#123; delete mInput_; delete mGraphics_;&#125; &emsp;&emsp;&emsp;现在，再来看看我们的 CGraphics 类： 12345678910111213class CGraphics &#123;public: CGraphics(); CGraphics(CGraphics&amp; cGraphics); ~CGraphics(); bool Initialize(); void Shutdown(); bool Render();private: bool InitializeGraphics(); void ShutdownGraphics(); bool RenderGraphics();&#125;; &emsp;&emsp;我们的 CGraphics 类中的 Initialize() 与 Shutdown() 和 CInput 中的一样，暂且不表。Render() 暂时也是简单的调用了 RenderGraphics() 。而 RenderGraphics() 则是负责了主要的东西，因为我们并没有后续内容，所以在此也暂时不提。 &emsp;&emsp;综上所述，我们的 CGraphics 类也是相当简单，现在和 CInput 一样将他加入到 CSystem 的初始化与结束中去： 123456789101112131415161718192021222324252627bool CSystem::Initialize() &#123; int screenWidth = 1920; int screenHeight = 1080; InitializeWindows(screenWidth, screenHeight); this-&gt;mInput_ = new CInput; if (!mInput_) &#123; return false; &#125; this-&gt;mGraphics_ = new CGraphics; if (!mGraphics_) &#123; return false; &#125; return true;&#125;void CSystem::Shutdown() &#123; if (mInput_) &#123; mInput_-&gt;Shutdown(); delete mInput_; mInput_ = 0; &#125; if (mGraphics_) &#123; delete mGraphics_; mGraphics_ = 0; &#125; ShutdownWindows();&#125; &emsp;&emsp;以上是我们增加了 CInput 和 CGraphics 类后的初始化。但是虽然进行了初始化，但是在代码中却并没有真的调用它，接下来看看在 CSystem 中的调用。 &emsp;&emsp;CInput 我们因为没有具体实现的原因，没什么可以动用的。而 CGraphics 则需要在 Run 方法里进行修改。 123456789101112131415void CSystem::Run() const &#123; MSG msg; ZeroMemory(&amp;msg, sizeof(MSG)); while (msg.message != WM_QUIT) &#123; if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; if (mGraphics_) &#123; mGraphics_-&gt;Render(); &#125; &#125;&#125; &emsp;&emsp;我们在 CSystem::Run() 里调用了 CGraphics::Render() 方法。 &emsp;&emsp;现在，你点击运行，如果没有错误的话，那么那个黑色窗口应该还会出现。 &emsp;&emsp;下一篇我们将会实现 CInput 下的类 CKeyboard 和 CMouse 。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】4-代码框架]]></title>
    <url>%2F2018%2F03%2F19%2F%E3%80%90DirectX%E3%80%914-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在之前的代码中，我们使用了大量的代码去绘制了一个三角形。对于我们来说实在是有点麻烦了，如果每次都需要写这么多的代码的话无疑是很容易让人写崩溃的。在此和之后的几篇文章，我们将会对之前使用的基本功能进行封装。 &emsp;&emsp;此篇所看教程来自：DirectX 11 Tutorials 。 &emsp;&emsp;首先，我们以一个 CSystem 类为总类（我们的代码中类以 C 开头，Class 的意思）。CSystem 类将直接用在我们的 main 方法里，它会封装一些最基本的功能，包括我们所必须的 windows 窗口的创建。来看看我们的 CSystem 类声明： 12345678910111213141516171819class CSystem&#123;public: CSystem(); CSystem(const CSystem&amp;); ~CSystem(); bool Initialize(); void Shutdown(); void Run() const; LRESULT CALLBACK MessageHandler(HWND, UINT, WPARAM, LPARAM) const;private: void InitializeWindows(int&amp;, int&amp;); void ShutdownWindows();private: LPCSTR mApplicationName_; HINSTANCE mHinstance_ = nullptr; HWND mHwnd_;&#125;; &emsp;&emsp;在这个类中封装了不少的变量和函数，我们会依次的解释他们，首先在构造方法中我们初始化那几个 private 变量（稍后我们会介绍每一个变量的作用）。 1234567CSystem::CSystem(): mApplicationName_(nullptr), mHinstance_(nullptr), mHwnd_(nullptr),mInput_(0),mGraphics_(0) &#123; this-&gt;Initialize();&#125;CSystem::CSystem(const CSystem&amp; other) &#123; *this = other; this-&gt;Initialize();&#125; &emsp;&emsp;在这个类中，我们封装了 Initialize 方法，这个方法会调用 InitializeWindows 为我们创建一个窗口，并使用 private 属性 mHwnd 来作为句柄。来看看这两个方法具体的实现： 123456bool CSystem::Initialize() &#123; int screenWidth = 1920; int screenHeight = 1080; InitializeWindows(screenWidth, screenHeight); return true;&#125; &emsp;&emsp;在 CSystem::Initialize() 中，我们只是简单的调用了 InitializeWindows(); （事实上并不止这些，但是现在我们只有这一个类，功能也极其简单）。 &emsp;&emsp;接下来看 InitializeWindows(); 方法： 12345678910111213141516171819202122232425void CSystem::InitializeWindows(int&amp; screenWidth, int&amp; screenHeight)&#123; mApplicationName_ = "DirectX"; mHinstance_ = GetModuleHandle(NULL); WNDCLASS wc; wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC; wc.lpfnWndProc = MessageHandler; wc.cbClsExtra = 0; wc.cbWndExtra = 0; wc.hInstance = mHinstance_; wc.hIcon = LoadIcon(NULL, IDI_WINLOGO); wc.hCursor = LoadCursor(NULL, IDC_ARROW); wc.hbrBackground = static_cast&lt;HBRUSH&gt;(GetStockObject(BLACK_BRUSH)); wc.lpszMenuName = NULL; wc.lpszClassName = mApplicationName_; RegisterClass(&amp;wc); mHwnd_ = CreateWindow(mApplicationName_, mApplicationName_,WS_OVERLAPPEDWINDOW, 0 , 0, screenWidth, screenHeight, NULL, NULL, mHinstance_, NULL); ShowWindow(mHwnd_, SW_SHOW); UpdateWindow(mHwnd_);&#125; &emsp;&emsp;请注意我们在 InitializeWindows 方法里初始化了窗口，但是在设置窗口类的 lpfnWndProc 属性的时候，我们虽然在 CSystem 类里定义了一个 MessageHandler ，但是却无法将他直接用在这里（），所以我们还需要创建一个额外的（不在类里边的 WndProc 方法）。 12345678910111213141516171819// 在 CSystem.h 中定义一个 CSystem 对象和一个 WndProc 方法static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);static CSystem* applicationHandle = 0;// 我们定义的全部 WndProc 方法，并在里边调用了 CSystem 类对象的 MessageHandler 方法。LRESULT CALLBACK WndProc(const HWND hwnd, const UINT umessage, const WPARAM wparam, const LPARAM lparam)&#123; switch (umessage) &#123; case WM_DESTROY: PostQuitMessage(0); return 0; case WM_CLOSE: PostQuitMessage(0); return 0; default: return applicationHandle-&gt;MessageHandler(hwnd, umessage, wparam, lparam); &#125;&#125; &emsp;&emsp;而在 MessageHandler 方法里，我们只是简单的返回了 Windows 默认的消息函数。 123LRESULT CSystem::MessageHandler(const HWND hwnd, const UINT umsg, const WPARAM wparam, const LPARAM lparam) &#123; return DefWindowProc(hwnd, umsg, wparam, lparam);&#125; &emsp;&emsp;初始化方法结束后，我们使用 CSystem::Run(); 来启动窗口： 12345678910111213void CSystem::Run() const &#123; MSG msg; ZeroMemory(&amp;msg, sizeof(MSG)); while (!msg.message != WM_QUIT) &#123; // Handle the windows messages. if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125;&#125; &emsp;&emsp;Run(); 方法里我们则是简单的封装了消息循环。当然，这里将是之后添加内容的主要地方。 &emsp;&emsp;最后，我们还有 Shutdown(); 和 ShutdownWindows(); 尚未介绍，和初始化一样，public 的 Shutdown(); 也只是简单的调用了 ShutdownWindows(); 。 123void CSystem::Shutdown() &#123; ShutdownWindows();&#125; &emsp;&emsp;在 CSystem::ShutdownWindows() 中则是什么都没有做（暂时不需要）。 12void CSystem::ShutdownWindows() &#123;&#125; &emsp;&emsp;这样，我们只是简单的将窗口的初始化封装到了类中，可以现在来试试效果： 12345int WINAPI WinMain(HINSTANCE hInstance , HINSTANCE hPrevInstance , LPSTR lpCmdLine , INT nCmdShow) &#123; CSystem *system = new CSystem; system-&gt;Run(); return 0;&#125; &emsp;&emsp;点击启动，成功应该是一个黑色的窗口：]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Single-Number-II]]></title>
    <url>%2F2018%2F03%2F19%2FSingle-Number-II%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#137 Single Number II 题目描述&emsp;&emsp;Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. 解题思路&emsp;&emsp;将数组排序，之后遍历查找就可以了。直接看代码 解题代码【.CPP】12345678910111213141516class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin() , nums.end()); bool isDup = false; for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[i] != nums[i-1])&#123; if (!isDup) return nums[i-1]; isDup = false; &#125; else &#123; isDup = true; &#125; &#125; return nums[nums.size()-1]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】3-D3D三角形]]></title>
    <url>%2F2018%2F03%2F18%2F%E3%80%90DirectX%E3%80%913-D3D%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇文章中我们介绍了 交换链，设备，设备上下文 等等名词，并成功创建了他们，这篇中我们将和学习 OpenGL 时一样去使用三个顶点来绘制一个三角形。 &emsp;&emsp;这篇中将要介绍的则是 ID3D11Buffer（缓冲） ，ID3D11VertexShader(顶点着色器) 和 ID3D11PixelShader(像素着色器) 这几个东西，我们将顶点数组构图，使用着色器填色。（事实上和我们的 OpenGL 基本一样） &emsp;&emsp;在 OpenGL 中我们使用 glm 数学库（OpenGL Mathematics），而在 DirectX 中则是使用 XM 库（DirectXMath）。首先定义一个三角形的顶点： 12345678910struct Vertex &#123; // 定义一个顶点结构体，暂时就一个坐标属性 DirectX::XMFLOAT3 pos;&#125;;Vertex vertices[] = // 顶点数组&#123; DirectX::XMFLOAT3(0.0f, 0.3f, 0.3f), DirectX::XMFLOAT3(0.3f, -0.3f, 0.3f), DirectX::XMFLOAT3(-0.3f, -0.3f, 0.3f),&#125;; &emsp;&emsp;现在使用 D3D11_BUFFER_DESC 创建定点缓冲描述， 123456// 缓存信息描述D3D11_BUFFER_DESC vertexBufferDesc;ZeroMemory(&amp;vertexBufferDesc, sizeof(vertexBufferDesc));vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT; // 默认使用vertexBufferDesc.ByteWidth = sizeof(Vertex) * 3; // 大小（我们有三个顶点）vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; // Bind &emsp;&emsp;创建 D3D11_SUBRESOURCE_DATA ： 123D3D11_SUBRESOURCE_DATA verticesSourceData;ZeroMemory(&amp;verticesSourceData, sizeof(D3D11_SUBRESOURCE_DATA));verticesSourceData.pSysMem = vertices; &emsp;&emsp;最后定义 ID3D11Buffer *pVertexBufferObject = nullptr; 将他初始化，接下来使用我们的设备对象来创建一个缓冲： 1pDevice-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;verticesSourceData, &amp;pVertexBufferObject); &emsp;&emsp;这几段代码就是为了创建缓冲而来。 &emsp;&emsp;在 OpenGL 中，我们现在应该去使用一个 VertexArraysObject（VAO）来描述这个缓冲，但是在 DirectX 中右上下文设备的存在，我们直接使用上下文： 1234UINT stride = sizeof(Vertex);UINT offset = 0;pImmediateContext-&gt;IASetVertexBuffers(0, 1, &amp;pVertexBufferObject, &amp;stride, &amp;offset);pImmediateContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); &emsp;&emsp;我们使用立即上下文对象 pImmediateContext 来接手这一段顶点数据缓冲。现在你如果直接在主循环里绘制的话，会得到一个消息：A Vertex Shader is always required when drawing, but none is currently bound. 因此我们在绘制的时候必须为其配置着色器程序。 &emsp;&emsp;与 DirectX 配套的着色器程序语言叫做 HLSL（High Level Shading Language），它也是使用文本文件来写，然后在 DirectX 代码中编译。首先我们来放两个最简单的着色器代码，顶点着色器和像素着色器（对应 OpenGL 中的片段着色器）： 12345678910//triangle.vs 顶点着色器float4 Main( float4 Pos : POSITION ) : SV_POSITION&#123; return Pos;&#125;//triangle.ps 像素着色器float4 Main( float4 Pos : SV_POSITION ) : SV_TARGET&#123; return float4( 1.0f, 1.0f, 0.0f, 1.0f ); &#125; &emsp;&emsp;相比而言，HLSL 的代码看起来更简单一点。我们直接定义了 Main 方法（需要注意的是 hlsl 的入口方法并非固定，当你启动编译的时候需要指定入口方法，也就是说是由你决定命名的）。在这里需要看一下 SV_POSITION 和 POSITION 以及 SV_TARGET 这三个变量。SV_POSITION 和 POSITION 无疑都是用来描述位置坐标的标识，而区别是 SV_POSITION 用来代表经过顶点着色器变换后的坐标。SV是Systems Value的简写，在SV_POSITION的情况下，如果它是绑定在一个从顶点着色器输出的数据结构上的话，意味着这个输出的数据结构包含了最终的转换过的，将用于光栅器的顶点坐标。 &emsp;&emsp;也就是说，顶点着色器接收未经处理的原始坐标，在顶点着色器中处理后送给像素着色器（虽然这个例子上我们并未处理）。然后 SV_TARGET 标识则是这个函数返回一个传递给下一阶段的值（也就是最终的OutPut Merger 的颜色值）。 &emsp;&emsp;如果需要了解更多的 HLSL 知识，可以去 MSDN 看一下（MSDN 是所有 Windows 程序员要翻烂的地方）。 &emsp;&emsp;接下来，我们对这两个着色器进行编译： 123ID3D10Blob* pErrorMessage = nullptr;ID3D10Blob* pVertexShaderBlob = nullptr;ID3D10Blob* pPixelShaderBlob = nullptr; &emsp;&emsp;首先定义顶点着色器 Blob 对象和像素着色器 Blob 对象以及用来查错的对象。之后调用 D3DX11CompileFromFile 来进行编译，先来看看这个方法的参数： 12345678910111213HRESULT D3DX11CompileFromFile( _In_ LPCTSTR pSrcFile, // 源文件 _In_ const D3D10_SHADER_MACRO *pDefines, // 可选项 为 NULL _In_ LPD3D10INCLUDE pInclude, // NULL _In_ LPCSTR pFunctionName, // 入口函数名称 _In_ LPCSTR pProfile, // 配置信息 （ps_x_x 像素 ,vs_x_x 顶点） _In_ UINT Flags1, // 参数配置 _In_ UINT Flags2, // 参数配置 _In_ ID3DX11ThreadPump *pPump, // NULL _Out_ ID3D10Blob **ppShader, // shader 对象 _Out_ ID3D10Blob **ppErrorMsgs, // 错误信息对象 _Out_ HRESULT *pHResult //NULL); &emsp;&emsp;具体使用如下： 1234567891011121314// 编译顶点着色器hr = D3DX11CompileFromFile("./triangle.vs", nullptr, nullptr, "Main", "vs_5_0", D3DCOMPILER_STRIP_DEBUG_INFO , 0, nullptr, &amp;pVertexShaderBlob, &amp;pErrorMessage, nullptr);if (FAILED(hr)) &#123; if (pErrorMessage) MessageBox(NULL, static_cast&lt;CHAR*&gt;(pErrorMessage-&gt;GetBufferPointer()), "Error", MB_OK); else MessageBox(NULL, "Triangle.vs File Not Found", "Error", MB_OK); return hr;&#125;// 编译像素着色器hr = D3DX11CompileFromFile("./triangle.ps", nullptr, nullptr, "Main", "ps_5_0", D3DCOMPILER_STRIP_DEBUG_INFO , 0, nullptr, &amp;pPixelShaderBlob, &amp;pErrorMessage, nullptr);if (FAILED(hr)) &#123; if (pErrorMessage) MessageBox(NULL, static_cast&lt;CHAR*&gt;(pErrorMessage-&gt;GetBufferPointer()), "Error", MB_OK); else MessageBox(NULL, "Triangle.vs File Not Found", "Error", MB_OK); return hr;&#125; &emsp;&emsp;在编译成功后，我们使用设备对象来创建顶点着色器和像素着色器： 12345678910hr = pDevice-&gt;CreateVertexShader(pVertexShaderBlob-&gt;GetBufferPointer(), pVertexShaderBlob-&gt;GetBufferSize(), nullptr, &amp;pVertexShader);if (FAILED(hr)) &#123; MessageBox(NULL, "ERROR::CreateVertexShader", "Error", MB_OK); return hr;&#125;hr = pDevice-&gt;CreatePixelShader(pPixelShaderBlob-&gt;GetBufferPointer(), pPixelShaderBlob-&gt;GetBufferSize(), nullptr, &amp;pPixelShader);if (FAILED(hr)) &#123; MessageBox(NULL, "ERROR::CreateVertexShader", "Error", MB_OK); return hr;&#125; &emsp;&emsp;在顶点着色器中，我们使用了 POSITION ，在 DirectX 代码中创建一个 InputLayout 来描述 input-assembler 阶段的数据。 12345678D3D11_INPUT_ELEMENT_DESC layout[] = &#123; &#123; "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 &#125; &#125;;const UINT numElements = ARRAYSIZE( layout );hr = pDevice-&gt;CreateInputLayout(layout, numElements, pVertexShaderBlob-&gt;GetBufferPointer(), pVertexShaderBlob-&gt;GetBufferSize(), &amp;pInputLayout);if (FAILED(hr)) &#123; MessageBox(NULL, "ERROR::CreateInputLayout", "Error", MB_OK); return hr;&#125;pImmediateContext-&gt;IASetInputLayout(pInputLayout); // 设置 &emsp;&emsp;DX 中多数 API 都有着及其繁杂的参数，限于篇幅在这里写者并没有全部列出来，最详细的信息还是首推 MSDN （话说我推荐过多少次了）。 &emsp;&emsp;这些都结束后，我们在主循环里绘制它： 1234567891011121314MSG msg;ZeroMemory(&amp;msg, sizeof(MSG));while (msg.message != WM_QUIT) &#123; float color[] = &#123; 0.1f , 0.2 , 0.5f , 1.0f &#125;; pImmediateContext-&gt;ClearRenderTargetView(pRenderTargetView, color); pImmediateContext-&gt;VSSetShader(pVertexShader, nullptr, 0); //set vs pImmediateContext-&gt;PSSetShader(pPixelShader, nullptr, 0); //set ps pImmediateContext-&gt;Draw(3, 0); //draw pSwapChain-&gt;Present(0, 0); if (PeekMessage(&amp;msg, nullptr, 0, 0, PM_REMOVE)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125;&#125; &emsp;&emsp;如果代码没有错的话应该可以看到这样一个效果：]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unique-Paths]]></title>
    <url>%2F2018%2F03%2F18%2FUnique-Paths%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#62 Unique Paths 题目描述&emsp;&emsp;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). &emsp;&emsp;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). &emsp;&emsp;How many possible unique paths are there? &emsp;&emsp;Above is a 3 x 7 grid. How many possible unique paths are there? &emsp;&emsp;Note: m and n will be at most 100. 解题思路&emsp;&emsp;一看到这题就想到无脑递归，但是最后看了看，觉得很有可能会 TEL ，所以放弃选择了 DP 。我们可以简单推出 Start （DP[0][0]） 到 Finish 的路径个数等于他的下边方格（DP[1][0]）和右边方格（DP[0][1]）之和。继续往下推也是这个道理，所以最后有递推公式： dp[i][j] = dp[i+1][j] + dp[i][j+1]; 解题代码【.CPP】1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m , vector&lt;int&gt;(n , 0)); dp[m-1][n-1] = 1; for (int i = m-1; i &gt;= 0; --i) &#123; for (int j = n-1; j &gt;= 0; --j) &#123; if (i+1 &lt; m) dp[i][j] += dp[i+1][j]; if (j+1 &lt; n) dp[i][j] += dp[i][j+1]; &#125; &#125; return dp[0][0]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】Breakout-7-实现消除和挡板效果]]></title>
    <url>%2F2018%2F03%2F17%2F%E3%80%90OpenGL%E3%80%91Breakout-7-%E5%AE%9E%E7%8E%B0%E6%B6%88%E9%99%A4%E5%92%8C%E6%8C%A1%E6%9D%BF%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在我们的游戏中，我们需要使用弹性球去破坏所有的可以破坏的东西来得到游戏的胜利。关于碰撞的检测，这篇文章中我们有所提到：【OpenGL】25-碰撞检测 。这篇文章则是实际运用这个来实现游戏逻辑。 &emsp;&emsp;我们的游戏中，弹性球是圆形，方块和挡板都是矩形，所以我们使用矩形与圆的碰撞检测算法。首先创建一个检测碰撞的方法： 12345public Game &#123; ... bool CollisionDetection(const GameObject &amp;brick,const BallObject &amp;ball) const; ...&#125; &emsp;&emsp;在 Game.cpp 里我们实现这个方法： 123456789101112131415bool Game::CollisionDetection(const GameObject&amp; brick, const BallObject&amp; ball) const &#123; // 求矩形和圆中点坐标 const glm::vec2 brickCenterPos = brick.position + glm::vec2(brick.size.x / 2.0, brick.size.y / 2.0); const glm::vec2 ballCenterPos = ball.position + glm::vec2(ball.radius / 2); // 求矢量 const glm::vec2 vecBrickToBall = ballCenterPos - brickCenterPos; // 限制矢量并求最近点 const glm::vec2 pos = brickCenterPos + glm::vec2(glm::max(glm::min(brick.size.x / 2, vecBrickToBall.x), -brick.size.x / 2), glm::max(glm::min(brick.size.y / 2, vecBrickToBall.y), -brick.size.y / 2)); // 判断碰撞 return glm::distance(pos, ballCenterPos) &lt; ball.radius;&#125; &emsp;&emsp;现在我们已经可以判断是否碰撞了，实现碰撞后可破坏的方块被破坏也很简单了，在 Update 里我们遍历当前的所有砖块来进行碰撞检测，当某个砖块发生碰撞的时候，如果它可以被破坏，则直接修改他的值。 12345678910111213141516/** * 更新游戏状态 */void Game::Update(const GLfloat dt) &#123; if (this-&gt;state == GAME_ACTIVE) &#123; ball.Move(dt, width); for(GameObject&amp; obj : levels[level].bricks) &#123; if (CollisionDetection(obj , ball)) &#123; if (!obj.isSolid) &#123; obj.destroyed = true; &#125; &#125; &#125; &#125;&#125; &emsp;&emsp;当碰撞到的砖块可以破坏的时候我们销毁他，如果不可以破坏呢？我们会进行反弹操作，如果碰撞在它的 X 轴边上（上下两个边）则对弹性球的 Y 速度坐标取负值，碰撞在 Y 轴边上则是 X 取负值。 &emsp;&emsp;我们修改判断碰撞方式给他添加一个引用参数来返回碰撞边的信息，修改后的碰撞检测方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546bool Game::CollisionDetection(const GameObject&amp; brick, const BallObject&amp; ball , int&amp; xy) const &#123; // 求矩形和圆中点坐标 const glm::vec2 brickCenterPos = brick.position + glm::vec2(brick.size.x / 2.0, brick.size.y / 2.0); const glm::vec2 ballCenterPos = ball.position + glm::vec2(ball.radius / 2); // 求矢量 const glm::vec2 vecBrickToBall = ballCenterPos - brickCenterPos; // 限制矢量并求最近点 const glm::vec2 pos = brickCenterPos + glm::vec2(glm::max(glm::min(brick.size.x / 2, vecBrickToBall.x), -brick.size.x / 2), glm::max(glm::min(brick.size.y / 2, vecBrickToBall.y), -brick.size.y / 2)); const glm::vec2 velo = glm::normalize(ball.velocity); float f; if (dots[0] &gt;= 0 &amp;&amp; dots[0] &lt;= 1 &amp;&amp; dots[1] &gt;= 0 &amp;&amp; dots[1] &lt;= 1) &#123; f = glm::dot(compess[1], compess[4]); xy = dots[1] &gt;= f ? 0 : 3; if (dots[1] == f &amp;&amp; glm::dot(compess[4] , velo) == -1) &#123; xy = 4; &#125; &#125; if (dots[1] &gt;= 0 &amp;&amp; dots[1] &lt;= 1 &amp;&amp; dots[2] &gt;= 0 &amp;&amp; dots[2] &lt;= 1) &#123; f = glm::dot(compess[2], compess[5]); xy = (dots[2] &gt;= f ? 1 : 0); if (dots[2] == f &amp;&amp; glm::dot(compess[5] , velo) == -1) &#123; xy = 4; &#125; &#125; if (dots[2] &gt;= 0 &amp;&amp; dots[2] &lt;= 1 &amp;&amp; dots[3] &gt;= 0 &amp;&amp; dots[3] &lt;= 1) &#123; f = glm::dot(compess[3], compess[6]); xy = (dots[3] &gt;= f ? 2 : 1); if (dots[3] == f &amp;&amp; glm::dot(compess[6] , velo) == -1) &#123; xy = 4; &#125; &#125; if (dots[3] &gt;= 0 &amp;&amp; dots[3] &lt;= 1 &amp;&amp; dots[0] &gt;= 0 &amp;&amp; dots[0] &lt;= 1) &#123; f = glm::dot(compess[0], compess[7]); xy = (dots[0] &gt;= f ? 3 : 2); if (dots[0] == f &amp;&amp; glm::dot(compess[7] , velo) == -1) &#123; xy = 4; &#125; &#125; // 判断碰撞 return glm::distance(pos, ballCenterPos) &lt; ball.radius;&#125; &emsp;&emsp;事实上我们更应该使用枚举来代表1，2，3，代码更清晰一些。比如这样： 1234567enum Direction &#123; RIGHT, DOWN, LEFT, UP, CORNER&#125;; &emsp;&emsp;然后我们修改碰撞检测方法中的 1，2，3 为枚举值。之后便可以在 Update 中根据 xy 引用变量带回来的值来判断弹性球碰到不可破坏砖块的反弹情况： 12345678910111213141516171819202122232425/** * 更新游戏状态 */void Game::Update(const GLfloat dt) &#123; if (this-&gt;state == GAME_ACTIVE) &#123; ball.Move(dt, width); for(GameObject&amp; obj : levels[level].bricks) &#123; int xy = 0; if (CollisionDetection(obj , ball , xy)) &#123; if (!obj.isSolid) &#123; obj.destroyed = true; &#125; else &#123; if (xy == COLLISTION_X) &#123; // 碰撞在 X 轴边上 ball.velocity.y = -ball.velocity.y; &#125; else if(xy == COLLISTION_Y) &#123; ball.velocity.x = -ball.velocity.x; &#125; else &#123; ball.velocity.y = -ball.velocity.y; ball.velocity.x = -ball.velocity.x; &#125; &#125; &#125; &#125; &#125;&#125; &emsp;&emsp;最后，我们实现挡板和弹性球的碰撞检测，当弹性球碰到挡板的上边时反弹，左右两边和下边则直接死亡。在 Update 方法中加入： 123if (CollisionDetection(player, ball, xy) &amp;&amp; xy == UP) &#123; ball.velocity.y = -ball.velocity.y;&#125; &emsp;&emsp;当弹性球落入下边界，则死亡重置： 1234567if (ball.position.y &gt;= height) &#123; player.position = glm::vec2(static_cast&lt;GLfloat&gt;(width) / 2 - player.size.x / 2, height - player.size.y / 2); ball.Reset(player.position + glm::vec2(player.size.x / 2 - ball.radius, -player.size.y + ball.radius), glm::vec2(50.0f, -50.0f)); for (auto&amp; obj : levels[level].bricks) &#123; obj.destroyed = false; &#125;&#125; &emsp;&emsp;最后添加胜利结果： 123if (levels[level].IsCompleted()) &#123; ball.Reset(player.position + glm::vec2(player.size.x / 2 - ball.radius, -player.size.y + ball.radius), glm::vec2(50.0f, -50.0f));&#125; &emsp;&emsp;最终代码看这里：Github]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elimination-Game]]></title>
    <url>%2F2018%2F03%2F17%2FElimination-Game%2F</url>
    <content type="text"><![CDATA[题目地址&emsp;&emsp;There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. &emsp;&emsp;Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. &emsp;&emsp;We keep repeating the steps again, alternating left to right and right to left, until a single number remains. &emsp;&emsp;Find the last number that remains starting with a list of length n. Example: 123456789Input:n = 9,1 2 3 4 5 6 7 8 92 4 6 82 66Output:6 解题思路&emsp;&emsp;题目要求按照给定的顺序多次删除数组内容：首先按照从左到右删除奇数索引上的数字，然后从右到左删除奇数索引上的数字。依次循环直到只剩一个数字然后返回这个数字。 &emsp;&emsp;以下这个霸气的解法不是我自己的（很惭愧智商不够），这个解法将题目分为镜像的子题目，使用递归求解。 &emsp;&emsp;After first elimination, all the numbers left are even numbers.Divide by 2, we get a continuous new sequence from 1 to n / 2.For this sequence we start from right to left as the first elimination.Then the original result should be two times the mirroring result of lastRemaining(n / 2). 解题代码【.CPP】123456class Solution &#123;public: int lastRemaining(int n) &#123; return n == 1 ? 1 : 2 * (n / 2 + 1 - lastRemaining(n / 2)); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】25-碰撞检测]]></title>
    <url>%2F2018%2F03%2F17%2F%E3%80%90OpenGL%E3%80%9125-%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇文章中，我们将介绍 2D碰撞检测（2D Collision detection） 。在我们的 Breakout 游戏中，我们将使用碰撞检测来实现弹性球销毁可破坏方块功能。 &emsp;&emsp;首先介绍我们可能用到的几个碰撞检测算法。我们在处理碰撞检测时，并不会用物体本身的顶点数据，而是使用它的近似几何来判断，比如我们的方块的近似几何自然就是长方形的，我们的弹性球近似几何就是圆形。 &emsp;&emsp;AABB（Axis-aligned Bounding Box）即轴对齐碰撞箱，它使用正方形的轴来判断是否发生碰撞。AABB-AABB则是两个矩形的碰撞检测。当两个矩形的 X ，Y 轴都发生重合时，则这两个矩形发生了碰撞。而判断轴重合则可以根据两个矩形的中点轴距离（在某一个轴上的距离）和中点到各自的变距离之差来判断 &emsp;&emsp;我们用代码来计算： 12345bool CollisionDetection(Rectangle ra , Rectangle rb)&#123; bool xc = (abs(ra.pos.x - rb.pos.x) - (ra.size.x + rb.size.x)) &gt; 0; //判断 x 轴是否重合 bool yc = (abs(ra.pos.y - rb.pos.y) - (ra.size.y + rb.size.y)) &gt; 0; //判断 y 轴是否重合 return xc &amp;&amp; yc; //x y 轴都重合时发生碰撞&#125; &emsp;&emsp;注意：AABB-AABB 只能检测到没有旋转过的矩形之间的碰撞。 &emsp;&emsp;除了 AABB-AABB ，我们来再看下矩形和圆之间的的碰撞检测。矩形和圆的碰撞检测则是根据矩形到圆的最近点到圆的距离和圆半径长度比较的，到圆的距离小于圆的半径则发生了碰撞。这个算法较为麻烦的就是求矩形到圆的最近的点，看下图： &emsp;&emsp;我们使用圆和矩形的中点的矢量（圆中点坐标 - 矩形中点坐标），然后使用矩形的半边长来限制这个矢量使得它与矩形中心相加的点不会超出矩形的范围。最后我们用矩形的中心点加上这个限制后的向量。如下： 12345678910111213bool CollisionDetection(Rectangle ra , Circle cb)&#123; //求矢量 vec2 v2; v2.x = cb.pos.x - ra.pos.x; v2.y = cb.pos.y - ra.pos.y; //限制其范围 v2.x = min(ra.size.x , max(-ra.size.x , v2.x)); v2.y = min(ra.size.y , max(-ra.size.y , v2.y)); //求最近点的坐标 vec2 pos = v2 + ra.pos; //返回碰撞检测结果 （距离小于半径时） return sqrt(pow(pos.x - cb.pos.x,2) , pow(pos.y - cb.pos,y , 2)) &lt; cb.radius;&#125; &emsp;&emsp;最后来看看两个圆之间的碰撞吧，这个比较简单，直接判断两中点坐标的距离和半径之和的差值就可以了： 1234bool CollisionDetection(Circle ca , Circle cb)&#123; //返回碰撞检测结果 （距离小于半径时） return sqrt(pow(ca.pos.x - cb.pos.x,2) , pow(ca.pos.y - cb.pos,y , 2)) &lt; ca.radius + cb.radius;&#125;]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】2-初识DirectX11]]></title>
    <url>%2F2018%2F03%2F16%2F%E3%80%90DirectX%E3%80%912-%E5%88%9D%E8%AF%86DirectX11%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本篇文章主要介绍 DirectX 库以及 DirectX 的初始化，在此之前我们需要来配置 DirectX 系统环境。 &emsp;&emsp;DX 的配置还是很方便的，这里是 DX11 SDK 的下载地址，在微软 DC 下载后，直接一路 Next 就可以成功安装了 。之后打开 Visual Studio，建立新项目，在项目属性的 VC++ 目录的 Include 加入 DX 安装路径里的 Include 文件夹， Library 加入 Libs 文件夹（这个和 OpenGL 在 Visual Studio 下的配置基本相同，不多介绍）。 &emsp;&emsp;配置好了之后，我们先建立一个 Win32 窗口，这个我们在第一篇文章中有介绍。建立完毕后现在开始配置 DX11 （希望你不会被这一个配置吓得失去信心）。 &emsp;&emsp;首先看一下 D3D 程序的基本结构：（如果你对 DX 一点基本概念都没有，可以看这里 DirectX 维基百科） &emsp;&emsp;我们今天要做的，就是初始化 D3D 程序这里，当显示了一个窗口后，下面继续创建一个Direct3D 11设备，这个设备用于绘制3D场景。首先必须创建三个对象：一个设备、一个立即执行上下文（immediate context）和一个交换链（Swap Chain），立即执行上下文对象是Direct3D 11中新添加的。 &emsp;&emsp;设备对象用于将内容绘制在一个缓冲中，设备还包含创建资源的方法。 &emsp;&emsp;交换链即表示对缓冲的操作，这些缓冲就是设备绘制的和显示在屏幕上的内容。交换链包含两个或两个以上的缓冲，主要是前缓冲和后备缓冲，它们就是设备绘制形成的纹理，用于显示在屏幕上。前缓冲（front buffer）就是当前显示在屏幕上的内容，这个缓冲是只读的，无法修改。后备缓冲（back buffer）是设备将要绘制的渲染目标，一旦它完成了绘制操作，交换链就会通过交换前缓冲和后备缓冲，将后备缓冲的内容显示在屏幕上，此时后备缓冲就变成了前缓冲。 &emsp;&emsp;交换链在 DX 中有定义好的结构体 DXGI_SWAP_CHAIN_DESC 12345678910typedef struct DXGI_SWAP_CHAIN_DESC &#123; DXGI_MODE_DESC BufferDesc; // 描述后台缓冲的结构体 DXGI_SAMPLE_DESC SampleDesc; // 描述多重采样的结构体 DXGI_USAGE BufferUsage; // 对于交换链，为DXGI_USAGE_RENDER_TARGET_OUTPUT UINT BufferCount; // 后台缓冲数量 HWND OutputWindow; // 将要渲染到窗口的句柄 BOOL Windowed; // 以窗口（window）还是全屏（full-screen）模式运行 DXGI_SWAP_EFFECT SwapEffect; // 设为DXGI_SWAP_EFFECT_DISCARD，让显卡驱动程序选择最高效的显示模式 UINT Flags; // 通常为 0&#125; DXGI_SWAP_CHAIN_DESC; &emsp;&emsp;在 DXGI_SWAP_CHAIN_DESC 结构体中又嵌套了多个结构体，我们主要看一下第一个：DXGI_MODE_DESC 12345678typedef struct DXGI_MODE_DESC &#123; UINT Width; // 宽度 UINT Height; // 高度 DXGI_RATIONAL RefreshRate; // 刷新率 hz DXGI_FORMAT Format; // 显示格式 RGB RGBA DXGI_MODE_SCANLINE_ORDER ScanlineOrdering; // scanling mode DXGI_MODE_SCALING Scaling; // scanling mode&#125; DXGI_MODE_DESC; &emsp;&emsp;现在，我们去配置一个交换链： 1234567891011121314// 配置交换链DXGI_SWAP_CHAIN_DESC ds;ZeroMemory(&amp;ds, sizeof(DXGI_SWAP_CHAIN_DESC));ds.BufferCount = 1;ds.BufferDesc.Width = width;ds.BufferDesc.Height = height;ds.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;ds.BufferDesc.RefreshRate.Numerator = 60;ds.BufferDesc.RefreshRate.Denominator = 1;ds.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;ds.OutputWindow = window;ds.SampleDesc.Count = 1;ds.SampleDesc.Quality = 0;ds.Windowed = TRUE; &emsp;&emsp;配置完成后，我们调用 D3D11CreateDeviceAndSwapChain 方法创建交换链： 123456789101112131415161718192021222324252627282930313233343536373839404142434445IDXGISwapChain* pIdxgiSwapChain = nullptr;ID3D11RenderTargetView* pD3D11RenderTargetView = nullptr;ID3D11Device* pD3D11Device = nullptr;ID3D11DeviceContext* pImmediateContext = nullptr;D3D_DRIVER_TYPE gD3DDriverType = D3D_DRIVER_TYPE_NULL;D3D_FEATURE_LEVEL pD3DFeatureLevel = D3D_FEATURE_LEVEL_11_0;D3D_DRIVER_TYPE driverTypes[] =&#123; D3D_DRIVER_TYPE_HARDWARE, D3D_DRIVER_TYPE_WARP, D3D_DRIVER_TYPE_REFERENCE,&#125;;const auto numDriverTypes = ARRAYSIZE(driverTypes);D3D_FEATURE_LEVEL featureLevels[] =&#123; D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_10_0,&#125;;const auto numFeatureLevels = ARRAYSIZE(featureLevels);HRESULT hr = S_OK;for (auto driverType : driverTypes) &#123; hr = D3D11CreateDeviceAndSwapChain( nullptr, driverType, nullptr, createDeviceFlags, featureLevels, numFeatureLevels, D3D11_SDK_VERSION, &amp;ds, &amp;pIdxgiSwapChain, &amp;pD3D11Device, &amp;pD3DFeatureLevel, &amp;pImmediateContext); if (SUCCEEDED(hr)) &#123; break; &#125;&#125;if (FAILED(hr)) &#123; return hr;&#125; &emsp;&emsp;请注意在这里我们定义了 IDXGISwapChain* pIdxgiSwapChain = nullptr; （交换链），ID3D11RenderTargetView* pD3D11RenderTargetView = nullptr; （渲染目标视图） ， ID3D11Device* pD3D11Device = nullptr; （设备），ID3D11DeviceContext* pImmediateContext = nullptr; （设备上下文）等多个指针。这几个指针的全部信息请参考 MSDN （我也是看 MSDN 的）。 &emsp;&emsp;交换链创建成功后，我们创建一个渲染目标视图（Render Target View）： &emsp;&emsp;渲染目标视图是Direct3D 11中一种资源视图（resource view）。资源视图可以让一个资源绑定到图形管线的某个阶段。可以将资源视图看成C中的类型转换，C中的一块 原始内存（raw memory） 可以被转换为任意数据结构，我们可以将一块内存转换为整数数组，浮点数数组，结构，结构数组等。如果我们不知道原始内存的类型，那么它对我们来说用处不大。Direct3D11的资源视图工作原理类似，例如一张2D纹理就类似于一块原始内存，就是一种原始基础资源，有了这个原始资源，我们就可以创建不同的资源视图将这个纹理以不同的格式绑定到图形管线的不同阶段，而不同的格式可以是要绘制的渲染目标，接收深度信息的深度模板缓冲，或者也可以是一个纹理资源。C中的类型转换可以以不同方式使用一块内存，而在Direct3D11中是资源视图进行类似的操作。 &emsp;&emsp;因为我们需要将交换链中的后备缓冲绑定为一个渲染目标，所以需要创建一个渲染目标视图，这样Direct3D11就可以在其上进行绘制了。我们首先调用 GetBuffer() 方法获取后备缓冲对象。我们可以使用一个 D3D11_RENDERTARGETVIEW_DESC 结构体表示要创建的渲染目标视图，这个结构体通常是 CreateRenderTargetView 方法的第二个参数。但是，在本教程中，默认的渲染目标视图就能满足需要，所以第二个参数为NULL表示使用默认的渲染目标视图。创建了渲染目标视图后，我们就可以调用 OMSetRenderTargets() 方法将它绑定到图形管线，这样管线的绘制输出被写到了后备缓冲中。 &emsp;&emsp;简单来说，就是创建一个缓冲，代码如下： 12345678910111213141516171819// 创建渲染目标视图ID3D11Texture2D *pId3D11Texture2D = nullptr;hr = pIdxgiSwapChain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast&lt;LPVOID*&gt;(&amp;pId3D11Texture2D));if (FAILED(hr)) &#123; return hr;&#125;hr = pD3D11Device-&gt;CreateRenderTargetView(pId3D11Texture2D, nullptr, &amp;pD3D11RenderTargetView);if (FAILED(hr)) &#123; return hr;&#125;pImmediateContext-&gt;OMSetRenderTargets(1, &amp;pD3D11RenderTargetView, nullptr);D3D11_VIEWPORT dv;dv.Width = width;dv.Height = height;dv.MaxDepth = 1;dv.MinDepth = 0;dv.TopLeftX = 0;dv.TopLeftY = 0;pImmediateContext-&gt;RSSetViewports(1, &amp;dv); &emsp;&emsp;（这部分内容实在是没办法，Win 系列的 API 本来就丑，而且还多，即使理解了他的工作机制还是要死记硬背这些内容） &emsp;&emsp;完成创建视图后，就可以开始渲染了，我们在主循环中使用立即执行上下文对象（pImmediateContext）来进行渲染。 123456789while (uMsg.message != WM_QUIT) &#123; float clearColor[4] = &#123; 0.1f , 0.2f , 0.5f , 0.3f &#125;; // 颜色数组 RGBA pImmediateContext-&gt;ClearRenderTargetView(pD3D11RenderTargetView, clearColor); pIdxgiSwapChain-&gt;Present(0, 0); if (PeekMessage(&amp;uMsg, nullptr, 0, 0, PM_REMOVE)) &#123; TranslateMessage(&amp;uMsg); DispatchMessage(&amp;uMsg); &#125; &#125; &emsp;&emsp;我们定义了一个 Color （包含 RGBA）数组，然后用 pImmediateContext 的 ClearRenderTargetView 来进行颜色渲染。最终效果如下： &emsp;&emsp;如果你没有看到这个窗口，那么可以看这里：GitHub]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】Breakout-6-弹性球]]></title>
    <url>%2F2018%2F03%2F16%2F%E3%80%90OpenGL%E3%80%91Breakout-6-%E5%BC%B9%E6%80%A7%E7%90%83%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在上一篇文章之后，我们已经实现了基本的游戏场景绘制，但只是个静态的图像，要让它彻底玩起来还需要很多东西。现在我们来实现这个游戏中最重要的一部分：弹性球（Elastic ball） 。 &emsp;&emsp;首先我们将他渲染出来，弹性球既属于 GameObjcet 又有他自己的属性和方法，比如需要一个是否处于被绑定在挡板上的属性和一个 Move（计算弹性球位置） 的方法。所以我们使用 GameObject 派生出来一个类： 12345678910111213class BallObject : public GameObject &#123;public: // 球的状态 GLfloat radius; GLboolean stuck; BallObject(); BallObject(glm::vec2 pos, GLfloat radius, glm::vec2 velocity, Texture2D sprite); glm::vec2 Move(GLfloat dt, GLuint windowWidth); void Reset(glm::vec2 position, glm::vec2 velocity);&#125;; &emsp;&emsp;实现代码看这里：BallObject.cpp &emsp;&emsp;在 Move 方法中，我们根据球的方向来进行位移，当它触碰到边界的时候触发反弹等等，我们仅处理在上，左和右边界的反弹，如果碰到下边则直接 “死亡 “ 。 1234567891011121314151617181920212223242526glm::vec2 BallObject::Move(const GLfloat dt, const GLuint windowWidth) &#123; // 如果没有被固定在挡板上 if (!this-&gt;stuck) &#123; // 移动球 this-&gt;position += this-&gt;velocity * dt; // 检查是否在窗口边界以外，如果是的话反转速度并恢复到正确的位置 if (this-&gt;position.x &lt;= 0.0f) &#123; this-&gt;velocity.x = -this-&gt;velocity.x; this-&gt;position.x = 0.0f; &#125; else if (this-&gt;position.x + this-&gt;size.x &gt;= windowWidth) &#123; this-&gt;velocity.x = -this-&gt;velocity.x; this-&gt;position.x = windowWidth - this-&gt;size.x; &#125; if (this-&gt;position.y &lt;= 0.0f) &#123; this-&gt;velocity.y = -this-&gt;velocity.y; this-&gt;position.y = 0.0f; &#125; &#125; return this-&gt;position;&#125; &emsp;&emsp;现在我们在 Game 类中添加一个 BallObject 对象： 1BallObject ball; &emsp;&emsp;在 Game::Init 中初始化变量： 1234// 加载弹性球 const auto ballRadius = 12.5f;const auto ballPos = paddlePos + glm::vec2(player.size.x / 2 - ballRadius, -player.size.y + ballRadius); //在挡板上面最中央ball = BallObject(ballPos, ballRadius, glm::vec2(100.0f, -100.0f), ResourceManager::GetTexture2D("face")); &emsp;&emsp;当游戏未开始的时候，我们的弹性球处于 stuck 状态（stuck 属性为 true），此时我们的弹性球被绑定在挡板上随着挡板移动。所以我们在弹性球 stuck 状态时移动挡板，弹性球也会跟随移动，需要修改 Game::ProcessInput 方法： 123456789101112131415161718192021222324252627282930313233/** * 处理输入 */void Game::ProcessInput(const GLuint dt) &#123; if (this-&gt;state == GAME_ACTIVE) &#123; const auto velocity = 10.0f * dt; // 移动挡板 if (this-&gt;keys[GLFW_KEY_A]) &#123; if (player.position.x &gt;= 0) &#123; player.position.x -= velocity; if (ball.stuck) &#123; ball.position.x -= velocity; &#125; &#125; &#125; if (this-&gt;keys[GLFW_KEY_D]) &#123; if (player.position.x &lt;= this-&gt;width - player.size.x) &#123; player.position.x += velocity; if (ball.stuck) &#123; ball.position.x += velocity; &#125; &#125; &#125; if (this-&gt;keys[GLFW_KEY_SPACE]) &#123; ball.stuck = !ball.stuck; &#125; &#125;&#125; &emsp;&emsp;可以看到，我们顺便设置了按空格键修改弹性球的固定属性（stuck）值。 &emsp;&emsp;在 Game::Update方法里，我们调用弹性球的 Move 方法： 12345678/** * 更新游戏状态 */ void Game::Update(const GLfloat dt) &#123; if (this-&gt;state == GAME_ACTIVE) &#123; ball.Move(dt, width); &#125;&#125; &emsp;&emsp;最后，在 Game::Render 里进行渲染： 12// 绘制球this-&gt;ball.Draw(*renderer); &emsp;&emsp;球体的 Update 我们实现了，现在还需要实现挡板的移动。这个比较简单，只需要我们在 Game::ProcessInput 方法里根据按键的不同修改挡板的坐标就可以了（代码上边已经有了）。请注意在这里我们调用了 Game 类的 keys 变量，这个变量是一个 bool 型的数组，里边的每一个元素代表着一个按键的值。每次按键就会更改按键的值，我们在需要判断按键的时候直接判断数组就可以了。 &emsp;&emsp;在渲染循环里更新 keys ： 123for (auto i = 0; i &lt; 1024; ++i) &#123; game.keys[i] = glfwGetKey(window, i);&#125; &emsp;&emsp;之后你应该会看到一个完整的场景： &emsp;&emsp;运行效果请看这里：https://youtu.be/5TTyPp8BIJs]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest-Repeating-Character-Replacement]]></title>
    <url>%2F2018%2F03%2F16%2FLongest-Repeating-Character-Replacement%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#424 Longest Repeating Character Replacement 题目描述&emsp;&emsp;Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations. Note:Both the string’s length and k will not exceed 104. Example 1: 12345678Input:s = &quot;ABAB&quot;, k = 2Output:4Explanation:Replace the two &apos;A&apos;s with two &apos;B&apos;s or vice versa. Example 2: 123456789Input:s = &quot;AABABBA&quot;, k = 1Output:4Explanation:Replace the one &apos;A&apos; in the middle with &apos;B&apos; and form &quot;AABBBBA&quot;.The substring &quot;BBBB&quot; has the longest repeating letters, which is 4. 解题思路&emsp;&emsp;本题可以采用滑动窗口法求最大值。我们维护这一个子串，并保存有当前子串的初始地址，Start 。 &emsp;&emsp;在遍历时，当遍历到一个新的字符，给当前字符的计数器+1，此时判断如果当前字符的个数满足大于当前子串长度减去 k 值（可替换的字符数量），则更新结果值。 解题代码【.CPP】12345678910111213141516class Solution &#123;public: int characterReplacement(string s, int k) &#123; vector&lt;int&gt; counts(26 , 0); int ret = 0, maxCount = 0, start = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; maxCount = max(maxCount , ++counts[s[i]-'A']); while(i-start-maxCount+1 &gt; k)&#123; --counts[s[start]-'A']; ++start; &#125; ret = max(ret , i-start+1); &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CXX-Const总结]]></title>
    <url>%2F2018%2F03%2F15%2FCXX-Const%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在 C/C++ 中，const 是一个比较常见的关键字，其用法也特别灵活，很容易就搞混。这几天在复习基础知识正巧看了这个，加上今天时间有点晚没事干刚好做个总结。 C/C++ const 作用 定义 const 常量，和宏常量的区别是 const 常量有类型检查（#define 定义的宏常量只做简单的替换） 修饰函数参数可以保护参数不被修改，一般用法是修改变量引用fun(const int&amp; i){...} 将一些必要的常量值（比如普通一年365天）定义为 const 常量可以减少代码中出现的 Magic number ，增强代码可读性而且修改较为方便。 const 定义的常量相比较宏定义而言更加节省空间，在程序运行的过程中只有一次拷贝（宏定义的调用多次即有多个）。 C/C++ const 用法 定义常量 &emsp;&emsp;const int i = 10 和 int const i = 10 两者作用相同，都是定义不可改变的常量值。 定义指针 修饰指针，指针不可变其指向的值可变 1int* const cpInt; 修饰值，指针可变而指向的值不可变 1const int* pcInt; 两者皆不可变 1const int* const cpcInt; 修饰函数 修饰函数参数 1234void f(const int i)&#123;...&#125; //修饰形参void f(const int&amp; i)&#123;...&#125; //修饰引用(引用对象不可进行更改)void f(const int* i)&#123;...&#125; //修饰指针(指针值不可更改)void f(int const* i)&#123;...&#125; //修饰指针(指针指向不可更改) 修饰函数返回值 123const int f()&#123;...&#125; //修饰方法返回值const int* f()&#123;...&#125; //相当于修饰变量 const int* fint* const f()&#123;...&#125; //同上 类内修饰 类常量 1234class A&#123; const int aId = 10; //不可更改 ...&#125; 常成员函数 123class A&#123; void f() const &#123;...&#125; //方法不可以改变类内成员信息也不可以调用非常函成员数&#125; 修饰类对象 / 对象引用 / 对象指针 &emsp;&emsp;除了和变量一样无法更改对象内值这种以外，也不允许调用任何非 const 方法。 const 与非 const 的转换&emsp;&emsp;C++ 提供了 const_cast&lt;Type&gt; 来对 const 进行转换。 123int i = 3;const int&amp; cref_i = i;const_case&lt;int&amp;&gt;(cref_i) = 4;]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】Breakout-5-环境物体]]></title>
    <url>%2F2018%2F03%2F15%2F%E3%80%90OpenGL%E3%80%91Breakout-5-%E7%8E%AF%E5%A2%83%E7%89%A9%E4%BD%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;到现在为止，我们的游戏窗口还只是一个黑乎乎的东西，最多加上一个渲染的精灵。我们需要的可不是这样，现在我们来绘制我们的游戏内容——游戏关卡（Game Level）。首先看看 Breakout 的游戏截图（来自维基百科 Break_out）： &emsp;&emsp;我们的游戏自然不会是这个画质（=。=），但是我们可以从这张图片中找到我们需要的东西。首先我们的游戏画面包含以下元素： 可 / 不可被破坏的方块 墙壁边界 一个可以活动的挡板 游戏角色 &emsp;&emsp;在游戏正式界面中，我们需要绘制游戏可能出现的场景，其中包括了游戏场景上半部分的可被破坏或者不可被破坏的砖块，一个可以碰撞弹动的游戏对象，一个在我们控制下移动的挡板（游戏对象碰撞到上，左，右边界和不可破坏砖块，挡板反弹，碰到下边界死亡，碰到可被破坏砖块，则砖块被破坏）。 &emsp;&emsp;游戏的砖块位置情况，我们用一个矩阵来表示，矩阵数字为0代表空，为1代表不可破坏砖块，为2代表可破坏砖块。例如： 1231 1 1 1 1 11 1 0 0 1 12 2 1 1 2 2 &emsp;&emsp;这些砖块将被平铺在游戏场景的上半部分，下半部分底部为一个挡板和我们的游戏对象。现在我们来绘制上半部分的场景。 &emsp;&emsp;关于砖块位置的信息我们将其放在文件里，不同的砖块信息我们将之认为不同的关卡（Game Level）。在此，我们创建一个被称为游戏对象的组件作为一个游戏内物体的基本表示。这样的游戏对象持有一些状态数据，如其位置、大小与速率。它还持有颜色、旋转、是否坚硬(不可被摧毁)、是否被摧毁的属性，除此之外，它还存储了一个Texture2D变量作为其精灵(Sprite)。 &emsp;&emsp;首先看看 GameObject 类： 1234567891011121314151617181920// Container object for holding all state relevant for a single// game object entity. Each object in the game likely needs the// minimal of state as described within GameObject.class GameObject&#123;public: // Object state glm::vec2 position, size, velocity; glm::vec3 color; GLfloat rotation; GLboolean isSolid; GLboolean destroyed; // Render state Texture2D sprite; // Constructor(s) GameObject(); GameObject(glm::vec2 pos, glm::vec2 size, Texture2D sprite, glm::vec3 color = glm::vec3(1.0f), glm::vec2 velocity = glm::vec2(0.0f, 0.0f)); // Draw sprite virtual void Draw(SpriteRenderer &amp;renderer);&#125;; &emsp;&emsp;我们在 GameObject 里定义了一系列的属性，并且有一个 Draw 的方法，这个 Draw 则是简单的判断对象是否存在而是否进行渲染。 GameObject 的实现代码可以看这里：GameObject.cpp。 &emsp;&emsp;除此之外，我们需要一个关卡类，用于关卡的操作（初始化，结束）： 1234567891011121314class GameLevel &#123;public: std::vector&lt;GameObject&gt; bricks; GameLevel(); // 从文件中加载关卡 void Load(const GLchar *file, GLuint levelWidth, GLuint levelHeight); // 渲染关卡 void Draw(SpriteRenderer &amp;renderer); // 检查一个关卡是否已完成 (所有非坚硬的瓷砖均被摧毁) GLboolean IsCompleted();private: // 由砖块数据初始化关卡 void Init(std::vector&lt;std::vector&lt;GLuint&gt;&gt; tileData, GLuint levelWidth, GLuint levelHeight);&#125;; &emsp;&emsp;GameLevel 类的实现看这里：GameLevel.cpp。 &emsp;&emsp;现在我们有了关卡类，可以正式的绘制关卡场景了。我们现在 Game 类里边加上一个存储关卡的数组以及一个游戏当前关卡的变量： 12std::vector&lt;GameLevel&gt; levels;GLuint level; &emsp;&emsp;在 Init 方法里，我们初始化这两个变量： 12345// 加载关卡GameLevel one;one.Load("resources/levels/one.lvl", this-&gt;width, this-&gt;height * 0.5);this-&gt;levels.push_back(one);this-&gt;level = 0; &emsp;&emsp;有了关卡信息后，我们使用 GameLevel 类的 Draw 进行绘制： 1234567891011121314// 加载关卡GameLevel one;one.Load("resources/levels/one.lvl", this-&gt;width, this-&gt;height * 0.5);GameLevel two; two.Load("levels/two.lvl", this-&gt;width, this-&gt;height * 0.5);GameLevel three; three.Load("levels/three.lvl", this-&gt;width, this-&gt;height * 0.5);GameLevel four; four.Load("levels/four.lvl", this-&gt;width, this-&gt;height * 0.5);this-&gt;levels.push_back(one);this-&gt;levels.push_back(two);this-&gt;levels.push_back(three);this-&gt;levels.push_back(four);this-&gt;level = 0; &emsp;&emsp;有了关卡信息后，我们使用 GameLevel 类的 Draw 进行绘制： 12345if (this-&gt;state == GAME_ACTIVE)&#123; // 绘制关卡 this-&gt;levels[this-&gt;level].Draw(*renderer);&#125; &emsp;&emsp;单一的颜色可能比较丑： &emsp;&emsp;我们为其加上背景和砖块纹理，首先在 Game::Init 方法里使用 ResourceManager 类读取纹理： 123ResourceManager::LoadTexture2D("resources/textures/background.jpg", GL_FALSE, "background");ResourceManager::LoadTexture2D("resources/textures/block.png", GL_FALSE, "block");ResourceManager::LoadTexture2D("resources/textures/block_solid.png", GL_FALSE, "block_solid"); &emsp;&emsp;在关卡初始化的时候为可破坏和不可破坏的纹理的加入不同的纹理： 123456789101112131415161718192021222324252627282930313233343536373839void GameLevel::Init(std::vector&lt;std::vector&lt;GLuint&gt;&gt; tileData, const GLuint levelWidth, const GLuint levelHeight) &#123; const auto height = tileData.size(); const auto width = tileData[0].size(); const auto unitWidth = levelWidth / static_cast&lt;GLfloat&gt;(width); const auto unitHeight = static_cast&lt;GLfloat&gt;(levelHeight) / height; for (GLuint y = 0; y &lt; height; ++y) &#123; for (GLuint x = 0; x &lt; width; ++x) &#123; const glm::vec2 pos(unitWidth * x, unitHeight * y); const glm::vec2 size(unitWidth, unitHeight); if (tileData[y][x] == 1) &#123; //GameObject obj(pos, size,null,glm::vec3(1.0f, 0.0f, 0.0f)); GameObject obj(pos, size, ResourceManager::GetTexture2D("block_solid"), glm::vec3(1.0f, 0.0f, 0.0f) ); obj.isSolid = GL_TRUE; this-&gt;bricks.push_back(obj); &#125; else if (tileData[y][x] &gt; 1) &#123; auto color = glm::vec3(0.5f); if (tileData[y][x] == 2) color = glm::vec3(0.3f, 0.2f, 0.0f); else if (tileData[y][x] == 3) color = glm::vec3(0.1f, 0.3f, 0.1f); else if (tileData[y][x] == 4) color = glm::vec3(0.4f, 0.6f, 0.1f); else if (tileData[y][x] == 5) color = glm::vec3(0.3f, 0.1f, 0.9f); //this-&gt;bricks.emplace_back(pos, size, null , color); this-&gt;bricks.emplace_back(pos, size, ResourceManager::GetTexture2D("block"), color); &#125; &#125; &#125;&#125; &emsp;&emsp;（注意注释部分，我们用实际加载的纹理代替了一个空的纹理对象）。最后我们在绘制关卡前先绘制背景纹理： 12345678910void Game::Render() &#123; if (this-&gt;state == GAME_ACTIVE) &#123; // 绘制背景 auto backgroundTexture = ResourceManager::GetTexture2D("background"); renderer-&gt;DrawSprite(backgroundTexture, glm::vec2(0, 0), glm::vec2(this-&gt;width, this-&gt;height), 0.0f , glm::vec3(0.1f , 0.1f , 0.1f)); // 绘制关卡 this-&gt;levels[this-&gt;level].Draw(*renderer); &#125;&#125; &emsp;&emsp;最终效果如下： &emsp;&emsp;貌似不错了，现在我们来绘制挡板，首先在 Game 类中添加 paddle 变量（同样也是 GameObject 对象）： 1GameObject player; &emsp;&emsp;在 Game::Init 方法里，我们读取纹理并且初始化这个对象： 1234ResourceManager::LoadTexture2D("resources/textures/paddle.png", GL_TRUE, "paddle");const auto paddleSize = glm::vec2(200.0f, 40.0f);const auto paddlePos = glm::vec2(static_cast&lt;GLfloat&gt;(width) / 2 - paddleSize.x / 2 , height - paddleSize.y / 2); //在底部player = GameObject(paddlePos , paddleSize , ResourceManager::GetTexture2D("paddle") , glm::vec3(0.3f) , glm::vec2(500.0f)); &emsp;&emsp;最后，在 Game::Render 方法里绘制： 12// 绘制挡板this-&gt;player.Draw(*renderer); &emsp;&emsp;效果如下：]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Combination-Sum-IV]]></title>
    <url>%2F2018%2F03%2F15%2FCombination-Sum-IV%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#377 Combination Sum IV 题目描述&emsp;&emsp;Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: 123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Follow up:&emsp;&emsp;What if negative numbers are allowed in the given array?&emsp;&emsp;How does it change the problem?&emsp;&emsp;What limitation we need to add to the question to allow negative numbers? 解题思路&emsp;&emsp;看到题后下意识的用了递归，然后就超时了。。。。 &emsp;&emsp;这道题的解法应该是 DP ，递归公式则为 &emsp;&emsp;dp[i] = {sum(dp[i-x1] , dp[i-x2] , dp[i-x3] ……) | x in nums &amp;&amp; nums[x] &lt; i} 解题代码【.CPP】1234567891011121314class Solution &#123;public: int combinationSum4(vector&lt;int&gt; &amp;nums, int target) &#123; vector&lt;int&gt; dp(target+1,0); dp[0] = 1; for (int i = 1; i &lt;= target; ++i) &#123; for (int j = 0; j &lt; nums.size(); ++j) &#123; if (i &gt;= nums[j]) dp[i] += dp[i - nums[j]]; &#125; &#125; return dp[target]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DirectX】1-A-Empty-Window]]></title>
    <url>%2F2018%2F03%2F14%2F%E3%80%90DirectX%E3%80%911-A-Empty-Window%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;哈哈哈哈哈哈是不是超熟悉的。继 OpenGL 基础学完后，在继续钻研 OpenGL 比较深入的内容的同时，也顺便学学 DirectX 吧，毕竟在游戏界，DirectX 还是主流。在很久之前，写者也是接触了一些 Windows 编程的，当然仅仅只是一点。也就写出来了几个窗口，还是跟着教程的。现在在学习了 OpenGL 之后，那些东西也有了一些理解，是时候继续学习了。 &emsp;&emsp;在学习 DirectX 之前要先介绍下 Windows 的窗口编程，以及 Windows 的消息机制。 Windows 窗口 &emsp;&emsp;由图可见，Windows （WS_EX_TOPMOST | WS_OVERLAPPEDWINDOW）窗口共分为标题栏，可调按钮（最大化，最小化和关闭），客户区几个区域。&emsp;我们的渲染一般都是在客户区里边，当然 Windows 也会给我们提供修改其他部位的 API。在 Windows 编程中，我们使用 HWND（句柄） 来标记窗口。 Windows 消息机制&emsp;&emsp;Windows 使用消息队列来进行维护窗口消息，比如我们鼠标光标在窗口里按动了左键。此时操作系统会感知到这个事件，并且将一个左键消息发送到窗口的消息队列中，而我们的程序从消息队列中取出来消息并进行相应的处理。这个处理则是操作系统调用程序中处理消息的函数 WndProc 。 &emsp;&emsp;消息队列，则是 Windows 在程序启动的时候创建的一个消息容器，这个容器用来存放所有的该程序窗口的消息。在我们触发了事件之后，操作系统将消息放入消息队列，而我们的程序会不断的从消息队列中读取消息并且处理他，这就是 Windows 窗口的消息机制。 创建一个 Windows 窗口 Windows 程序入口&emsp;&emsp;我们在学习 C/C++ 的时候已经写过不少的程序了，他们在 Windows 中都输入控制台应用，甚至在我们的 OpenGL 学习中，使用 Windows 开发的时候，也都是 Win32 控制台应用。在 Win32 控制台应用里，我们的程序入口时 main 方法： 123int main(int argc , char** argv)&#123; ...&#125; &emsp;&emsp;而在 Windows 程序中，我们则是使用了 WinMain 的入口方法： 1234567int WINAPI WinMain( HINSTANCE hInstance, //当前运行的实例的句柄 HINSTANCE hPreInstince, //上一个运行的实例的句柄 LPSTR lpCmdLine, //程序运行的命令行参数 int nCmdShow)&#123; //程序窗口的显示方式（不显示=0，正常显示=1，最小化=2，最大化=3） ...&#125; &emsp;&emsp;注释上我们说明了各个参数的意义，有些参数我们在之后的代码中要用到。 设计 Windows 类&emsp;&emsp;在 OpenGL 中，我们在创建窗口之前要进行 glfw 的配置，glew 的配置等，而在 Windows 程序窗口中，Windows 系统提供给了我们一个 Window 类：WNDCLASS，我们可以通过填充这个类的属性来配置我们的窗口类。 &emsp;&emsp;窗口类的定义如下： 123456789101112typedef struct tagWNDCLASS &#123; UINT style; //窗口显示样式，枚举值 WNDPROC lpfnWndProc; //消息处理回调函数 int cbClsExtra; //为窗口类额外分配的字节数 int cbWndExtra; //为窗口实例额外分配的字节数 HINSTANCE hInstance; //窗口过程的实例句柄 HICON hIcon; //窗口图标 HCURSOR hCursor; //窗口光标 HBRUSH hbrBackground; //窗口背景画刷 LPCTSTR lpszMenuName; //窗口菜单 LPCTSTR lpszClassName; //窗口类的名字（！和CreateWindow里的参数必须一样！）&#125; WNDCLASS, *PWNDCLASS; &emsp;&emsp;style 参数的具体枚举值我们可以看 MSDN 文档（在学习 Windows 开发的时候，MSDN 是我们永远的老师）：Window Class Styles &emsp;&emsp;我们创建 WNDCLASS 的实例，并为他赋值，即设计好了我们的窗口类。如下： 1234567891011WNDCLASS winClass;winClass.style = CS_VREDRAW | CS_HREDRAW;winClass.hInstance = hInstance;winClass.cbClsExtra = 0;winClass.cbWndExtra = 0;winClass.hCursor = LoadCursor(nullptr, IDC_ARROW);winClass.hIcon = LoadIcon(nullptr, IDC_ICON);winClass.hbrBackground = static_cast&lt;HBRUSH&gt;(GetStockObject(DKGRAY_BRUSH));winClass.lpfnWndProc = static_cast&lt;WNDPROC&gt;(WndProc);winClass.lpszClassName = "windowClass";winClass.lpszMenuName = nullptr; 注册窗口类&emsp;&emsp;在设计好窗口类之后，我们需要向 Windows 注册这个类（请注意我们只是用给定的类模板设计了我们的窗口类，在程序中我们的 windowClass 只是一个 WNDCLASS 的实例对象而已，我们需要注册他成为一个类而让我们可以使用它来创建窗口）。 &emsp;&emsp;我们使用 RegisterClass 方法来注册我们的窗口类，传入 WNDCLASS 的实例对象，他将为我们创建名为winClass.lpszClassName 的窗口类。 1234if (!RegisterClass(&amp;winClass)) &#123; MessageBox(nullptr,"ERROR::WINDOWS_CLASS::REGISTER_ERROR", "REGISTER REEOR" , 0); return 0;&#125; 创建窗口&emsp;&emsp;注册完了窗口类之后，我们便可以使用它来创建窗口，使用 CreateWindow 方法： 12345678910111213HWND WINAPI CreateWindow( _In_opt_ LPCTSTR lpClassName, //窗口类名称 _In_opt_ LPCTSTR lpWindowName, //窗口名称 _In_ DWORD dwStyle, //窗口样式，枚举值 _In_ int x, //窗口左上角坐标 _In_ int y, //窗口左上角坐标 _In_ int nWidth, //窗口宽度 _In_ int nHeight, //窗口高度 _In_opt_ HWND hWndParent, //父窗口（创建子窗口时有用） _In_opt_ HMENU hMenu, //窗口菜单 _In_opt_ HINSTANCE hInstance, //实例句柄 _In_opt_ LPVOID lpParam //附加参数); &emsp;&emsp;各个参数的用途可以看注释，关于窗口样式的详细信息看 MSDN 文档：Window Styles，当窗口创建成功时会返回他的窗口句柄 hWnd。 &emsp;&emsp;现在我们使用它来创建一个窗口： 12345678910111213141516const auto windowHandle = CreateWindow( "windowClass", "Empty Window", WS_EX_TOPMOST | WS_OVERLAPPEDWINDOW, 0, 0, 1920, 1080, nullptr, nullptr, hInstance, nullptr);if (!windowHandle) &#123; MessageBox(nullptr,"ERROR::WINDOWS_CREATE::CREATE_ERROR", "CREATE REEOR" , 0); return 0;&#125; 窗口更新&emsp;&emsp;创建好窗口后，我们可以使用 ShowWindow 来显示窗口，而在窗口更新之后，则可以使用 UpdateWindow 来更新窗口显示，在调用 ShowWindow 之后也需要调用 UpdateWindow 。 12ShowWindow(windowHandle, SW_SHOWNORMAL);UpdateWindow(windowHandle); &emsp;&emsp;ShowWindow 有两个参数，窗口句柄和窗口的显示方式，这也是一个枚举值，具体值属性我们可以看这里：Show Controls 消息处理&emsp;&emsp;文章前边介绍了 Windows 的消息处理方式，而现在需要写一个消息循环来不断的从消息队列读取消息并且处理消息，这里我们需要介绍 Windows 封装好的消息结构体和消息处理函数。 123456789101112131415161718//消息结构体typedef struct tagMSG &#123; HWND hwnd; //窗口句柄 UINT message; //消息标识 WPARAM wParam; //消息附加信息 LPARAM lParam; //消息附加信息 DWORD time; //消息到达消息队列的时间 POINT pt; //鼠标当前位置&#125; MSG; //从消息队列中得到消息 成功返回非零BOOL WINAPI PeekMessage( _Out_ LPMSG lpMsg, //msg指针 _In_opt_ HWND hWnd, //窗口句柄 _In_ UINT wMsgFilterMin, //指定被检查的消息范围第一个消息，通常为0 _In_ UINT wMsgFilterMax, //指定被检查的消息范围最后一个消息，通常为0 _In_ UINT wRemoveMsg //是否将消息从消息队列中删除（PM_NOREMOVE 保留，PM_REMOVE 删除）); &emsp;&emsp;我们通过使用 PeekMessage（还有个 GetMessage也可以得到消息，但是不会 Remove） 来接收消息，然后使用 TranslateMessage 转化消息（将其转换为字符消息），最后通过 DispatchMessage 来将消息传递给窗口处理函数。 123456789MSG uMsg;ZeroMemory(&amp;uMsg, sizeof(MSG));uMsg.message = WM_ACTIVATE;while (uMsg.message != WM_QUIT) &#123; if (PeekMessage(&amp;uMsg, nullptr, 0, 0, PM_REMOVE)) &#123; //使用 PeekMessage TranslateMessage(&amp;uMsg); //使用 TranslateMessage DispatchMessage(&amp;uMsg); //使用 DispatchMessage &#125;&#125; &emsp;&emsp;这两个方法都比较简单，传入消息结构体就可以了。之后，我们在窗口内部产生的消息将会被翻译成字符消息后送往 WindowProc（窗口处理消息），这是一个回调（CALLBACK）函数。 12345678LRESULT CALLBACK WndProc( const HWND hwnd, //窗口句柄 const UINT uMsg, //消息结构体 const WPARAM wParam, //消息附加参数 LPARAM lParam) //消息附加参数&#123; ...&#125; &emsp;&emsp;这个窗口过程函数是一个 CALLBACK 函数，我们在设置窗口类的时候就将他绑定到了窗口类的过程函数上winClass.lpfnWndProc = static_cast&lt;WNDPROC&gt;(WndProc);，他会在收到消息后自动被调用。我们可以在他内部根据消息的不同来做不一样的处理。 &emsp;&emsp;Windows 将各种消息封装为常量，所以我们可以直接根据消息的值来判断： 123456789LRESULT CALLBACK WndProc(const HWND hwnd, const UINT uMsg, const WPARAM wParam, LPARAM lParam) &#123; switch (uMsg) &#123; case WM_LBUTTONDOWN: MessageBox(nullptr, "鼠标按下", "消息详情", 0); break; default: break; &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam);&#125; &emsp;&emsp;Windows 窗口的消息常量便是以 WM_ 开头的常量值。 &emsp;&emsp;我们使用了 switch ，当 uMsg 为 WM_LBUTTONDOWN （鼠标左键按下）时弹出一个提示框，来看看效果吧： &emsp;&emsp;成功！ &emsp;&emsp;完整的窗口代码在 Github ，点这里前往：A Win32 Window]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>DirectX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】Breakout-4-精灵]]></title>
    <url>%2F2018%2F03%2F14%2F%E3%80%90OpenGL%E3%80%91Breakout-4-%E7%B2%BE%E7%81%B5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;到现在为止，我们基本实现了我们的游戏框架代码，而现在就是正式开始渲染游戏和检验前边成果的时候了。这篇文章我们主要介绍精灵（Sprite），以及创建一个精灵类以实现精灵的渲染。 &emsp;&emsp;精灵（Sprite） 是计算机图形学中的一个概念（不是精灵族的精灵），他的定义是包含于场景中的一个二维贴图或者图像，也就是说一个二维的贴图，我们今天想要做的就是将他渲染出来。为此我们创建一个 SpriteRender 类： 123456789101112131415class SpriteRenderer&#123; public: explicit SpriteRenderer(Shader &amp;&amp;shader); ~SpriteRenderer(); void DrawSprite(Texture2D &amp;texture, glm::vec2 position, glm::vec2 size = glm::vec2(10, 10), GLfloat rotate = 0.0f, glm::vec3 color = glm::vec3(1.0f)); private: Shader shader_; GLuint quadVao_; void InitRenderData();&#125;; &emsp;&emsp;在这个类中我们有除了构造和析构外只有一个公开方法，就是 DrawSprite ，我们可以使用它来进行绘制。他的实现的源代码在这里：SpriteRender.cpp。代码也比较简单，首先在构造方法里，我们接受了一个 Shader 对象作为参数，并赋值给 shader_ 成员，同时调用 InitRenderData() 方法。 1234SpriteRenderer::SpriteRenderer(Shader &amp;&amp;shader) : quadVao_(0) &#123; this-&gt;shader_ = shader; this-&gt;InitRenderData(); &#125; &emsp;&emsp;在 InitRenderData 方法里，我们创建顶点数组，并绑定 VBO ，VAO 等，这些操作我们在之前的代码中都写过很多，也就是换了个地方而已。 12345678910111213141516171819202122GLuint vbo;GLfloat vertices[] = &#123; 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f&#125;;glGenVertexArrays(1, &amp;this-&gt;quadVao_);glGenBuffers(1, &amp;vbo);glBindBuffer(GL_ARRAY_BUFFER, vbo);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBindVertexArray(this-&gt;quadVao_);glEnableVertexAttribArray(0);glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), static_cast&lt;GLvoid*&gt;(0));glBindBuffer(GL_ARRAY_BUFFER, 0);glBindVertexArray(0); &emsp;&emsp;请注意我们 vertices 数组以四个数值为一组，前两个是顶点坐标（我们是二维的游戏，所以没有 z 轴，在顶点着色器里默认赋值为 0.0f），后两个是纹理坐标。 &emsp;&emsp;DrawSprite 方法则是封装了给着色器传值和 Draw 等函数调用，这里不再介绍。下来主要看我们的着色器操作，我们的小游戏是二维平面游戏，所以不需要 z 轴。同时也需要将观察空间坐标转换为二维投影坐标。 &emsp;&emsp;从这个坐标系统教程中，我们明白了投影矩阵的作用是把观察空间坐标转化为标准化设备坐标。通过生成合适的投影矩阵，我们就可以在不同的坐标系下计算，这可能比把所有的坐标都指定为标准化设备坐标（再计算）要更容易处理。 &emsp;&emsp;我们不需要对坐标系应用透视，因为这个游戏完全是2D的，所以一个正射投影矩阵(Orthographic Projection Matrix)就可以了。由于正射投影矩阵几乎直接变换所有的坐标至裁剪空间，我们可以定义如下的投影矩阵指定世界坐标为屏幕坐标：glm::mat4 projection = glm::ortho(0.0f, 800.0f, 600.0f, 0.0f, -1.0f, 1.0f); 。 &emsp;&emsp;前面的四个参数依次指定了投影平截头体的左、右、下、上边界。这个投影矩阵把所有在0到800之间的x坐标变换到-1到1之间，并把所有在0到600之间的y坐标变换到-1到1之间。这里我们指定了平截头体顶部的y坐标值为0，底部的y坐标值为600。所以，这个场景的左上角坐标为(0,0)，右下角坐标为(800,600)，就像屏幕坐标那样。观察空间坐标直接对应最终像素的坐标。 &emsp;&emsp;这样我们就可以指定所有的顶点坐标为屏幕上的像素坐标了，这对2D游戏来说相当直观。 &emsp;&emsp;在顶点着色器中，我们将传入顶点着色器的数组分为两部分，前两个为 x , y 坐标，后两个为纹理坐标，传值给片段着色器。 12345678910111213#version 420 corelayout (location = 0) in vec4 aPos;out vec2 TexCoords;uniform mat4 model;uniform mat4 projection;void main()&#123; TexCoords = aPos.zw; gl_Position = projection * model * vec4(aPos.xy, 0.0f, 1.0f);&#125; &emsp;&emsp;片段着色器： 123456789101112#version 420 corein vec2 TexCoords;out vec4 color;uniform sampler2D image;uniform vec3 spriteColor;void main()&#123; color = vec4(spriteColor, 1.0f) + texture(image, TexCoords);&#125; &emsp;&emsp;我们通过传入的纹理和颜色向量来控制纹理颜色。 &emsp;&emsp;精灵类算是完成了，我们将在 Game 类的方法里去加载并且渲染他： &emsp;&emsp;在 Game::Init 里加载： 1234567891011// 加载着色器ResourceManager::LoadShader("resources/shaders/sprite.vertexShader", "resources/shaders/sprite.fragmentShader", nullptr, "sprite");// 配置着色器const auto projection = glm::ortho(0.0f, static_cast&lt;GLfloat&gt;(this-&gt;width), static_cast&lt;GLfloat&gt;(this-&gt;height), 0.0f, -1.0f, 1.0f);ResourceManager::GetShader("sprite").Use().SetInteger("image", 0);ResourceManager::GetShader("sprite").SetMatrix4("projection", projection);// 设置专用于渲染的控制renderer = new SpriteRenderer(ResourceManager::GetShader("sprite"));// 加载纹理ResourceManager::LoadTexture2D("resources/textures/awesomeface.png", GL_TRUE, "face"); &emsp;&emsp;在 Game::Render 里调用渲染： 123auto spriteTexture = ResourceManager::GetTexture2D("face");renderer-&gt;DrawSprite(spriteTexture, glm::vec2(100.0f, 100.0f), glm::vec2(200, 300), 45.0f, glm::vec3(0.1f, 0.2f, 0.1f)); &emsp;&emsp;现在我们看看效果吧：]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Time-to-Buy-and-Sell-Stock]]></title>
    <url>%2F2018%2F03%2F14%2FTime-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#121 Best Time to Buy and Sell Stock 题目描述&emsp;&emsp;Say you have an array for which the ith element is the price of a given stock on day i. &emsp;&emsp;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: 1234Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: 1234Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 解题思路&emsp;&emsp;我们定义两个索引 minIdx 与 maxIdx ，遍历给定数组，当值小于 minIdx 所对应的值时更新 minIdx 与 maxIdx （更新 maxIdx 以保证 max 值总是在 min 之后），当当前值大于 maxIdx 对应值的时候，更新 maxIdx 与 result。 解题代码【.CPP】1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int minIdx = 0 , maxIdx = 0; for (int i = 1; i &lt; prices.size(); ++i) &#123; if(prices[i] &lt;= prices[minIdx]) &#123; minIdx = i; maxIdx = i; &#125; else if(prices[i] &gt;= prices[maxIdx])&#123; maxIdx = i; res = max(res , prices[maxIdx] - prices[minIdx]); &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】24-抗锯齿]]></title>
    <url>%2F2018%2F03%2F13%2F%E3%80%90OpenGL%E3%80%9124-%E6%8A%97%E9%94%AF%E9%BD%BF%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】抗锯齿 【英文版】Anti Aliasing 学习记录&emsp;&emsp;在讨论抗锯齿之前，我们需要知道什么是锯齿。我们的屏幕显示效果其实是由一个个像素点显示而成的，就是相当于一个个小方格堆砌而成，而当我们在屏幕上显示一条线的时候，他可能是比较平滑的，因为可以沿着小方格的边缘着色，但是若是斜线呢。 &emsp;&emsp;试想，在几何中，用边长为1的单位正方形去构造一条与平面呈 45 ° 的斜线，我们最终堆砌而成的是很明显的锯齿状，见下图： &emsp;&emsp;可以看到，在与正方形边缘平行的那一条线是比较平滑的，而其他两条就成了那种台阶状，我们又称之为锯齿。而在计算机图形中，所有的图形也是由一个个小方格组成，方格的大小和屏幕分辨率有关，当屏幕分辨率较低的时候，我们可以看到画面上几乎都是一个个的小方格。所以提高分辨率是解决锯齿的最好的办法。 &emsp;&emsp;不过，提高分辨率是硬件的技术，在超高分辨率的屏幕尚未发明出来时，我们也有各种技术来对图像边缘进行处理，以提高画面感。这篇文章就是用来介绍这几门技术。 多重采样技术（MSAA）&emsp;&emsp;多重采样技术，即在每一个像素点里放置多个采样点，根据最后图像边缘覆盖的采样点多少来觉得色度的深浅。默认一般是一个的，首先我们看看一个的情况： &emsp;&emsp;这种情况下，当我们的边缘覆盖到采样点的时候，整个像素都会被绘制成片段的颜色，当没有覆盖的时候即不进行染色。这样下来就会出现边缘的锯齿，如最上边的图那样。而多重采样技术，则是在一个像素点内有多个采样点，覆盖每个采样点则增加点颜色深度，当一个像素内所有的采样点都覆盖时则为片段颜色。例如我们使用四个采样点，某一个像素区域内片段覆盖了三个采样点，则这个像素的颜色是 fragColor * 0.75 。 &emsp;&emsp;其实这种技术我们一直在用，还记得我们 OpenGL 代码中的 glfwWindowHint(GLFW_SAMPLES, 4); 。这即是开启了赋值了每个像素点内的采样点数量，我们将其设置为 4 。同时在设置采样点数量的时候，我们还需要使用 glEnable(GL_MULTISAMPLE); 来开启（默认开启）多重采样的功能。这样下来 OpenGL 将会按照四个采样点来计算，而不用我们自己去抗锯齿。 &emsp;&emsp;我们将之前的 A Colored Cube 代码拿出来，将其颜色染为纯色，然后注释掉设置采样点的代码，来看看效果： &emsp;&emsp;能够看到边缘不是很平滑，但是也没有看到具体的锯齿，接下来我们将图片放大： &emsp;&emsp;是不是很明显的看到了。这就是锯齿。现在，我们设置采样点为8，再看看效果： 12glfwWindowHint(GLFW_SAMPLES, 8);glEnable(GL_MULTISAMPLE); &emsp;&emsp;这样处理之后，我们在稍微近的地方看下来显示效果会好很多。当然提高了显示效果，那么资源也是耗费更多，我们在每一个像素点上做8个采样点，最终的耗费便是以前的8倍。所以除了一些对画面要求比较苛刻的程序，一般情况下不会设置这么多的。 题外话&emsp;&emsp;事实上，OpenGL 的基础学习到这里也就差不多结束了，Learn OpenGL 剩下的教程都是高级光照和一些其他的东西。我也不会去保持一天一更这种速度去写这些内容的博客，这一系列文章算上这个总共二十四篇，就算是结束了。后边的内容，可能更多是总结性的内容了。目前虽然已经看完了 OpenGL 教程中的内容，但是却没有真正写过太多的代码，以后会零零散散更新一些知识的细节。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest-Palindromic-Subsequence]]></title>
    <url>%2F2018%2F03%2F13%2FLongest-Palindromic-Subsequence%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#516 Longest Palindromic Subsequence 题目描述&emsp;&emsp;Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. Example 1:Input: 1&quot;bbbab&quot; Output: 14 One possible longest palindromic subsequence is “bbbb”. Example 2:Input: 1&quot;cbbd&quot; Output: 12 One possible longest palindromic subsequence is “bb”. 解题思路&emsp;&emsp;最长回文子序列，和最长回文字符串不同的地方在于这个不要求连续，做法和最长回文字符串也不差多少。我们使用 DP ，递推公式如下： s[i] == s[j] : dp[i][j] = dp[i+1][j-1] + 2 s[i] != s[j] : dp[i][j] = max(dp[i+1][j] , dp[i][j-1]) 解题代码【.CPP】1234567891011121314class Solution &#123;public: int longestPalindromeSubseq(string s) &#123; vector&lt;vector&lt;int&gt;&gt; dp(s.size() , vector&lt;int&gt;(s.size() , 0)); for(int i = s.size() - 1 ; i &gt;= 0 ; --i)&#123; dp[i][i] = 1; for (int j = i+1; j &lt; s.size(); ++j) &#123; if (s[i] == s[j]) dp[i][j] = dp[i+1][j-1] + 2; else dp[i][j] = max(dp[i+1][j] , dp[i][j-1]); &#125; &#125; return dp[0][s.size()-1]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】23-实例化]]></title>
    <url>%2F2018%2F03%2F13%2F%E3%80%90OpenGL%E3%80%9123-%E5%AE%9E%E4%BE%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】实例化 【英文版】Instancing 学习记录&emsp;&emsp;在这篇文章中，我们来介绍一个用于绘制大量模型物体的技术：实例化（Instancing） &emsp;&emsp;是否还记得我们在 高级 GLSL 这一篇文章中，我们绘制的四个正方体模型： 1234567891011121314151617181920212223242526272829303132//绘制第一个模型someShader1.use();someShader1.setMat4("projection", projection);someShader1.setMat4("view", camera.GetViewMatrix());someShader1.setMat4("model", model1);glBindVertexArray(vertexArrayObject);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);//绘制第二个模型someShader2.use();someShader2.setMat4("projection", projection);someShader2.setMat4("view", camera.GetViewMatrix());someShader2.setMat4("model", model2);glBindVertexArray(vertexArrayObject);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);//绘制第三个模型someShader3.use();someShader3.setMat4("projection", projection);someShader3.setMat4("view", camera.GetViewMatrix());someShader3.setMat4("model", model3);glBindVertexArray(vertexArrayObject);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);//绘制第四个模型someShader4.use();someShader4.setMat4("projection", projection);someShader4.setMat4("view", camera.GetViewMatrix());someShader4.setMat4("model", model4);glBindVertexArray(vertexArrayObject);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0); &emsp;&emsp;刚开始我们需要一个一个的传入 MVP ，然后一个一个的绘制，代码冗余不说效率也不高。之后我们使用 UBO （Uniform Buffer Object）优化了代码： 12345678910111213141516171819glBindVertexArray(vertexArrayObject);glslShader1.use();glslShader1.setMat4("model", model1);glDrawArrays(GL_TRIANGLES, 0, 36);glslShader2.use();glslShader2.setMat4("model", model2);glDrawArrays(GL_TRIANGLES, 0, 36);glslShader3.use();glslShader3.setMat4("model", model3);glDrawArrays(GL_TRIANGLES, 0, 36);glslShader4.use();glslShader4.setMat4("model", model4);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0); &emsp;&emsp;代码变成了这样，但我们仍然是调用多个绘制函数，如果我们的 Shader 再一样的话，那么应该是这样： 1234567891011121314151617glBindVertexArray(vertexArrayObject);glslShader.use();glslShader.setMat4("model", model1);glDrawArrays(GL_TRIANGLES, 0, 36);glslShader.setMat4("model", model2);glDrawArrays(GL_TRIANGLES, 0, 36);glslShader.setMat4("model", model3);glDrawArrays(GL_TRIANGLES, 0, 36);glslShader.setMat4("model", model4);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0); &emsp;&emsp;亦或者使用 for 循环： 1234567glBindVertexArray(vertexArrayObject);glslShader.use();for (const auto&amp; model : models) &#123; glslShader.setMat4("model", model); glDrawArrays(GL_TRIANGLES, 0, 36);&#125;glBindVertexArray(0); &emsp;&emsp;这样再多的模型我们也只需要在 models 容器里添加 model 就可以了，代码的冗余似乎解决了，但是效率并没有提高。与绘制顶点本身相比，使用 glDrawArrays 或 glDrawElements 函数告诉 GPU 去绘制顶点数据会消耗更多的性能，因为 OpenGL 在绘制顶点数据之前需要做很多准备工作（比如告诉 GPU 该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的 CPU 到 GPU 总线(CPU to GPU Bus)上进行的）。所以，即便渲染顶点非常快，命令 GPU 去渲染却未必。 &emsp;&emsp;如果我们能够将数据一次性发送给 GPU ，然后使用一个绘制函数让 OpenGL 利用这些数据绘制多个物体，就会更方便了。这就是实例化（Instancing）。通过实例化技术，我们可以快速的绘制出大量的同类模型。 &emsp;&emsp;用了这么大的篇幅去介绍为什么使用实例化技术，那么这个究竟如何使用呢？ &emsp;&emsp;在渲染多个相同的物体时，我们需要提供他的位置（否则在一个位置渲染再多的相同物体都是没有意义的），首先我们在顶点着色器里定义位置数组。 1uniform vec3 positions[40]; &emsp;&emsp;我们定义了一个大小为 40 的位置索引，这时候我们需要用提供的当前渲染的物体的索引来选择相应的位置，索性 GLSL 给我们定义了这么一个内建变量：gl_InstanceID 。 Namegl_InstanceID — contains the index of the current primitive in an instanced draw command Description​ gl_InstanceID is a vertex language input variable that holds the integer index of the current primitive in an instanced draw command such as glDrawArraysInstanced. If the current primitive does not originate from an instanced draw command, the value of gl_InstanceID is zero. &emsp;&emsp;gl_InstanceID 给了我们当前所渲染的物体的 ID，从 0 开始，跟随我们渲染的物体数而自增。所以在顶点着色器代码中，使用 gl_InstanceID 索引位置数组，并加到 gl_Position 上。 1gl_Position = projection * view * model * vec4(aPos + positions[gl_InstanceID] , 1.0f); &emsp;&emsp;此时我们的顶点着色器应该是这个样子： 123456789101112131415#version 420 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform vec3 positions[40];layout (std140) uniform VP&#123; mat4 projection; mat4 view;&#125;;void main()&#123; gl_Position = projection * view * model * vec4(aPos + positions[gl_InstanceID] , 1.0f); gl_PointSize = abs(aPos.z) * 20;&#125;; &emsp;&emsp;着色器的代码完了，现在我们需要在 OpenGL 代码中为着色器的 positions[] 变量赋值，首先我们创建一个 positions 数组： 12345678std::vector&lt;glm::vec3&gt; positions(0);for (float i = 1; i &lt; 10.0; i++) &#123; positions.push_back(glm::vec3(3.0f, 3.0f, 0.0f) * i); positions.push_back(glm::vec3(-3.0f, -3.0f, 0.0f) * i); positions.push_back(glm::vec3(3.0f, -3.0f, 0.0f) * i); positions.push_back(glm::vec3(-3.0f, 3.0f, 0.0f) * i);&#125; &emsp;&emsp;之后，我们在调用 shader.use() 之后，我们为着色器变量写值： 12345glslShader.use();for (auto i = 0; i &lt; positions.size(); ++i) &#123; glslShader.setVec3("positions[" + std::to_string(i) + "]", positions[i]);&#125;glslShader.setMat4("model", model); &emsp;&emsp;最后，我们调用实例化 Draw 方法：glDrawArraysInstanced(GL_TRIANGLES, 0, 36, 40); ，请注意我们最后一个参数是要渲染的物体数量。效果如下： &emsp;&emsp;如果你没有成功，请看这里：源代码]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】Breakout-3-实现我们的基础类]]></title>
    <url>%2F2018%2F03%2F13%2F%E3%80%90OpenGL%E3%80%91Breakout-3-%E5%AE%9E%E7%8E%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇文章中，我们为游戏搭建了基本框架，创建了几个必要类，但是也仅仅是创建了他们而没有实现。现在我们将开始为他们编码，实现其内容。这将是出现大量代码的一篇文章。 &emsp;&emsp;首先是 Shader 类，我们之前的代码中也用到了 Shader 类，但是那个类封装的较为粗糙。甚至于将文件读取也封装到了里边，而现在我们对其稍微更改： 1234567891011121314151617181920212223class Shader&#123;public: // State GLuint id; // Constructor Shader(); // Sets the current shader as active Shader &amp;Use(); // Compiles the shader from given source code void Compile(const GLchar *vertexSource, const GLchar *fragmentSource, const GLchar *geometrySource = nullptr); // Note: geometry source code is optional // Utility functions void SetFloat(const GLchar *name, GLfloat value, GLboolean useShader = false); void SetInteger(const GLchar *name, GLint value, GLboolean useShader = false); void SetVector2F(const GLchar *name, GLfloat x, GLfloat y, GLboolean useShader = false); void SetVector2F(const GLchar *name, const glm::vec2 &amp;value, GLboolean useShader = false); void SetVector3F(const GLchar *name, GLfloat x, GLfloat y, GLfloat z, GLboolean useShader = false); void SetVector3F(const GLchar *name, const glm::vec3 &amp;value, GLboolean useShader = false); void SetVector4F(const GLchar *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w, GLboolean useShader = false); void SetVector4F(const GLchar *name, const glm::vec4 &amp;value, GLboolean useShader = false); void SetMatrix4(const GLchar *name, const glm::mat4 &amp;matrix, GLboolean useShader = false);&#125;; &emsp;&emsp;我们为其封装了 id 属性，Compiler 方法以及 Use 方法和为着色器传输数据的 Set 系列方法。具体方法的实现看这里：Shader.cpp 。 &emsp;&emsp;除了 Shader 之外，另一个资源类则是 Texture 类，这是我们的 Texture2D 类声明： 1234567891011121314151617181920212223242526#include &lt;GL/glew.h&gt;// Texture2D is able to store and configure a texture in OpenGL.// It also hosts utility functions for easy management.class Texture2D&#123;public: // Holds the ID of the texture object, used for all texture operations to reference to this particlar texture GLuint id&#123;&#125;; // Texture image dimensions GLuint width, height; // Width and height of loaded image in pixels // Texture Format GLuint internalFormat; // Format of texture object GLuint imageFormat; // Format of loaded image // Texture configuration GLuint wrapS; // Wrapping mode on S axis GLuint wrapT; // Wrapping mode on T axis GLuint filterMin; // Filtering mode if texture pixels &lt; screen pixels GLuint filterMax; // Filtering mode if texture pixels &gt; screen pixels // Constructor (sets default texture modes) Texture2D(); // Generates texture from image data void Generate(GLuint width, GLuint height, unsigned char* data); // Binds the texture as the current active GL_TEXTURE_2D texture object void Bind() const;&#125;; &emsp;&emsp;如 Shader 类一样，我们在类中封装了大量的属性和方法，具体实现也可以直接看源代码 Texture2D.cpp，毕竟这不是我们这次游戏练习的主要内容。 &emsp;&emsp;游戏类的封装我们在上一篇文章中介绍了，资源管理器类其实也就是我们上一篇文章中写的那几个，毕竟现在只是大概一个框架，没有多少详尽的内容。 &emsp;&emsp;这是 ResourceManager 类的声明： 123456789101112131415161718class ResourceManager&#123;public: // 定义着色器与纹理存储 static std::map&lt;std::string, Shader&gt; shaders; static std::map&lt;std::string, Texture2D&gt; textures; // 定义 Shader 交互方法 static Shader LoadShader(const GLchar *vertexShaderFile, const GLchar *fragmentShaderFile, const GLchar *geometryShaderFile, std::string name); static Shader GetShader(std::string name); // 定义 Texture2D 交互方法 static Texture2D LoadTexture2D(const GLchar *file, GLboolean alpha, std::string name); static Texture2D GetTexture2D(std::string name); ResourceManager(); ~ResourceManager();&#125;; &emsp;&emsp;具体实现也直接看源文件吧：ResourceManager.cpp &emsp;&emsp;在接下来的学习中，我们将着重于介绍围绕游戏逻辑以及游戏开发技术的方面，基础的 OpenGL 知识将一笔带过。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】Breakout-2-构建游戏框架]]></title>
    <url>%2F2018%2F03%2F12%2F%E3%80%90OpenGL%E3%80%91Breakout-2-%E6%9E%84%E5%BB%BA%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个真正的程序往往不是一个 main 方法就可以完成的，显然，对于初学 OpenGL 的我们（尽管我们可能有很长时间的 C/C++ 编程经验）来说，在初次实现一个小项目的时候，需要在开发之前理清项目结构。这样在正式编码的时候才能不会手忙脚乱。 &emsp;&emsp;首先定义顶级类游戏类（Game Class）控制游戏状态，资源管理器类控制游戏资源（ResourceManager Class），所以我们需要这两个类： 123456789// Game 类class Game &#123; ...&#125;;// ResourceManager 类class ResourceManager &#123; ... &#125;; &emsp;&emsp;除此之外，我们之前在代码中使用的 Shader 类和纹理操作也是需要封装的，在之前的 Shader 类中，我们用 Shader 类直接从读取着色器文件到返回 Program 全部在类内实现，这显然不是一个好的实现，更何况我们现在又有了全局的资源管理器类，所以将 Shader 类重写并添加相应的 Texture 类（Shader 和 Texture 统属于 ResourceManager 类进行管理，请注意我们的资源管理类是为了直接调用其他类而存在的，所以属性和方法等都用 static 修饰）。所以我们为 ResourceManager 类添加 Shader 和 Texture 的管理： 1234567891011// 定义着色器与纹理存储static std::map&lt;std::string, Shader&gt; shaders;static std::map&lt;std::string, Texture2D&gt; textures;// 定义 Shader 交互方法static Shader LoadShader(const GLchar *vertexShaderFile, const GLchar *fragmentShaderFile, const GLchar *geometryShaderFile, std::string name);static Shader GetShader(std::string name);// 定义 Texture2D 交互方法static Texture2D LoadTexture2D(const GLchar *file, GLboolean alpha, std::string name);static Texture2D GetTexture2D(std::string name); &emsp;&emsp;我们定义了用来存储 shader 对象和 texture 对象的变量，然后给定了从文件中读取源文件编译处理成 shader 或者 texture 并写入 map 的方法，并给定从 map 中返回 shader 或 texture 的方法。这样，我们在调用着色器或者纹理的时候可以这样操作。 12Shader shader = ResourceManager::GetShader("shader_name"); //调用已有着色器Shader shader = ResourceManager::LoadShader("vFile.vs" , "fFile.fs" , "gFile.gs" , "shader_name"); //使用新编译着色器 &emsp;&emsp;纹理操作类似。 &emsp;&emsp;在暂时不考虑细节实现的情况下，我们使用 ResourceManager 进行资源对象管理暂时就这样子了。接下来看另一个类 Game 。Game 类的主要作用是（简单）管理游戏代码，并与此同时将所有的窗口代码从游戏中解耦。这样子的话，我们就可以把相同的类迁移到完全不同的窗口库（比如SDL或SFML）而不需要做太多的工作。在我们的 Game 类中，我们需要一个游戏状态的属性（GameState），为此我们先创建一个枚举值代表游戏的不同状态： 12345enum GameState &#123; GAME_ACTIVE, GAME_MENU, GAME_WIN&#125;; &emsp;&emsp;除此外我们再封装一个初始化函数（Init），一个输入处理的函数（ProcessInput），一个画面的更新函数（Update），一个渲染函数（Render）。 1234567891011121314151617181920212223242526// 游戏状态enum GameState &#123; GAME_ACTIVE, GAME_MENU, GAME_WIN&#125;;// 游戏类class Game &#123;public: // 游戏状态 GameState state; GLboolean keys[1024]; GLuint width, height; // 构造方法与析构方法 Game(GLuint width , GLuint height); ~Game(); // 游戏初始化 void Init(); // 游戏输入处理 void ProcessInput(GLuint dt); // 游戏更新 void Update(GLfloat dt); // 渲染 void Render();&#125;; &emsp;&emsp;暂不考虑具体的实现，我们一个小游戏的框架首先要搭建起来，在这个游戏框架里， Game 类处理游戏代码， ResourceManager 管理游戏的资源。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swim-in-Rising-Water]]></title>
    <url>%2F2018%2F03%2F12%2FSwim-in-Rising-Water%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#778 Swim in Rising Water 题目描述&emsp;&emsp;On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). &emsp;&emsp;Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. &emsp;&emsp;You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: 12345678Input: [[0,2],[1,3]]Output: 3Explanation:At time 0, you are in grid location (0, 0).You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.You cannot reach point (1, 1) until time 3.When the depth of water is 3, we can swim anywhere inside the grid. Example 2: 1234567891011Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]Output: 16Explanation: 0 1 2 3 424 23 22 21 512 13 14 15 1611 17 18 19 2010 9 8 7 6The final route is marked in bold.We need to wait until time 16 so that (0, 0) and (4, 4) are connected. Note: 2 &lt;= N &lt;= 50. grid[i][j] is a permutation of [0, …, N*N - 1]. 解题思路&emsp;&emsp;题目意思是给定一个矩阵，里边的每个数字代表着第 N 秒才可以从这里通过，最终要求从左上角到右下角找出一条能最早到达的路径，也就是说一路上经过的数字都尽可能最小。 &emsp;&emsp;这道题思路基本上就是优先队列（Priority Queue）了，将经过的值都 push 进去，然后 pop 队首（因为是优先队列，所以是能到达的最小值），再从 pop 继续扩散。当到达右下角的时候返回。 解题代码【.CPP】12345678910111213141516171819202122232425262728293031class Solution &#123;public: struct T &#123; int t, x, y; T(int a, int b, int c) : t (a), x (b), y (c)&#123;&#125; bool operator&lt; (const T &amp;d) const &#123;return t &gt; d.t;&#125; &#125;; int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int N = grid.size (), res = 0; priority_queue&lt;T&gt; pq; pq.push(T(grid[0][0], 0, 0)); vector&lt;vector&lt;int&gt;&gt; seen(N, vector&lt;int&gt;(N, 0)); seen[0][0] = 1; static int dir[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123; -1, 0&#125;&#125;; while (true) &#123; auto p = pq.top (); pq.pop (); res = max(res, p.t); if (p.x == N - 1 &amp;&amp; p.y == N - 1) return res; for (auto&amp; d : dir) &#123; int i = p.x + d[0], j = p.y + d[1]; if (i &gt;= 0 &amp;&amp; i &lt; N &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; N &amp;&amp; !seen[i][j]) &#123; seen[i][j] = 1; pq.push (T(grid[i][j], i, j)); &#125; &#125; &#125; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】22-几何着色器]]></title>
    <url>%2F2018%2F03%2F12%2F%E3%80%90OpenGL%E3%80%9122-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】几何着色器 【英文版】Geometry Shader 学习记录&emsp;&emsp;我们这么多篇文章以来，着色器是很常用的东西了，在之前还介绍了着色器中一些变量以及接口块等使用技巧。而我们的着色器一直是顶点着色器，片段着色器两种。使用顶点着色器传递定点数据，使用片段着色器着色。而这篇文章中我们将介绍位于顶点着色器与片段着色器之间的可选着色器：几何着色器（Geometry Shader）。 &emsp;&emsp;几何着色器一般结构如下： 12345678#version 420 core //版本layout (input_primitive) in; //inputlayout (output_primitive, max_vertices = ver_count) out; //output// main functionvoid main() &#123; ...&#125; &emsp;&emsp;我们在几何着色器中首先需要定义两个变量，使用 layout 关键字，一个输出 out ，一个输入 in ，在 in 中我们接收一个图元作为属性。 &emsp;&emsp;The input_primitive type must match the primitive type for the vertex stream provided to the GS. If Tessellation is enabled, then the primitive type is specified by the Tessellation Evaluation Shader‘s output qualifiers. If Tessellation is not enabled, then the primitive type is provided by the drawing command that renders with this shader program. The valid values for input_primitive, along with the valid OpenGL primitive types or tessellation forms, are: GS input OpenGL primitives TES parameter vertex count points GL_POINTS point_mode 1 lines GL_LINES, GL_LINE_STRIP, GL_LINE_LIST isolines 2 lines_adjacency GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY N/A 4 triangles GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN triangles, quads 3 triangles_adjacency GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY N/A 6 &emsp;&emsp;The vertex count is the number of vertices that the GS receives per-input primitive. &emsp;&emsp;The output_primitive must be one of the following: points line_strip triangle_strip &emsp;&emsp;These work exactly the same way their counterpart OpenGL rendering modes do. To output individual triangles or lines, simply use EndPrimitive (see below) after emitting each set of 3 or 2 vertices. &emsp;&emsp;在 in 变量中我们接受一个图元，之后经过几何着色器的拓展我们可以将其转换为其他图元类型并且会传给片段着色器 max_vertices = ver_count 个顶点（请注意我们在这里定义了最大顶点个数，当其后的代码中超过最大数量后的定点会被抛弃）。 &emsp;&emsp;除了我们需要显性定义的 in 和 out 变量外，我们在集合着色器中也有用于输入的内建（built-in）接口块： 1234567// input built-in variablesin gl_PerVertex&#123; vec4 gl_Position; float gl_PointSize; float gl_ClipDistance[];&#125; gl_in[]; &emsp;&emsp;这是一个和顶点着色器中的 gl_Position 相似的内建变量，我们无需定义直接使用即可。使用方法如下： 1234567891011121314151617181920#version 420 corelayout(points) in;layout(line_strip , max_vertices = 4) out;void main()&#123; gl_Position = gl_in[0].gl_Position + vec4(1.0f , 1.0f , 0.0f , 0.0f); //右上 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(1.0f , -1.0f , 0.0f , 0.0f); //右下 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(-1.0f , -1.0f , 0.0f , 0.0f); //左下 EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4(-1.0f , 1.0f , 0.0f , 0.0f); //左上 EmitVertex(); EndPrimitive();&#125; &emsp;&emsp;在这段代码中，我们定义了输入进来的图元为 points ，然后输入为 line_strip ，且最大输出的定点数为 4 个。之后，我们使用 gl_in 这个内建接口块，从顶点着色器中读取 gl_Position 并复制给几何着色器中的内建变量。请注意我们在每一个 gl_Position 的赋值后都使用了 EmitVertex 函数，在 main 的结尾调用了 EndPrimitive 函数。 &emsp;&emsp;每次我们调用EmitVertex时，gl_Position中的向量会被添加到图元中来。当EndPrimitive被调用时，所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。在一个或多个EmitVertex调用之后重复调用EndPrimitive能够生成多个图元。在我们的例子代码中，我们为图元添加了四个顶点，并且将其合成为指定的渲染图元。最后效果如下： &emsp;&emsp;我们可以用几何着色器去增加顶点，修改图元等等。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】21-高级GLSL-Uniform与块元素]]></title>
    <url>%2F2018%2F03%2F11%2F%E3%80%90OpenGL%E3%80%9121-%E9%AB%98%E7%BA%A7GLSL-Uniform%E4%B8%8E%E5%9D%97%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[教程地址【中文版】高级GLSL 【英文版】Advanced GLSL 学习记录&emsp;&emsp;上篇文章中我们介绍了 GLSL 的内建变量，并简单的实现了几个例子。这篇文章中我们将介绍接口块（Interface Block）与 Uniform 缓冲对象（Uniform Buffer Object）。 &emsp;&emsp;接口块实际上就是 GLSL 中的结构体，我们使用它将多个同类变量放在一个结构中进行传递，定义如下： 123Block_Name &#123; ...&#125; Intance_Name; &emsp;&emsp;Block_Name 是接口块在传递过程中使用的名字，如果我们需要将数据从顶点着色器发送到片段着色器，那么必须保证 Block_Name 相同，这和普通的变量是相同的。举例如下： 12345678//顶点着色器中out Vertex_To_Fragment_Object &#123; ... vec4 pColor; ...&#125; VOO;VOO.pColor = ...; 12345678//片段着色器中in Vertex_To_Fragment_Object &#123; ... vec4 pColor; ...&#125; FII;... = FII.pColor; &emsp;&emsp;接口块其实就是个结构体嘛！ &emsp;&emsp;下来介绍 Uniform 缓冲对象： &emsp;&emsp;OpenGL 为我们提供了一个叫做 Uniform 缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的全局Uniform变量。当使用Uniform缓冲对象的时候，我们只需要设置相关的uniform一次。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。 &emsp;&emsp;因为Uniform缓冲对象仍是一个缓冲，我们可以使用glGenBuffers来创建它，将它绑定到GL_UNIFORM_BUFFER缓冲目标，并将所有相关的uniform数据存入缓冲。 &emsp;&emsp;如果说接口块是着色器之间传递数据的结构体，那么 Uniform Buffer Object 则是 OpenGL 代码与 着色器代码之间的结构体了。在我们之前的很多代码中，我们大量使用了 Uniform 变量，比如： 123uniform mat4 model;uniform mat4 projection;uniform mat4 view; &emsp;&emsp;而在这些代码中，一般情况下我们需要为每一个模型的着色器设置一次这个，然后再绘制的时候再大量的使用 glUniformMatrix4fv 方法为其赋值，所以经常看到这样的代码（我们使用了 Shader 类）： 1234567891011121314151617181920212223242526272829303132//绘制第一个模型someShader1.use();someShader1.setMat4("projection", projection);someShader1.setMat4("view", camera.GetViewMatrix());someShader1.setMat4("model", model1);glBindVertexArray(vertexArrayObject);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);//绘制第二个模型someShader2.use();someShader2.setMat4("projection", projection);someShader2.setMat4("view", camera.GetViewMatrix());someShader2.setMat4("model", model2);glBindVertexArray(vertexArrayObject);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);//绘制第三个模型someShader3.use();someShader3.setMat4("projection", projection);someShader3.setMat4("view", camera.GetViewMatrix());someShader3.setMat4("model", model3);glBindVertexArray(vertexArrayObject);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);//绘制第四个模型someShader4.use();someShader4.setMat4("projection", projection);someShader4.setMat4("view", camera.GetViewMatrix());someShader4.setMat4("model", model4);glBindVertexArray(vertexArrayObject);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0); &emsp;&emsp;可以看到，仅仅是 model 不同，我们就需要为每一个着色器赋值一遍，相对于而言 projection 和 view 几乎是不会因模型不同而异的。如果有几十个变量，几千个模型，那么我们就需要 几十*几千 行这样的冗余代码。而现在有了 UBO （Uniform Buffer Object），我们可以将其归类，统一绑定。 &emsp;&emsp;在着色器代码中我们定义 UBO ： 1234layout (std140) uniform VP&#123; mat4 projection; mat4 view;&#125;; &emsp;&emsp;我们将多个模型都相同的数据绑定在一起（关于 std140 等下解释），在 OpenGL 代码中，需要创建相应的 UBO 缓冲： 12345unsigned int uboBlock;glGenBuffers(1, &amp;uboBlock);glBindBuffer(GL_UNIFORM_BUFFER, uboBlock);glBufferData(GL_UNIFORM_BUFFER, sizeof(glm::mat4) * 2, nullptr, GL_STATIC_DRAW);glBindBuffer(GL_UNIFORM_BUFFER, 0); &emsp;&emsp;Uniform 缓冲的构建与其他缓冲相同，不过我们并没有进行初始化数据而是设为 nullptr ，size 我们设置为两个 mat4 的大小（我们 uniform 中有两个 mat4 变量）。 &emsp;&emsp;现在，每当我们需要对缓冲更新或者插入数据，我们都会绑定到uboExampleBlock，并使用glBufferSubData来更新它的内存。我们只需要更新这个Uniform缓冲一次，所有使用这个缓冲的着色器就都使用的是更新后的数据了。但是，如何才能让OpenGL知道哪个Uniform缓冲对应的是哪个Uniform块呢？ &emsp;&emsp;在OpenGL上下文中，定义了一些绑定点(Binding Point)，我们可以将一个Uniform缓冲链接至它。在创建Uniform缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的Uniform块绑定到相同的绑定点，把它们连接到一起。下面的这个图示展示了这个： &emsp;&emsp;你可以看到，我们可以绑定多个Uniform缓冲到不同的绑定点上。因为着色器A和着色器B都有一个链接到绑定点0的Uniform块，它们的Uniform块将会共享相同的uniform数据，uboMatrices，前提条件是两个着色器都定义了相同的Matrices Uniform块。 &emsp;&emsp;为了将Uniform块绑定到一个特定的绑定点中，我们需要调用glUniformBlockBinding函数，它的第一个参数是一个程序对象，之后是一个Uniform块索引和链接到的绑定点。Uniform块索引(Uniform Block Index)是着色器中已定义Uniform块的位置值索引。这可以通过调用glGetUniformBlockIndex来获取，它接受一个程序对象和Uniform块的名称。 &emsp;&emsp;我们将我们的着色器中的 VP 缓冲绑定到绑定点 0 上（我们可以将多个着色器的 VP 缓冲对象绑定到一个绑定点，只要他们 VP 的内容相同，这正是我们的目的）： 12const auto vpIndex = glGetUniformBlockIndex(glslShader.ID, "VP"); //获取着色器中的 uniform 缓冲对象位置索引glUniformBlockBinding(glslShader.ID, vpIndex, 0); //将其绑定到 0 绑定点 &emsp;&emsp;在 GLSL 420 （即 OpenGL 4.2版本）之后，支持直接在定义 Uniform 缓冲对象的时候绑定： 1234layout(std140, binding = 2) uniform VP &#123; mat4 projection; mat4 view;&#125;; &emsp;&emsp;现在将 OpenGL 代码中的 uboBlock 缓冲对象也绑定到 0 绑定点： 1glBindBufferBase(GL_UNIFORM_BUFFER, 0, uboBlock); //将 uboBlock 对象（OpenGL中的缓冲对象）绑定到 0 绑定点 &emsp;&emsp;这样绑定之后，我们可以使用 uboBlock 对象来更新着色器中的 Uniform 缓冲对象。我们使用之前介绍过的缓冲部分填充函数为其添加数据： 12glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), &amp;projection);glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4) , sizeof(glm::mat4), &amp;camera.GetViewMatrix()); &emsp;&emsp;正常使用。我们现在创建四个模型与四个着色器程序，每个着色器程序里仅仅是最后给的颜色不同，之后实现绑定，最后渲染： 12345678910111213141516171819202122232425262728293031const auto projection = glm::perspective(glm::radians(90.0f), static_cast&lt;float&gt;(WIDTH) / static_cast&lt;float&gt;(HEIGHT), 0.1f, 100.0f);auto camera = Camera(glm::vec3(0.0f, 0.0f, 10.0f));const auto model1 = glm::translate(glm::mat4(1.0f), glm::vec3(5.0f, 5.0f, 0.0f));const auto model2 = glm::translate(glm::mat4(1.0f), glm::vec3(-5.0f, 5.0f, 0.0f));const auto model3 = glm::translate(glm::mat4(1.0f), glm::vec3(5.0f, -5.0f, 0.0f));const auto model4 = glm::translate(glm::mat4(1.0f), glm::vec3(-5.0f, -5.0f, 0.0f));...//填充数据glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), &amp;projection);glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4), sizeof(glm::mat4), &amp;camera.GetViewMatrix());do &#123; glBindVertexArray(vertexArrayObject); glslShader1.use(); glslShader1.setMat4("model", model1); glDrawArrays(GL_TRIANGLES, 0, 36); glslShader2.use(); glslShader2.setMat4("model", model2); glDrawArrays(GL_TRIANGLES, 0, 36); glslShader3.use(); glslShader3.setMat4("model", model3); glDrawArrays(GL_TRIANGLES, 0, 36); glslShader4.use(); glslShader4.setMat4("model", model4); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0);&#125; &emsp;&emsp;效果如下： &emsp;最后，我们来解释下我们着色器代码中 stb140 的含义：std140 代表着我们使用140布局，这是 uniform 内存布局方式的一种。 &emsp;&emsp;Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。 &emsp;&emsp;假设着色器中有以下的这个Uniform块： 123456789layout (std140) uniform ExampleBlock&#123; float value; vec3 vector; mat4 matrix; float values[3]; bool boolean; int integer;&#125;; &emsp;&emsp;我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个vec3放置在float边上。不是所有的硬件都能这样处理，可能会在附加这个float之前，先将vec3填充(Pad)为一个4个float的数组。这个特性本身很棒，但是会对我们造成麻烦。 &emsp;&emsp;默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。使用共享布局时，GLSL是可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变。因为我们无法知道每个uniform变量的偏移量，我们也就不知道如何准确地填充我们的Uniform缓冲了。我们能够使用像是glGetUniformIndices这样的函数来查询这个信息，但这超出本节的范围了。 &emsp;&emsp;虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。 &emsp;&emsp;每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。 &emsp;&emsp;布局规则的原文可以在OpenGL的Uniform缓冲规范这里找到，但我们将会在下面列出最常见的规则。GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个N来表示。 类型 布局规则 标量，比如int和bool 每个标量的基准对齐量为N。 向量 2N或者4N。这意味着vec3的基准对齐量为4N。 标量或向量的数组 每个元素的基准对齐量与vec4的相同。 矩阵 储存为列向量的数组，每个向量的基准对齐量与vec4的相同。 结构体 等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。 &emsp;&emsp;和OpenGL大多数的规范一样，使用例子就能更容易地理解。我们会使用之前引入的那个叫做ExampleBlock的Uniform块，并使用std140布局计算出每个成员的对齐偏移量： 123456789101112131415layout (std140) uniform ExampleBlock&#123; // 基准对齐量 // 对齐偏移量 float value; // 4 // 0 vec3 vector; // 16 // 16 (必须是16的倍数，所以 4-&gt;16) mat4 matrix; // 16 // 32 (列 0) // 16 // 48 (列 1) // 16 // 64 (列 2) // 16 // 80 (列 3) float values[3]; // 16 // 96 (values[0]) // 16 // 112 (values[1]) // 16 // 128 (values[2]) bool boolean; // 4 // 144 int integer; // 4 // 148&#125;; &emsp;&emsp;通过在Uniform块定义之前添加layout (std140)语句，我们告诉OpenGL这个Uniform块使用的是std140布局。除此之外还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量。我们已经见过shared布局了，剩下的一个布局是packed。当使用紧凑(Packed)布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在每个着色器中都可能是不同的。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】Breakout-1-环境]]></title>
    <url>%2F2018%2F03%2F11%2F%E3%80%90OpenGL%E3%80%91Breakout-1-%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;终于开始用所学的东西去写点可以真正使用的内容了啊。由于之前的学习都是在 Mac 环境下，而这次的实战项目决定在 Windows 下使用 VS 2017 实现（VS的安装请去网上随便找个教程）。所以这篇文章主要为环境配置。 &emsp;&emsp;首先，这个练手实战项目中 OpenGL， GLFW , GLEW 三个库是必不可少的，其次我们使用 Assimp （可能会使用）导入模型，用 GLM 计算矩阵等，这篇中就是为了配置这些东西。 &emsp;&emsp;GLFW ， GLEW 下载比较简单，和 MAC 种差不多。下载 GLEW ，GLFW ，在这里我们依旧下载源文件，然后使用 CMake GUI 程序创建 VS2017 项目，之后将其编译为静态库（.lib）文件即可。 &emsp;&emsp;我们在 C 盘根目录创建 OpenGL 文件夹，并在其中创建子文件夹 libs 和 headers 。 &emsp;&emsp;之后，我们将生成的 lib 文件拖入 libs 文件夹，将源文件里的 headers 目录拖入 headers 目录，最好分类放，如下： &emsp;&emsp; Assimp 的话也差不多，点此 Assimp下载 源文件，同样生成为 .lib 文件， 放入 libs ， headers 文件夹拖入 headers 。 &emsp;&emsp;我们还需要 GLM 和 stbi 库（这两个只需要下载头文件）就可以了，GLM ，STBI 。将其放入 headers 文件夹。 &emsp;&emsp;做完以上步骤后，我们打开 Visual Studio ，创建新项目。 &emsp;&emsp;选择 Visual C++ 和 Empty Project。 &emsp;&emsp;项目创建完成后，我们右键项目打开属性 Properties 。点击 VC++ Directories ， 修改 Include Directories 将我们刚才的 headers 文件夹添加进去，修改 Library Directories 将 libs 文件夹添加进去。 &emsp;&emsp;除此之外，点击 Linker - Input ，在 Additional Dependencies 中添加我们刚才的那几个 lib 文件，比如我是 opengl32.lib ，glfw3.lib，glew32.lib，assimp.lib（opengl32.lib是我们安装 VS 就会有的，所以不用单独下载，当然你单独下载也可以）。 &emsp;&emsp;配置了这些之后，按理说已经没有问题了。我们创建 main.cpp 文件，输入以下代码做实验。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#define GLEW_STATIC#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#define WIDTH 1920#define HEIGHT 1080void InitGlfw() &#123; /*初始化glfw*/ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); //设置最大版本 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //设置最小版本 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //设置core-profile glfwWindowHint(GLFW_RESIZABLE, false); //设置不可改变大小#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif&#125;void DisPlayColor() &#123; static int r = 0; static int g = 128; static int b = 255; static int dr = 1; static int dg = 1; static int db = 1; glClearColor(r / 255.0f, g / 255.0f, b / 255.0f, 1.0f); r += dr; g += dg; b += db; if (r &gt; 255 || r &lt; 0) dr = -dr; if (g &gt; 255 || g &lt; 0) dg = -dg; if (b &gt; 255 || b &lt; 0) db = -db; glClear(GL_COLOR_BUFFER_BIT);&#125;void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) &#123; if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, GL_TRUE); &#125;&#125;int main()&#123; InitGlfw(); //创建一个窗口 GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, "Empty Window", nullptr, nullptr); //设置窗口环境 glfwMakeContextCurrent(window); if (window == nullptr) &#123; std::cout &lt;&lt; "Faild to create glfw window" &lt;&lt; std::endl; glfwTerminate(); &#125; //设置glew glewExperimental = GL_TRUE; if (glewInit() != GLEW_OK) &#123; std::cout &lt;&lt; "Faild to init glew" &lt;&lt; std::endl; return -1; &#125; //设置位置 glViewport(0, 0, WIDTH, HEIGHT); glfwSetKeyCallback(window, key_callback); while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); DisPlayColor(); glfwSwapBuffers(window); &#125; return 0;&#125; &emsp;&emsp;如果代码成功运行的话应该是一个不断变换背景颜色的空窗口，如果没有，那么请仔细检查下配置问题。 &emsp;&emsp;项目 Github 地址 : https://github.com/KsGin/OpenGL-BreakOut]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】20-高级GLSL-内建变量]]></title>
    <url>%2F2018%2F03%2F11%2F%E3%80%90OpenGL%E3%80%9120-%E9%AB%98%E7%BA%A7GLSL-%E5%86%85%E5%BB%BA%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[教程地址【中文版】高级GLSL 【英文版】Advanced GLSL 学习记录&emsp;&emsp;GLSL ，OpenGL Shading Language 。我们之前的代码中用了不少，但都是很短的代码，不管是顶点着色器或者是片段着色器都是简单的几行，我们对其了解也很少，这篇文章中就专门介绍 GLSL 。我们将会讨论一些有趣的内建变量(Built-in Variable)，管理着色器输入和输出的新方式以及一个叫做Uniform缓冲对象(Uniform Buffer Object)的有用工具。 &emsp;&emsp;所谓内建变量，其实就是着色器已经给我们定义好的变量，比如 gl_Position ，这个我们所有顶点着色器都使用过的变量，他定义输出了顶点的位置。 &emsp;&emsp;除了 gl_Position 外，GLSL 内建了很多其他变量，比如 gl_PointSize ，他允许我们修改每一个点的大小，当我们使用 GL_POINTS 为图元进行绘制时可以使用。 &emsp;&emsp;gl_PointSize 的使用比较简单，当在 OpenGL 中启用 gl_PontSize 之后，我们直接在顶点着色器里调用就是了。（此时我们需要将 glDrawArrays() 的绘制参数改为 GL_POINTS） 1234567891011#version 420 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 projection;uniform mat4 view;void main()&#123; gl_Position = projection * view * model * vec4(aPos , 1.0f); gl_PointSize = aPos.z * 10;&#125; &emsp;&emsp;在这里我们将其设置为顶点 z 轴（深度）的十倍，这样有一种越靠近我们顶点越大的感觉。 &emsp;&emsp;顶点着色器中还有一个内建变量 gl_VertexID ，用来访问我们当前所绘制的顶点的索引，当使用索引绘制时，即 glDrawElements 时他会存储当前索引，当使用 glDrawArrays 绘制时会存储当前已渲染的图元个数。这个变量可以被我们使用已做出一些有趣的效果，用刚才绘制的点的代码来示例，我们可以使每一个的颜色不同。 &emsp;&emsp;在顶点着色器中，我们使用 gl_VertexID 去设置一个到片段着色器的 vec4 变量，并在片段着色器中进行渲染。 1234567891011121314#version 420 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 projection;uniform mat4 view;out vec4 pColor;void main()&#123; gl_Position = projection * view * model * vec4(aPos , 1.0f); gl_PointSize = abs(aPos.z) * 10; pColor = vec4(gl_VertexID / 12.0f + 0.1f , gl_VertexID / 3.0f + 0.1f , gl_VertexID / 8.0f + 0.1f, 1.0f);&#125; 12345678#version 420 coreout vec4 FragColor;in vec4 pColor;void main()&#123; FragColor = pColor;&#125; &emsp;&emsp;由于顶点 ID 不同，所以亮度不同，效果如下： &emsp;&emsp;前两个是顶点着色器的内建变量，现在我们来看下片段着色器中的变量 gl_FragCoord ，gl_FragCoord 的 x 和 y 分量分别是屏幕的 x , y 坐标，z 则是深度变量，相当于 z 轴。以此，我们可以通过这个变量去对模型在屏幕的各个部位进行不同的着色，或者去实现其他有趣的效果。 &emsp;&emsp;我们将顶点分别放在屏幕中心两侧（x 轴0点两侧），并且略微调大了 gl_PointSize 使得等下效果更加显著。现在，我们在片段着色器里进行修改。 123456789101112#version 420 coreout vec4 FragColor;in vec4 pColor;void main()&#123; if(gl_FragCoord.x &lt; 960)&#123; FragColor = vec4(1.0f,1.0f,1.0f,0.0f); &#125; else &#123; FragColor = pColor; &#125;&#125; &emsp;&emsp;由于我们的屏幕 width 值为1920，所以960正好是一半，这样我们将凡是在屏幕 x 轴左边的全部渲染为白色，右边则是刚才的颜色。效果如下： &emsp;&emsp;可以看到，即便是一个点，只要依旧可以进行不同的着色。 &emsp;&emsp;接下来一个是 gl_FrontFacing 变量，这是一个布尔值变量，他告诉了我们当前的片段属于正面还是背面，以此我们也可以进行着色，例如对箱子外部和内部渲染不同的纹理等。（由于我这里代码只有点的，这个就不演示了）用法也极为简单： 123456789101112#version 420 coreout vec4 FragColor;in vec4 pColor;void main()&#123; if(gl_FrontFacing)&#123; //first color &#125; else &#123; //second color &#125;&#125; &emsp;&emsp;另外一个变量 gl_FragDepth 允许我们在片段着色器里修改深度值，然而，由我们自己设置深度值有一个很大的缺点，只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会（像深度测试小节中讨论的那样）禁用所有的提前深度测试(Early Depth Testing)。它被禁用的原因是，OpenGL无法在片段着色器运行之前得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。在写入gl_FragDepth时，你就需要考虑到它所带来的性能影响。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Serialize-and-Deserialize-BST]]></title>
    <url>%2F2018%2F03%2F11%2FSerialize-and-Deserialize-BST%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#449 Serialize and Deserialize BST 题目描述&emsp;&emsp;Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. &emsp;&emsp;Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 解题思路&emsp;&emsp;二叉搜索树的序列化与反序列化。 解题代码1234567891011121314151617181920212223242526272829303132class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; ostringstream os; serialize(root, os); return os.str(); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; istringstream is(data); return deserialize(is); &#125; void serialize(TreeNode* root, ostringstream&amp; os) &#123; if (!root) os &lt;&lt; "# "; else &#123; os &lt;&lt; root-&gt;val &lt;&lt; " "; serialize(root-&gt;left, os); serialize(root-&gt;right, os); &#125; &#125; TreeNode* deserialize(istringstream&amp; is) &#123; string val = ""; is &gt;&gt; val; if (val == "#") return NULL; TreeNode* node = new TreeNode(stoi(val)); node-&gt;left = deserialize(is); node-&gt;right = deserialize(is); return node; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】19-高级数据]]></title>
    <url>%2F2018%2F03%2F10%2F%E3%80%90OpenGL%E3%80%9119-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】高级数据 【英文版】Advanced Data 学习记录&emsp;&emsp;这篇文章中我们将介绍几个特殊的方法，glBufferSubData 和 glCopyBufferSubData 。看到这两个方法，我想你能够想到 glBufferData 吧。glBufferData 是我们在之前学习中填充数据的方法，我们使用它将顶点，法线等数据统一填充到 BO(Buffer Object) 里。而这篇文章中主要介绍了部分填充方法 glBufferSubData ，它允许我们分别填充顶点或者纹理坐标或者法线等等。 &emsp;&emsp;首先看一下 glBufferSubData 的官方介绍： 123456void glBufferSubData( GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data ); target Specifies the target to which the buffer object is bound for glBufferSubData, which must be one of the buffer binding targets in the following table: Buffer Binding Target Purpose GL_ARRAY_BUFFER Vertex attributes GL_ATOMIC_COUNTER_BUFFER Atomic counter storage GL_COPY_READ_BUFFER Buffer copy source GL_COPY_WRITE_BUFFER Buffer copy destination GL_DISPATCH_INDIRECT_BUFFER Indirect compute dispatch commands GL_DRAW_INDIRECT_BUFFER Indirect command arguments GL_ELEMENT_ARRAY_BUFFER Vertex array indices GL_PIXEL_PACK_BUFFER Pixel read target GL_PIXEL_UNPACK_BUFFER Texture data source GL_QUERY_BUFFER Query result buffer GL_SHADER_STORAGE_BUFFER Read-write storage for shaders GL_TEXTURE_BUFFER Texture data buffer GL_TRANSFORM_FEEDBACK_BUFFER Transform feedback buffer GL_UNIFORM_BUFFER Uniform block storage offset Specifies the offset into the buffer object’s data store where data replacement will begin, measured in bytes. size Specifies the size in bytes of the data store region being replaced. data Specifies a pointer to the new data that will be copied into the data store. &emsp;&emsp;这个方法给定了偏移量参数，允许我们在 buffer 的固定位置写入数据，第一个参数和 glBufferData 相同，第二个数据是偏移量，也就是你要开始写入的地址，第三个参数则是你要写入的大小，第四个则是 data 。也就是说你写入的数据应位于 BO 的 [ offset , offset + size ] 位置内。 &emsp;&emsp;那么这样做有什么意义呢，想想我们之前的顶点坐标数组，我们所有的数据信息必须是交叉存在的，也就是说数组排列必须如下 123456float vertices[] = &#123; pos1.x , pos1.y , pos1.z , nor1.x ,nor1.y , nor1.z , pos2.x , pos2.y , pos2.z , nor2.x ,nor2.y , nor2.z , ...&#125;glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); &emsp;&emsp;如上，我们的信息以每一个顶点为一个单元，其中顶点坐标，法线坐标，贴图UV，等等交叉混合在一个数组里。我们设置步长，每步采用个数等进行填充。而有了部分填充后，我们可以简单的将法线，UV坐标等分开放在多个数组里。 123456789101112float vertices[] = &#123; pos1.x , pos1.y , pos1.z , pos2.x , pos2.y , pos2.z , ...&#125;glBufferSubData(GL_ARRAY_BUFFER, 0 , sizeof(vertices), vertices);float normals[] = &#123; nor1.x ,nor1.y , nor1.z , nor2.x ,nor2.y , nor2.z , ...&#125;glBufferSubData(GL_ARRAY_BUFFER, 0 , sizeof(normals), normals); &emsp;&emsp;当然，如果你真的像上边这样简单的写了之后，那么你的程序基本上会崩掉。那是因为 glBufferSubData 方法和 glBufferData 最根本的不同在于 glBufferSubData 是不分配内存的。所以你需要在调用 glBufferSubData 之前调用 glBufferData 并将其 data 设置为 null （随便你设置什么，反正你后边使用 glBufferSubData 会将本来里边的数据冲走）。 &emsp;&emsp;glBufferSubData 这个方法提供给了我们部分更新缓冲的能力，也使得我们实现某个功能时可以有更完美的选择。 &emsp;&emsp;OpenGL中的缓冲只是一个管理特定内存块的对象，没有其它更多的功能了。在我们将它绑定到一个缓冲目标(Buffer Target)时，我们才赋予了其意义。当我们绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲，但我们也可以很容易地将其绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。 &emsp;&emsp;将数据导入缓冲的另外一种方法是，请求缓冲内存的指针，直接将数据复制到缓冲当中。通过调用glMapBuffer函数，OpenGL会返回当前绑定缓冲的内存指针。之后可以使用例如 memset 等 c 中常用方法进行填充，拷贝等。 &emsp;&emsp;除了这个之外，这篇中还需要介绍的一个方法是 glCopyBufferSubData ： 1234567void glCopyBufferSubData( GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size ); readTarget Specifies the target to which the source buffer object is bound for glCopyBufferSubData writeTarget Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. readOffset Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. writeOffset Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. size Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. Description&emsp;&emsp;glCopyBufferSubData and glCopyNamedBufferSubData copy part of the data store attached to a source buffer object to the data store attached to a destination buffer object. The number of basic machine units indicated by size is copied from the source at offset readOffset to the destination at writeOffset. readOffset, writeOffset and size are in terms of basic machine units. &emsp;&emsp;For glCopyBufferSubData, readTarget and writeTarget specify the targets to which the source and destination buffer objects are bound, and must each be one of the buffer binding targets in the following table: Buffer Binding Target Purpose GL_ARRAY_BUFFER Vertex attributes GL_ATOMIC_COUNTER_BUFFER Atomic counter storage GL_COPY_READ_BUFFER Buffer copy source GL_COPY_WRITE_BUFFER Buffer copy destination GL_DISPATCH_INDIRECT_BUFFER Indirect compute dispatch commands GL_DRAW_INDIRECT_BUFFER Indirect command arguments GL_ELEMENT_ARRAY_BUFFER Vertex array indices GL_PIXEL_PACK_BUFFER Pixel read target GL_PIXEL_UNPACK_BUFFER Texture data source GL_QUERY_BUFFER Query result buffer GL_SHADER_STORAGE_BUFFER Read-write storage for shaders GL_TEXTURE_BUFFER Texture data buffer GL_TRANSFORM_FEEDBACK_BUFFER Transform feedback buffer GL_UNIFORM_BUFFER Uniform block storage &emsp;&emsp;Any of these targets may be used, but the targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are provided specifically to allow copies between buffers without disturbing other GL state. &emsp;&emsp;readOffset, writeOffset and size must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of the buffer bound to writeTarget. If the source and destination are the same buffer object, then the source and destination ranges must not overlap. &emsp;&emsp;这个方法提供给了我们将缓冲中的一部分复制给另一部分的功能，我们可以自由的复制缓冲中的一部分数据。readtarget和writetarget参数需要填入复制源和复制目标的缓冲目标。比如说，我们可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。 &emsp;&emsp;但如果我们想读写数据的两个不同缓冲都为顶点数组缓冲该怎么办呢？我们不能同时将两个缓冲绑定到同一个缓冲目标上。正是出于这个原因，OpenGL提供给我们另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER。我们接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为readtarget和writetarget参数。 &emsp;&emsp;接下来glCopyBufferSubData会从readtarget中读取size大小的数据，并将其写入writetarget缓冲的writeoffset偏移量处。下面这个例子展示了如何复制两个顶点数组缓冲： 1234float vertexData[] = &#123; ... &#125;;glBindBuffer(GL_COPY_READ_BUFFER, vbo1);glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData)); &emsp;&emsp;这两个方法在一些场景是非常有用的。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parse-Lisp-Expression]]></title>
    <url>%2F2018%2F03%2F10%2FParse-Lisp-Expression%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#736 Parse Lisp Expression 题目描述&emsp;&emsp;You are given a string expression representing a Lisp-like expression to return the integer value of. &emsp;&emsp;The syntax for these expressions is given as follows. &emsp;&emsp;An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable. Expressions always evaluate to a single integer. &emsp;&emsp;(An integer could be positive or negative.) &emsp;&emsp;A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string &quot;let&quot;, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr. &emsp;&emsp;An add-expression takes the form (add e1 e2) where add is always the string &quot;add&quot;, there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2. &emsp;&emsp;A mult-expression takes the form (mult e1 e2) where mult is always the string &quot;mult&quot;, there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2. &emsp;&emsp;For the purposes of this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally for your convenience, the names “add”, “let”, or “mult” are protected and will never be used as variable names. &emsp;&emsp;Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on scope. Evaluation Examples: 1234567891011121314151617181920212223242526272829303132Input: (add 1 2)Output: 3Input: (mult 3 (add 2 3))Output: 15Input: (let x 2 (mult x 5))Output: 10Input: (let x 2 (mult x (let x 3 y 4 (add x y))))Output: 14Explanation: In the expression (add x y), when checking for the value of the variable x,we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.Since x = 3 is found first, the value of x is 3.Input: (let x 3 x 2 x)Output: 2Explanation: Assignment in let statements is processed sequentially.Input: (let x 1 y 2 x (add x y) (add x y))Output: 5Explanation: The first (add x y) evaluates as 3, and is assigned to x.The second (add x y) evaluates as 3+2 = 5.Input: (let x 2 (add (let x 3 (let x 4 x)) x))Output: 6Explanation: Even though (let x 4 x) has a deeper scope, it is outside the contextof the final x in the add-expression. That final x will equal 2.Input: (let a1 3 b2 (add a1 1) b2) Output 4Explanation: Variable names can contain digits after the first character. Note: &emsp;&emsp;The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses. The expression is guaranteed to be legal and evaluate to an integer. &emsp;&emsp;The length of expression is at most 2000. (It is also non-empty, as that would not be a legal expression.) &emsp;&emsp;The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer. 解题思路&emsp;&emsp;这是一道类似于字符串计算器的题，只是 Lisp 的语法有些麻烦。善用递归循环就可以解决。 解题代码【.CPP】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class Solution &#123; int cal(string expression , unordered_map&lt;string , int&gt; ky)&#123; string exp = ""; int ret = 0; if(expression[0] == '(')&#123; //解析 () ret = cal(expression.substr(1 , expression.size()-2) , ky); return ret; &#125; else if(isdigit(expression[0]) || expression[0] == '-')&#123; //解析数字 exp += expression[0]; for (int i = 1; i &lt; expression.size(); ++i) &#123; if(!isdigit(expression[i])) break; else exp += expression[i]; &#125; ret = atoi(exp.c_str()); return ret; &#125; else if((expression.substr(0,3) == "add" &amp;&amp; expression[3] == ' ') || (expression.substr(0,4) == "mult" &amp;&amp; expression[4] == ' '))&#123; //解析 and 和 mult int i , k = 0; int start = (expression[0] == 'a') ? 4 : 5; if(expression[start] == '(')&#123; k = 0; for (i = start + 1; i &lt; expression.size(); ++i) &#123; if(expression[i] == ')' &amp;&amp; k == 0) &#123; i++; break; &#125; else &#123; if(expression[i] == '(') k++; if(expression[i] == ')') k--; exp += expression[i]; &#125; &#125; &#125; else &#123; for (i = start; i &lt; expression.size(); ++i) &#123; if(expression[i] == ' ') break; else exp += expression[i]; &#125; &#125; int par1 = cal(exp , ky); exp = string(""); if(expression[i+1] == '(')&#123; k = 0; for (i = i+2; i &lt; expression.size(); ++i) &#123; if(expression[i] == ')' &amp;&amp; k == 0) &#123; i++; break; &#125; else &#123; if(expression[i] == '(') k++; if(expression[i] == ')') k--; exp += expression[i]; &#125; &#125; &#125; else &#123; for (i = i+1; i &lt; expression.size(); ++i) &#123; if(expression[i] == ' ') break; else exp += expression[i]; &#125; &#125; int par2 = cal(exp , ky); if(expression[0] == 'a')&#123; ret = par1 + par2; &#125; else &#123; ret = par1 * par2; &#125; return ret; &#125; else if(expression[0] == 'l')&#123; //解析let string key = ""; int k = 0; for (int i = 4; i &lt; expression.size(); ++i) &#123; if(expression[i] == '(')&#123; k = 0; i++; while ((expression[i] != ')' &amp;&amp; i &lt; expression.size()) || k != 0) &#123; //key if(expression[i] == '(') k++; if(expression[i] == ')') k--; key += expression[i]; i++; &#125; i++; &#125; else &#123; while (expression[i] != ' ' &amp;&amp; i &lt; expression.size()) &#123; //key key += expression[i]; i++; &#125; &#125; if(i == expression.size()) break; ++i; if(expression[i] == '(')&#123; i++; k = 0; exp = string(""); while (expression[i] != ')' || k != 0)&#123; if(expression[i] == '(') k++; if(expression[i] == ')') k--; exp += expression[i]; i++; &#125; i++; ky[key] = cal(exp , ky); key = string(""); &#125; else &#123; exp = string(""); while (expression[i] != ' ')&#123; exp += expression[i]; i++; &#125; ky[key] = cal(exp , ky); key = string(""); &#125; &#125; ret = cal(key , ky); return ret; &#125; else &#123; exp = string(""); ret = ky[expression]; return ret; &#125; &#125;public: int evaluate(string expression) &#123; int ret = cal(expression , unordered_map&lt;string , int&gt;()); return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】18-三维贴图]]></title>
    <url>%2F2018%2F03%2F09%2F%E3%80%90OpenGL%E3%80%9118-%E4%B8%89%E7%BB%B4%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】立方体贴图 【英文版】Cubemaps 学习记录&emsp;&emsp;之前我们学习的纹理贴图都是为某一面进行贴图，这篇文章中，将会学到一种一般用来构建基本环境的贴图方式：立方体贴图。 &emsp;&emsp;立方体贴图很容易理解，就是为一个立方体的六个面进行贴图，不过这次不是在表面。我们以立方体内部中心为原点，为立方体内部面贴图（是不是觉得是在渲染一个房间环境或者一个巨大的场景贴图，没错！）。依照此贴图我们可以去渲染出一些很好看的场景。 &emsp;&emsp;简单来说，立方体贴图就是一个包含了6个2D纹理的纹理，每个2D纹理都组成了立方体的一个面：一个有纹理的立方体。你可能会奇怪，这样一个立方体有什么用途呢？为什么要把6张纹理合并到一张纹理中，而不是直接使用6个单独的纹理呢？立方体贴图有一个非常有用的特性，它可以通过一个方向向量来进行索引/采样。假设我们有一个1x1x1的单位立方体，方向向量的原点位于它的中心。使用一个橘黄色的方向向量来从立方体贴图上采样一个纹理值会像是这样： &emsp;&emsp;方向向量的大小并不重要，只要提供了方向，OpenGL就会获取方向向量（最终）所击中的纹素，并返回对应的采样纹理值。 &emsp;&emsp;如果我们假设将这样的立方体贴图应用到一个立方体上，采样立方体贴图所使用的方向向量将和立方体（插值的）顶点位置非常相像。这样子，只要立方体的中心位于原点，我们就能使用立方体的实际位置向量来对立方体贴图进行采样了。接下来，我们可以将所有顶点的纹理坐标当做是立方体的顶点位置。最终得到的结果就是可以访问立方体贴图上正确面(Face)纹理的一个纹理坐标。 &emsp;&emsp;立方体贴图也是纹理贴图，所以创建基本一样： 123unsigned int textureID;glGenTextures(1, &amp;textureID);glBindTexture(GL_TEXTURE_CUBE_MAP, textureID); &emsp;&emsp;因为立方体贴图包含有6个纹理，每个面一个，我们需要调用glTexImage2D函数6次，参数和之前教程中很类似。但这一次我们将纹理目标(target)参数设置为立方体贴图的一个特定的面，告诉OpenGL我们在对立方体贴图的哪一个面创建纹理。这就意味着我们需要对立方体贴图的每一个面都调用一次glTexImage2D。 &emsp;&emsp;由于我们有6个面，OpenGL给我们提供了6个特殊的纹理目标，专门对应立方体贴图的一个面。 纹理目标 方位 GL_TEXTURE_CUBE_MAP_POSITIVE_X 右 GL_TEXTURE_CUBE_MAP_NEGATIVE_X 左 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 上 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 下 GL_TEXTURE_CUBE_MAP_POSITIVE_Z 后 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 前 &emsp;&emsp;这六个纹理目标都是枚举值，这代表着他们其实也是从 0 开始的 Int 值，也就是说只要我们按照相应的顺序排放贴图顺序，我们就可以使用 for 循环实现贴图。 123456789// 立方体贴图 std::vector&lt;std::string&gt; faces&#123; "../resources/shadowpeak_rt.tga", //right "../resources/shadowpeak_lf.tga", //left "../resources/shadowpeak_up.tga", //up "../resources/shadowpeak_dn.tga", //down "../resources/shadowpeak_bk.tga", //back "../resources/shadowpeak_ft.tga" //front &#125;; &emsp;&emsp;之后，我们使用 for 遍历来贴图： 1234567GLint face_width, face_height, face_nrChannels; unsigned char *data; for (int i = 0; i &lt; faces.size(); ++i) &#123; data = stbi_load(faces[i].c_str(), &amp;face_width, &amp;face_height, &amp;face_nrChannels, 0); glTexImage2D(static_cast&lt;GLenum&gt;(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i), 0, GL_RGB, face_width, face_height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); &#125; &emsp;&emsp;同时设定立方体贴图的线性过滤和环绕方式： 12345glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); &emsp;&emsp;而在着色器中，我们使用 uniform samplerCube cubemap; 来创建立方体贴图的 uniform 对象，由于立方体贴图的特性，我们用立方体顶点坐标向量就可以对纹理进行采样。所以在顶点着色器中传入立方体顶点坐标，并将其传入给片段着色器，然后调用： 1FragColor = texture(cubemap, textureDir); //texture方向 即顶点坐标 &emsp;&emsp;我们可以使用立方体贴图来创造环境贴图，在这里可以下载立方体贴图。本来按理说这里已经结束了，我们应该看到一个完美的环境贴图，但是启动后却发现并非如此： &emsp;&emsp;可以看到，我们的上下贴图与前后左右贴图并没有完美的契合，这其实是一个 OpenGL 的问题，见此 Convention of faces in OpenGL cubemapping ，我们修改贴图数组的顺序使得其显示正确。 123456789// 立方体贴图std::vector&lt;std::string&gt; faces&#123; "../resources/glacier_ft.tga", //front "../resources/glacier_bk.tga", //back "../resources/glacier_up.tga", //up "../resources/glacier_dn.tga", //down "../resources/glacier_rt.tga", //right "../resources/glacier_lf.tga", //left&#125;; &emsp;&emsp;这样，显示成功。 &emsp;&emsp;我们可以试着转动摄像机以查看身后或者其他方向，是不是一切正常了？完整代码在此：GitHub]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Escape-The-Ghosts]]></title>
    <url>%2F2018%2F03%2F09%2FEscape-The-Ghosts%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#789 Escape The Ghosts 题目描述&emsp;&emsp;You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is(target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at(ghosts[i][0], ghosts[i][1]). &emsp;&emsp;Each turn, you and all ghosts simultaneously may move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away. &emsp;&emsp;You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.) If you reach any square (including the target) at the same time as a ghost, it doesn’t count as an escape. &emsp;&emsp;Return True if and only if it is possible to escape. 1234567Example 1:Input: ghosts = [[1, 0], [0, 3]]target = [0, 1]Output: trueExplanation: You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you. 1234567Example 2:Input: ghosts = [[1, 0]]target = [2, 0]Output: falseExplanation: You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination. 1234567Example 3:Input: ghosts = [[2, 0]]target = [1, 0]Output: falseExplanation: The ghost can reach the target at the same time as you. Note: All points have coordinates with absolute value &lt;= 10000. The number of ghosts will not exceed 100. 解题思路&emsp;&emsp;ghosts 可以四处移动或者静止不动，所以要判断能够安全到达目的地，只需要判断所有鬼魂到达目的地的时间比玩家长就是了，即判断所有鬼魂距离目的地逗比玩家远。 解题代码【.CPP】123456789101112131415class Solution &#123; bool canEscape(vector&lt;int&gt; &amp;ghost , vector&lt;int&gt;&amp; target) &#123; auto distance1 = abs(target[0]) + abs(target[1]); auto distance2 = abs(target[0]-ghost[0]) + abs(target[1] - ghost[1]); return distance1 &lt; distance2; &#125;public: bool escapeGhosts(vector&lt;vector&lt;int&gt;&gt; &amp;ghosts, vector&lt;int&gt; &amp;target) &#123; for (auto &amp;ghost : ghosts) &#123; if(!canEscape(ghost , target)) return false; &#125; return true; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】17-帧缓冲与离屏渲染]]></title>
    <url>%2F2018%2F03%2F08%2F%E3%80%90OpenGL%E3%80%9117-%E5%B8%A7%E7%BC%93%E5%86%B2%E4%B8%8E%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】帧缓冲 【英文版】Framebuffers 学习记录&emsp;&emsp;帧缓冲（Framebuffer Object, FBO），是 OpenGL 中实现后处理效果的核心技术，在我们之前的代码中，所有的不论是颜色缓冲，深度缓冲等等都是使用的默认帧缓冲，即在主循环中实现渲染并且反映到窗口中。现在我们在默认缓冲之外创建一个自己的帧缓冲对象，在当前帧缓冲之外渲染，以实现一些炫酷的效果。请注意我们使用我们自定义的缓冲对象进行渲染的时候，他是不会显示在主窗口的，所以又称为离屏渲染。 &emsp;&emsp;帧缓冲的创建和其他缓冲类似： 123GLuint FBO; glGenFramebuffers(1, &amp;FBO); glBindFramebuffer(GL_FRAMEBUFFER, FBO); &emsp;&emsp;注意，当我们使用了 glBindFramebuffer(GL_FRAMEBUFFER, FBO); 绑定帧缓冲之后，我们之后所做的渲染都是在 FBO 缓冲上，如果我们要返回默认缓冲，则使用： 1glBindFramebuffer(GL_FRAMEBUFFER, 0); &emsp;&emsp;我们也可以使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER，将一个帧缓冲分别绑定到读取目标或写入目标。绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。大部分情况你都不需要区分它们，通常都会使用GL_FRAMEBUFFER，绑定到两个上。 &emsp;&emsp;创建了缓冲之后，我们需要为缓冲添加内容，现在的它还不完整(Complete)，一个完整的帧缓冲需要满足以下的条件： 附加至少一个缓冲（颜色、深度或模板缓冲）。 至少有一个颜色附件(Attachment)。 所有的附件都必须是完整的（保留了内存）。 每个缓冲都应该有相同的样本数。 &emsp;&emsp;如果你不知道什么是样本，不要担心，我们将在之后的教程中讲到。 &emsp;&emsp;我们可以主动判断帧缓冲是否完整： 123if (glCheckFramebufferStatus(FBO) != GL_FRAMEBUFFER_COMPLETE) &#123; std::cout &lt;&lt; "FRAME::BUFFER::ERROR" &lt;&lt; std::endl;&#125; &emsp;&emsp;现在，为帧缓冲添加一个纹理贴图附件，首先创建纹理： 1234567GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, WIDTH, HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glBindTexture(GL_TEXTURE_2D, 0); &emsp;&emsp;请注意我们 glTexImage2D 方法中 data 的参数设置了 nullptr ，是因为我们要将纹理绑定为帧缓冲的附件，使得我们所渲染的画面成为一个纹理（然后可以将它作为贴图贴到其他地方）。接下来绑定纹理： 1glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); &emsp;&emsp;glFrameBufferTexture2D有以下的参数： target：帧缓冲的目标（绘制、读取或者两者皆有） attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。 textarget：你希望附加的纹理类型 texture：要附加的纹理本身 level：多级渐远纹理的级别。我们将它保留为0。 &emsp;&emsp;在绑定纹理后，我们还需要为其添加深度缓冲和模板缓冲，使用： 12glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_DEPTH_COMPONENT, texture, 0); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_STENCIL_INDEX, texture, 0); &emsp;&emsp;或者将其放在一起： 12345glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, WIDTH, HEIGHT, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); &emsp;&emsp;除了这两种，我们来介绍另一个东西：渲染缓冲对象附件 &emsp;&emsp;渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到OpenGL中，作为一个可用的帧缓冲附件类型的，所以在过去纹理是唯一可用的附件。和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。 &emsp;&emsp;渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。 &emsp;&emsp;因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。 &emsp;&emsp;既然也是缓冲对象，那么使用类似： 123456GLuint RBO; glGenRenderbuffers(1, &amp;RBO); glBindRenderbuffer(GL_RENDERBUFFER, RBO); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, WIDTH, HEIGHT); glBindRenderbuffer(GL_RENDERBUFFER, 0); glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, RBO); &emsp;&emsp;我们在 glRenderbufferStorage 的参数里设置内部格式为：GL_DEPTH24_STENCIL8 （即 24 位深度 + 8 位模板缓冲）。 &emsp;&emsp;现在我们将颜色缓冲，深度缓冲，模板缓冲都加在了帧缓冲里，现在为其的纹理进行渲染，我们使用之前光照的部分场景，将其渲染到帧缓冲内部： 12345678910111213141516171819202122232425262728293031323334do &#123; glBindFramebuffer(GL_FRAMEBUFFER, FBO); //以下内容绘制在自定义的帧缓冲里 glEnable(GL_DEPTH_TEST); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glUseProgram(cudeProgram); glUniformMatrix4fv(glGetUniformLocation(cudeProgram, "view"), 1, GL_FALSE, &amp;View[0][0]); glUniformMatrix4fv(glGetUniformLocation(cudeProgram, "model"), 1, GL_FALSE, &amp;cudeModel[0][0]); glUniformMatrix4fv(glGetUniformLocation(cudeProgram, "projection"), 1, GL_FALSE, &amp;Projection[0][0]); glUniform3f(glGetUniformLocation(cudeProgram, "viewPos"), 4.0f, 5.0f, 3.0f); glUniform3f(glGetUniformLocation(cudeProgram, "lightPos"), 0.0f, 1.0f, 0.0f); glUniform3f(glGetUniformLocation(cudeProgram, "objectColor"), 1.0f, 0.5f, 0.31f); glUniform3f(glGetUniformLocation(cudeProgram, "lightColor"), 1.0f, 1.0f, 1.0f); glBindVertexArray(cudeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0); glUseProgram(lightProgram); glUniformMatrix4fv(glGetUniformLocation(lightProgram, "projection"), 1, GL_FALSE, &amp;Projection[0][0]); glUniformMatrix4fv(glGetUniformLocation(lightProgram, "view"), 1, GL_FALSE, &amp;View[0][0]); glUniformMatrix4fv(glGetUniformLocation(lightProgram, "model"), 1, GL_FALSE, &amp;lightModel[0][0]); glBindVertexArray(lightVAO); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0); // Swap buffers glfwSwapBuffers(window); glfwPollEvents(); &#125; while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &amp;&amp; glfwWindowShouldClose(window) == 0); &emsp;&emsp;我们在 do-while 的循环里第一行绑定了缓冲为我们所定义的帧缓冲 FBO，之后的代码里所做的渲染将都渲染到 FBO 里，并变成可以使用的纹理（还记得之前创建的那个 data 为空的纹理吗）。现在如果启动，黑色窗口将不会有任何显示，因为并没有在主窗口的默认缓冲放入任何内容。 &emsp;&emsp;现在我们创建一个窗口大小的长方形，并将纹理贴在上方（这样的显示与我们没有使用帧缓冲是一致的），首先创建长方形数组（代码请见 Github ），并配置相应的 VAO , VBO 以及着色器程序，在 Github 都可以找到。最后，我们在 do-while 循环里将帧缓冲绑定为默认缓冲，并为长方形附上纹理。 123456789101112131415do&#123; ... glBindFramebuffer(GL_FRAMEBUFFER, 0); //以下为默认窗口帧缓冲 glDisable(GL_DEPTH_TEST); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(screenProgram); glUniform1i(glGetUniformLocation(screenProgram, "screenTexture"), 0); glBindTexture(GL_TEXTURE_2D, texture); glBindVertexArray(screenVAO); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); ... &#125;(...) &emsp;&emsp;我们在帧缓冲里渲染的内容作为一个纹理贴图在我们所画的长方形上成功显示。 &emsp;&emsp;当然，帧缓冲的作用并不是让我们如此去多次一举的写代码，而是实现很多很好玩的特效，因为现在我们将之前的缓冲做成纹理，所以我们可以在着色器里对纹理做很多的改动，例如修改颜色为 x = 1 - x （反相）等等。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kth-Smallest-Element-in-a-BST]]></title>
    <url>%2F2018%2F03%2F08%2FKth-Smallest-Element-in-a-BST%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#230 Kth Smallest Element in a BST 题目描述&emsp;&emsp;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: &emsp;&emsp;You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Follow up:&emsp;&emsp;What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? 解题思路&emsp;&emsp;题目要求找到树种第K个最小的值，可以将树的节点值保存到容器数组中，然后排序就可以了。emm 解题代码【.CPP】12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; void getValue(TreeNode* root , vector&lt;int&gt;&amp; values)&#123; if(!root) return; values.push_back(root-&gt;val); getValue(root-&gt;left , values); getValue(root-&gt;right , values); &#125;public: int kthSmallest(TreeNode* root, int k) &#123; vector&lt;int&gt; valuse(0); getValue(root , valuse); sort(valuse.begin(),valuse.end()); return valuse[k-1]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】16-面剔除]]></title>
    <url>%2F2018%2F03%2F07%2F%E3%80%90OpenGL%E3%80%9116-%E9%9D%A2%E5%89%94%E9%99%A4%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】面剔除 【英文版】Face culling 学习记录&emsp;&emsp;这一篇文章内容很少，其实我并不想将这一个放一篇文章的，毕竟我这并不是什么教程（Emm 也没人看）。这篇内容就是在渲染过程中进行的一部分优化。我们在渲染一个模型的时候，都是每个面都进行渲染，但是以我们的视角来看，有一部分面是根本不可见的。我们却要对它进行渲染，这样浪费了很多的时间。 &emsp;&emsp;尝试在脑子中想象一个3D立方体，数数你从任意方向最多能同时看到几个面。如果你的想象力不是过于丰富了，你应该能得出最大的面数是3。你可以从任意位置和任意方向看向这个立方体，但你永远不能看到3个以上的面。所以我们为什么要浪费时间绘制我们不能看见的那3个面呢？如果我们能够以某种方式丢弃这几个看不见的面，我们能省下超过50%的片段着色器执行数！ &emsp;&emsp;我说的是超过50%而不是50%，因为从特定角度来看的话只能看见2个甚至是1个面。在这种情况下，我们就能省下超过50%了。 &emsp;&emsp;这是一个很好的主意，但我们仍有一个问题需要解决：我们如何知道一个物体的某一个面不能从观察者视角看到呢？&emsp;&emsp;如果我们想象任何一个闭合形状，它的每一个面都有两侧，每一侧要么面向用户，要么背对用户。如果我们能够只绘制面向观察者的面呢？ &emsp;&emsp;OpenGL 能够只渲染面向观察点的面而抛弃背向我们的那一边，面剔除默认是禁用的，要启用它使用 glEnable() 方法： 1glEnable(GL_CULL_FACE); &emsp;&emsp;当然，仅仅启动也是使用默认的面剔除类型，要自定义剔除面需要使用方法： 1glCullFace(GL_FRONT); &emsp;&emsp;glCullFace函数有三个可用的选项： GL_BACK：只剔除背向面。 GL_FRONT：只剔除正向面。 GL_FRONT_AND_BACK：剔除正向面和背向面。 &emsp;&emsp;glCullFace的初始值是GL_BACK。 &emsp;&emsp;OpenGL 能够剔除背面，但是需要我们告诉他哪边是正面那边是背面。这里有一个很聪明的技巧，分析顶点数据的环绕顺序(Winding Order)。 12345678910float vertices[] = &#123; // 顺时针 vertices[0], // 顶点1 vertices[1], // 顶点2 vertices[2], // 顶点3 // 逆时针 vertices[0], // 顶点1 vertices[2], // 顶点3 vertices[1] // 顶点2 &#125;; &emsp;&emsp;当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，我们会从三角形中间来看，为这3个顶点设定一个环绕顺序。 &emsp;&emsp;可以看到，我们首先定义了顶点1，之后我们可以选择定义顶点2或者顶点3，这个选择将定义了这个三角形的环绕顺序。上边的代码展示了这点。 &emsp;&emsp;每组组成三角形图元的三个顶点就包含了一个环绕顺序。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。 &emsp;&emsp;当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从观察者视角所见的了。 &emsp;&emsp;观察者所面向的所有三角形顶点就是我们所指定的正确环绕顺序了，而立方体另一面的三角形顶点则是以相反的环绕顺序所渲染的。这样的结果就是，我们所面向的三角形将会是正向三角形，而背面的三角形则是背向三角形。下面这张图显示了这个效果： &emsp;&emsp;在顶点数据中，我们将两个三角形都以逆时针顺序定义（正面的三角形是1、2、3，背面的三角形也是1、2、3（如果我们从正面看这个三角形的话））。然而，如果从观察者当前视角使用1、2、3的顺序来绘制的话，从观察者的方向来看，背面的三角形将会是以顺时针顺序渲染的。虽然背面的三角形是以逆时针定义的，它现在是以顺时针顺序渲染的了。这正是我们想要剔除（Cull，丢弃）的不可见面了！ &emsp;&emsp;在顶点数据中，我们定义的是两个逆时针顺序的三角形。然而，从观察者的方面看，后面的三角形是顺时针的，如果我们仍以1、2、3的顺序以观察者当面的视野看的话。即使我们以逆时针顺序定义后面的三角形，它现在还是变为顺时针。它正是我们打算剔除（丢弃）的不可见的面！ &emsp;&emsp;也就是说，我们使用顶点的环绕顺序来判断面向，当我们定义逆时针顺序的三角形时候，以摄像机面向而言，我们所观察到的逆时针方向的三角形为正面，顺时针为反面，反面则被弃掉。 &emsp;&emsp;当然，OpenGL 仍然给我们提供了修改默认面向的方法： 1glFrontFace(GL_CCW); &emsp;&emsp;默认值是GL_CCW，它代表的是逆时针的环绕顺序，另一个选项是GL_CW，它（显然）代表的是顺时针顺序。 &emsp;&emsp;这样，我们可以设置面向的判断顺序（顺时针环绕顺序还是逆时针环绕顺序），设置抛弃的面向（正面还是反面）。启动面剔除后就可以将想剔除的面抛弃掉。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】15-混合]]></title>
    <url>%2F2018%2F03%2F07%2F%E3%80%90OpenGL%E3%80%9115-%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】混合 【英文版】Blending 学习记录 &emsp;&emsp;OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。 &emsp;&emsp;在现实生活中，我们有完全透明的玻璃，也有带色彩半透明的玻璃。在透过完全透明玻璃看东西的时候，我们看到的是物体的原本色彩，而在透过有色玻璃看东西的时候，我们看到的就成了玻璃的颜色和物体本身颜色混合后的色彩。 &emsp;&emsp;如上图所示，当我们透过红色的半透明玻璃看物体时候，看到的便是混合后的颜色。 &emsp;&emsp;透明的物体可以是完全透明的（让所有的颜色穿过），或者是半透明的（它让颜色通过，同时也会显示自身的颜色）。一个物体的透明度是通过它颜色的aplha值来决定的。Alpha颜色值是颜色向量的第四个分量，你可能已经看到过它很多遍了。在这个教程之前我们都将这个第四个分量设置为1.0，让这个物体的透明度为0.0，而当alpha值为0.0时物体将会是完全透明的。当alpha值为0.5时，物体的颜色有50%是来自物体自身的颜色，50%来自背后物体的颜色。 &emsp;&emsp;我们目前一直使用的纹理有三个颜色分量：红、绿、蓝。但一些材质会有一个内嵌的alpha通道，对每个纹素(Texel)都包含了一个alpha值。这个alpha值精确地告诉我们纹理各个部分的透明度。比如说，下面这个窗户纹理中的玻璃部分的alpha值为0.25（它在一般情况下是完全的红色，但由于它有75%的透明度，能让很大一部分的网站背景颜色穿过，让它看起来不那么红了），边框的alpha值是0.0。 &emsp;&emsp;首先实现比较简单的要么全透明要么全不透明的纹理透明度，使用小草的纹理图片为例（我们总是需要在地面上绘制很多草丛，然而为了效率我们又不能像是渲染模型一样费大力气去构建他的模型以及渲染他，所以使用一张带有草丛的纹理图片）： &emsp;&emsp;可能你会觉得，既然是一张除了草丛其他部位都是透明的纹理贴图，那么直接渲染上去就可以了吧。然而如果我们不自己进行处理，OpenGL 并不能很好的去完成它。比如我们直接渲染纹理： 1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); &emsp;&emsp;请注意和我们之前调用不同的地方在于我们使用了 GL_RGBA 而不是 GL_RGB。 1234void main()&#123; FragColor = texture(texture1, TexCoords);&#125; &emsp;&emsp;由于我们纹理贴图传进来的是 rgba vec4数据，所以倒不用去特意转换为 vec4。在各个地方渲染了几个草丛后如下： &emsp;&emsp;这样我们就可以看到草丛纹理的别扭之处了，我们没有对草丛进行处理，虽然纹理图片本身是透明的，但是默认下并没有进行处理，所以我们看到的是白色底。所以我们需要对纹理进行设置： 123456...vec4 texColor = texture(texture1, TexCoords); if(texColor.a &lt; 0.1) discard; FragColor = texColor;... &emsp;&emsp;在片段着色器中，我们读取这个纹理渲染单元的 a 属性（透明度），当期超过一个阈值时我们认为他是完全透明的，所以做 discard （丢弃）操作。最终效果如下： &emsp;&emsp;注意，当采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE： 12glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); &emsp;&emsp;是不是看起来问题不大了。这是看起来很简单的要么渲染要么抛弃问题，实现起来也是比较简单，下来我们将看看透过那些半透明的物体（有色玻璃）看东西时候的颜色是如何渲染的。 &emsp;&emsp;首先要启动混合，我们需要调用 glEnable(GL_BLEND); 来启动混合功能，而且需要设置 glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 方法。以下是参数说明： GL_FUNC_ADD：默认选项，将两个分量相加：result=Src+Dst GL_FUNC_SUBTRACT：将两个分量相减： result=Src−Dst GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：result=Dst−Src &emsp;&emsp;OpenGL中的混合规则请看这里：OpenGL超级宝典笔记——混合 &emsp;&emsp;我们在启用且设置混合参数后，效果如下： 12glEnable(GL_BLEND);glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); &emsp;&emsp;可以看到我们已经实现了部分混合，可是却出现了遮挡问题，即最前边的窗口遮挡了后边的内容。这是因为我们的渲染顺序不对而造成的。 &emsp;&emsp;发生这一现象的原因是，深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。 &emsp;&emsp;所以我们不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题了。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，我们需要首先绘制背后的这部分窗户。这也就是说在绘制的时候，我们必须先手动将窗户按照最远到最近来排序，再按照顺序渲染。 &emsp;&emsp;要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下： 先绘制所有不透明的物体。 对所有透明的物体排序。 按顺序绘制所有透明的物体。 &emsp;&emsp;排序透明物体的一种方法是，从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得。接下来我们把距离和它对应的位置向量存储到一个STL库的map数据结构中。map会自动根据键值(Key)对它的值排序，所以只要我们添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum-Distance-Between-BST-Nodes]]></title>
    <url>%2F2018%2F03%2F07%2FMinimum-Distance-Between-BST-Nodes%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#783 Minimum Distance Between BST Nodes 题目描述&emsp;&emsp;Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : 1234567891011121314Input: root = [4,2,6,1,3,null,null]Output: 1Explanation:Note that root is a TreeNode object, not an array.The given tree [4,2,6,1,3,null,null] is represented by the following diagram: 4 / \ 2 6 / \ 1 3 while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2. Note: The size of the BST will be between 2 and 100. The BST is always valid, each node’s value is an integer, and each node’s value is different. 解题思路&emsp;&emsp;刚开始想复杂了。。 &emsp;&emsp;直接将树的所有节点值存入数组并排序，然后找到相差最小的数字返回其差值。 解题代码【.CPP】1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; void getValuse(TreeNode* root , vector&lt;int&gt;&amp; values )&#123; if(!root) return; values.push_back(root-&gt;val); getValuse(root-&gt;left,values); getValuse(root-&gt;right,values); &#125;public: int minDiffInBST(TreeNode* root) &#123; vector&lt;int&gt; values(0); getValuse(root , values); sort(values.begin() , values.end()); int ret = INT_MAX; for (int i = 1; i &lt; values.size(); ++i) &#123; ret = min(ret , values[i] - values[i-1]); &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】14-深度测试与模板测试]]></title>
    <url>%2F2018%2F03%2F06%2F%E3%80%90OpenGL%E3%80%9114-%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】深度测试 模板测试 【英文版】Depth testing Stencil testing 学习心得&emsp;&emsp;在我们之前所实现的代码中，总是使用了 3D 图形，包括我们所导入的模型以及之前一直在使用的正立方体。以正方体为例，这是一个对称的结构，总是有一部分内容在一部分之后使得我们不可见。由于计算机屏幕坐标系本身是一个二维的面，我们必须在这上边模拟出 3D 的效果。而遮挡效果也是必须要实现的，在这里需要介绍一个概念：深度缓冲 。 &emsp;&emsp;在计算机图形学中，深度缓冲是在三维图形中处理图像深度坐标的过程，这个过程通常在硬件中完成，它也可以在软件中完成，它是可见性问题的一个解决方法。可见性问题是确定渲染场景中哪部分可见、哪部分不可见的问题。画家算法是另外一种常用的方法，尽管效率较低，但是也可以处理透明场景元素。深度缓冲也称为Z缓冲。 &emsp;&emsp;当三维图形卡渲染物体的时候，每一个所生成的像素的深度（即z坐标）就保存在一个缓冲区中。这个缓冲区叫作z缓冲区或者深度缓冲区，这个缓冲区通常组织成一个保存每个屏幕像素深度的x-y二维数组。如果场景中的另外一个物体也在同一个像素生成渲染结果，那么图形处理卡就会比较二者的深度，并且保留距离观察者较近的物体。然后这个所保留的物体点深度保存到深度缓冲区中。最后，图形卡就可以根据深度缓冲区正确地生成通常的深度感知效果：较近的物体遮挡较远的物体。这个过程叫作z消隐。 &emsp;&emsp;OpenGL 中提供了一个深度测试，用来判断有重合区域的两部分，深度较高的（较远）的那部分将被抛弃不予以渲染。启动深度测试方法如下（默认禁用）： 1glEnable(GL_DEPTH_TEST); &emsp;&emsp;当它启用的时候，如果一个片段通过了深度测试的话，OpenGL会在深度缓冲中储存该片段的z值；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT 来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值： 1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); &emsp;&emsp;可以想象，在某些情况下我们会需要对所有片段都执行深度测试并丢弃相应的片段，但不希望更新深度缓冲。基本上来说，在使用一个只读的(Read-only)深度缓冲。OpenGL允许我们禁用深度缓冲的写入，只需要设置它的深度掩码(Depth Mask)设置为GL_FALSE就可以了： 1glDepthMask(GL_FALSE); &emsp;&emsp;在启动深度测试时，我们也可以设置深度测试的模式，使用 glDepthFunc() 方法，参数可以设置如下（默认为 GL_LESS）： 函数 描述 GL_ALWAYS 永远通过深度测试 GL_NEVER 永远不通过深度测试 GL_LESS 在片段深度值小于缓冲的深度值时通过测试 GL_EQUAL 在片段深度值等于缓冲区的深度值时通过测试 GL_LEQUAL 在片段深度值小于等于缓冲区的深度值时通过测试 GL_GREATER 在片段深度值大于缓冲区的深度值时通过测试 GL_NOTEQUAL 在片段深度值不等于缓冲区的深度值时通过测试 GL_GEQUAL 在片段深度值大于等于缓冲区的深度值时通过测试 &emsp;&emsp;除了深度测试，还有一个模板测试 ： &emsp;&emsp;图形卡控制屏幕的方法是在图形卡的显存中分配一个区域，区域中每一个单元中存储的颜色值和屏幕中相对应点的颜色一一对应，也就是说如果程序修改了显存区域中一个单元中存储的颜色值，也就修改了和这个单元相对应的屏幕点的颜色。这个显存区域一般叫屏幕显示区。 &emsp;&emsp;有时，需要为屏幕显示区的每个单元设置一些标记，在渲染时根据这些标记进行不同的处理，记录这些标记的显存单元集合称作模板缓存区。例如分辨率为1024×768像素的显示器模式，屏幕显示区的单元数应为1024×768，由于屏幕每个像素点都应有一个标记，所以模板缓存区单元数也应为1024×768。模板缓存区的一个单元可以是1位、4位或8位二进制数。 &emsp;&emsp;模板缓存区的一个单元和深度缓存区的一个单元总是共用一个32位二进制数，例如，其中24位为深度缓存区单元，8位为模板缓存区单元。显卡不同，模板缓存区单元和深度缓存区单元在32位二进制数中各允许占用的位数也不同。可以用如下方法查看本计算机使用的显卡中，模板缓存区单元和深度缓存区单元各允许占用多少位数，依序选择“开始”|“程序”|“Microsoft DirectX 9.0 SDK Update|DirectX Utilitites|DirectX Caps Viewer”菜单项，然后打开“DirectX Caps Viewer”窗口，即可看到本机显卡所支持的所有深度/模板缓存区单元模式。例如，模式D24S8表示一个32位二进制数中深度缓存区单元24位，模板缓存区单元8位，模式D24X8表示深度缓存区单元24位，其余8位不使用。 &emsp;&emsp;使用渲染函数渲染3D模型的最后一步是，将投影变换得到的且将在屏幕显示的3D模型的每个像素点的颜色值写入屏幕显示区相应的单元。如果允许模版测试，就在每次写入一个像素点颜色值前，使用设定的模版比较函数进行测试，即对该像素点对应的模板缓冲单元的值和模板参考值进行比较，只有在该点模板函数比较成功时，渲染函数才执行写入。当然，最终是否写入，还要取决于深度测试，否则将保留该像素点在屏幕显示区相应单元原来的颜色值。最后还要根据比较结果，对该模板缓冲单元的值做指定的处理。 &emsp;&emsp;例子如下： &emsp;&emsp;模板测试的启动和控制方法和深度测试类似： 12glEnable(GL_STENCIL_TEST);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); &emsp;&emsp;设置属性也是有具体的方法： &emsp;&emsp;和深度测试一样，我们对模板缓冲应该通过还是失败，以及它应该如何影响模板缓冲，也是有一定控制的。一共有两个函数能够用来配置模板测试：glStencilFunc 和 glStencilOp。 &emsp;&emsp;glStencilFunc(GLenum func, GLint ref, GLuint mask) 一共包含三个参数： func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。 ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。 mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。 &emsp;&emsp;glStencilFunc仅仅描述了OpenGL应该对模板缓冲内容做什么，而不是我们应该如何更新缓冲。这就需要glStencilOp这个函数了。 &emsp;&emsp;glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个选项，我们能够设定每个选项应该采取的行为： sfail：模板测试失败时采取的行为。 dpfail：模板测试通过，但深度测试失败时采取的行为。 dppass：模板测试和深度测试都通过时采取的行为。 &emsp;&emsp;每个选项都可以选用以下的其中一种行为： 行为 描述 GL_KEEP 保持当前储存的模板值 GL_ZERO 将模板值设置为0 GL_REPLACE 将模板值设置为glStencilFunc函数设置的ref值 GL_INCR 如果模板值小于最大值则将模板值加1 GL_INCR_WRAP 与GL_INCR一样，但如果模板值超过了最大值则归零 GL_DECR 如果模板值大于最小值则将模板值减1 GL_DECR_WRAP 与GL_DECR一样，但如果模板值小于0则将其设置为最大值 GL_INVERT 按位翻转当前的模板缓冲值 &emsp;&emsp;默认情况下 glStencilOp 是设置为(GL_KEEP, GL_KEEP, GL_KEEP)的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。 &emsp;&emsp;所以，通过使用 glStencilFunc 和 glStencilOp ，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Split-Linked-List-in-Parts]]></title>
    <url>%2F2018%2F03%2F06%2FSplit-Linked-List-in-Parts%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#725 Split Linked List in Parts 题目描述&emsp;&emsp;Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”. &emsp;&emsp;The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null. &emsp;&emsp;The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later. &emsp;&emsp;Return a List of ListNode’s representing the linked list parts that are formed. &emsp;&emsp;Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ] Example 1: 12345678Input: root = [1, 2, 3], k = 5Output: [[1],[2],[3],[],[]]Explanation:The input and each element of the output are ListNodes, not arrays.For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.The first element output[0] has output[0].val = 1, output[0].next = null.The last element output[4] is null, but it&apos;s string representation as a ListNode is []. Example 2: 12345Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. Note: The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50]. 解题思路&emsp;&emsp;题目要求将链表分割 K 条，并满足当链表长度 Len % K == N 的时候，则前 N 条子链的长度为 Len / K + 1，其他的长度为 Len / K。当某一个子链长度为0时，数组里存 NULL 。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123; int sLength = 0; ListNode* tmp = root; while (tmp) &#123; sLength++; tmp = tmp-&gt;next; &#125; int eLen = sLength / k; int eRem = sLength % k; tmp = root; vector&lt;ListNode*&gt; ret(0); for (int i = 0; i &lt; k; ++i) &#123; if(tmp)&#123; if(eLen &gt; 0)&#123; auto eRoot = tmp; auto eTmp = eRoot; tmp = tmp-&gt;next; for (int j = 1; j &lt; eLen; ++j) &#123; eTmp-&gt;next = tmp; tmp = tmp-&gt;next; eTmp = eTmp-&gt;next; &#125; if(eRem &gt; 0)&#123; eTmp-&gt;next = tmp; eTmp = eTmp-&gt;next; tmp = tmp-&gt;next; eRem--; &#125; eTmp-&gt;next = nullptr; ret.push_back(eRoot); &#125; else &#123; if(eRem &gt; 0)&#123; auto eTmp = tmp; tmp = tmp-&gt;next; eTmp-&gt;next = nullptr; eRem--; ret.push_back(eTmp); &#125; &#125; &#125; else &#123; ret.push_back(0); &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Couples-Holding-Hands]]></title>
    <url>%2F2018%2F03%2F05%2FCouples-Holding-Hands%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#765 Couples Holding Hands 题目描述&emsp;&emsp;N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats. &emsp;&emsp;The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1). &emsp;&emsp;The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat. Example 1: 123Input: row = [0, 2, 1, 3]Output: 1Explanation: We only need to swap the second (row[1]) and third (row[2]) person. Example 2: 123Input: row = [3, 2, 0, 1]Output: 0Explanation: All couples are already seated side by side. Note: len(row) is even and in the range of [4, 60]. row is guaranteed to be a permutation of 0...len(row)-1. 解题思路&emsp;&emsp;直接遍历，当碰到不是情侣的时候（即不满足 x , x+1 且 x % 2 == 0），就在数组里查找的满足的值直接与当前进行替换。即解决一对是一对的政策。（话说我一个单身狗为什么要考虑帮他们做这个） 解题代码1234567891011121314151617181920class Solution &#123;public: int minSwapsCouples(vector&lt;int&gt; &amp;row) &#123; int ret = 0; for (int i = 0; i &lt; row.size() - 1; i += 2) &#123; if ((row[i] % 2 == 0 &amp;&amp; row[i] + 1 != row[i+1]) || (row[i] % 2 == 1 &amp;&amp; row[i] - 1 != row[i+1])) &#123; for (int j = i + 2; j &lt; row.size(); ++j) &#123; if ((row[i] % 2 == 0 &amp;&amp; row[i] + 1 == row[j]) || (row[i] % 2 == 1 &amp;&amp; row[i] - 1 == row[j])) &#123; swap(row[i + 1], row[j]); ret++; break; &#125; &#125; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】13-Mesh与Model类]]></title>
    <url>%2F2018%2F03%2F05%2F%E3%80%90OpenGL%E3%80%9113-Mesh%E4%B8%8EModel%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在上一篇文章中我们了解了 Assimp 这个库，但是只知道这个库只是作为一个加载的作用，并不清楚如何使用，这这一篇便是介绍 Assimp 的数据结构以及我们自己创建的两个为方便使用它而创建的类。 &emsp;&emsp;首先看一下 Assimp 的结构图： &emsp;&emsp;Assimp 读取模型文件后，会将其加载到一套通用的数据结构中，如上图所示，首先是一个 Scene 对象，对象中包括了多个场景对象，各个对象以树状结构展开，而 Scene 中储存了根节点 mRootNode。mMeshes 和 mMatertials 则是存储了模型的 Mesh（网格：代表一个可绘制的实体）与 Material（材质）数据，每一个 Children（子节点） 包括了它的孩子节点集合和网格（Mesh）索引集合，注意 Child Node 中的 Mesh 集合中存储的是 Scene 对象里的 Mesh 数组的索引，也就是说具体数据是在 Scene 中存储的，这里只有索引。 &emsp;&emsp;除了 Scene 对象之外，便是代表具体网格数据的 Mesh 对象了，Mesh 对象存储了网格的顶点位置（mVertices）、法向量（mNormals）、纹理坐标（mTetureCoords）、面(mFaces)和物体的材质索引（mMaterialIndex），材质数据则是在在 Scene 对象的 mMaterials[] 中存储。 &emsp;&emsp;在了解了 Assimp 的通用数据结构后，我们就可以从 Scene 对象中接收数据了。首先构造一个我们自己的 Mesh 类，用来直接进行 Mesh 的绘制工作。在此之前仍需要定义好两个东西，Vertex 与 Texture 。 12345678910111213141516171819202122232425262728struct Vertex &#123; glm::vec3 Position; glm::vec3 Normal; glm::vec2 TextCoords; //U V glm::vec3 Tangent; glm::vec3 Bitangent;&#125;;struct Texture &#123; unsigned int id; std::string type; std::string path;&#125;;class Mesh &#123;public: /*网格数据*/ std::vector&lt;Vertex&gt; vertices; std::vector&lt;unsigned int&gt; indices; std::vector&lt;Texture&gt; textures; /*方法*/ Mesh(std::vector&lt;Vertex&gt; vertices , std::vector&lt;unsigned int&gt; indices , std::vector&lt;Texture&gt; textures); void Draw(Shader shader);private: unsigned int VAO; unsigned int VBO , EBO; void setupMesh();&#125;; &emsp;&emsp;我们定义了公开的包括顶点 Vertex（顶点中定义了位置，法线等等），索引以及纹理，同时留下了构造方法以及 Draw 绘制接口 。而 Private 则是定义了我们在构造或者绘制过程中需要做的一些事。以下来看具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Mesh::Mesh(std::vector&lt;Vertex&gt; vertices, std::vector&lt;unsigned int&gt; indices, std::vector&lt;Texture&gt; textures) &#123; this-&gt;vertices = vertices; this-&gt;indices = indices; this-&gt;textures = textures; setupMesh();&#125;void Mesh::setupMesh() &#123; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); glBindVertexArray(VAO); //VBO glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &amp;vertices[0], GL_STATIC_DRAW); //EBO glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &amp;indices[0], GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *) 0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex,Normal)); glEnableVertexAttribArray(2); glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex,TextCoords)); glEnableVertexAttribArray(3); glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent)); glEnableVertexAttribArray(4); glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Bitangent)); glBindVertexArray(0);&#125;void Mesh::Draw(Shader shader) &#123; unsigned int diffuseNr = 1; unsigned int specularNr = 1; unsigned int normalNr = 1; unsigned int heightNr = 1; for(unsigned int i = 0; i &lt; textures.size(); i++) &#123; glActiveTexture(GL_TEXTURE0 + i); // active proper texture unit before binding // retrieve texture number (the N in diffuse_textureN) std::string number; std::string name = textures[i].type; if(name == "texture_diffuse") number = std::to_string(diffuseNr++); else if(name == "texture_specular") number = std::to_string(specularNr++); // transfer unsigned int to stream else if(name == "texture_normal") number = std::to_string(normalNr++); // transfer unsigned int to stream else if(name == "texture_height") number = std::to_string(heightNr++); // transfer unsigned int to stream // now set the sampler to the correct texture unit glUniform1i(glGetUniformLocation(shader.ID, (name + number).c_str()), i); // and finally bind the texture glBindTexture(GL_TEXTURE_2D, textures[i].id); &#125; // draw mesh glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); glBindVertexArray(0); // always good practice to set everything back to defaults once configured. glActiveTexture(GL_TEXTURE0);&#125; &emsp;&emsp;实现的内容没有多少难度，Mesh 的构造中就是复制以及我们之前学过的绑定顶点对象以及填充数据等， Draw 方法传入一个 Shader（着色器对象），并读取纹理贴图后为 Shader 对象的属性赋值以及绘制等。 &emsp;&emsp;暂时明白了 Mesh 的实现，接下来看看将 Scene 解析并将所有 Mesh 绘制的 Model 类： 123456789101112131415161718192021222324class Model &#123;public: Model(char *path , bool gamma = false); void Darw(Shader shader); std::vector&lt;Mesh&gt; meshes;private: bool gammaCorrection; std::string directory; std::vector&lt;Texture&gt; textures_loaded; void loadModel(std::string path); void processNode(aiNode *node, const aiScene *scene); Mesh processMesh(aiMesh *mesh, const aiScene *scene); std::vector&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, std::string typeName);&#125;; &emsp;&emsp;Mesh 中已经完成了对网格的操作，而在 Model 中我们的重点仅仅是将 Scene 的属性按照数据结构解析并赋给 Mesh 而已，我们留下了构造方法已经绘制函数，绘制函数很简单，就是遍历 meshes 数组，挨个调用 mesh 对象的 draw 方法就可以了。 12345void Model::Darw(Shader shader) &#123; for (auto &amp;meshe : meshes) &#123; meshe.Draw(shader); &#125;&#125; &emsp;&emsp;而构造方法则是层层调用解析函数，最外层是 loadModel 方法，在 loadModel 里使用 Assimp 读取 obj 文件以及贴图文件的文件夹地址，然后调用解析节点方法（processNode）： 1234567891011121314151617Model::Model(char *path, bool gamma) : gammaCorrection(gamma) &#123; loadModel(path);&#125;void Model::loadModel(std::string path) &#123; Assimp::Importer importer; const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace); //翻转UV坐标 if (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) &#123; std::cout &lt;&lt; "ERROR::ASSIMP::" &lt;&lt; importer.GetErrorString() &lt;&lt; std::endl; return; &#125; directory = path.substr(0, path.find_last_of('/')); processNode(scene-&gt;mRootNode, scene);&#125; &emsp;&emsp;我们之前说了，每个节点中存放的是 Mesh 在 Scene 对象里的数组的索引和子节点，所以 processNode 的实现则是依据索引解析 Mesh 对象并将其保存到 Model 的 meshes 数组里，同时递归子节点。 123456789101112void Model::processNode(aiNode *node, const aiScene *scene) &#123; for (unsigned int i = 0; i &lt; node-&gt;mNumMeshes; ++i) &#123; aiMesh *mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; meshes.push_back(processMesh(mesh, scene)); &#125; for (unsigned int i = 0; i &lt; node-&gt;mNumChildren; ++i) &#123; processNode(node-&gt;mChildren[i], scene); &#125;&#125; &emsp;&emsp;解析 Mesh 对象则是使用了 processMesh 方法，里边的内容也不难考虑，即将 assimp 的 Mesh 里存放的数据挨个转移到我们自定义的 Mesh 类对象里，包括顶点数据 Vertex 对象以及材质 Texture 对象，而 assimp 的Mesh 类只有材质的索引属性，所以需要我们调用读取材质的方法（loadMaterialTextures）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Mesh Model::processMesh(aiMesh *mesh, const aiScene *scene) &#123; std::vector&lt;Vertex&gt; vertices; std::vector&lt;unsigned int&gt; indices; std::vector&lt;Texture&gt; textures; //Vertex for (unsigned int i = 0; i &lt; mesh-&gt;mNumVertices; ++i) &#123; Vertex vertex; vertex.Position = glm::vec3(mesh-&gt;mVertices[i].x, mesh-&gt;mVertices[i].y, mesh-&gt;mVertices[i].z); vertex.Normal = glm::vec3(mesh-&gt;mNormals[i].x, mesh-&gt;mNormals[i].y, mesh-&gt;mNormals[i].z); if (mesh-&gt;mTextureCoords[0]) &#123; vertex.TextCoords = glm::vec2(mesh-&gt;mTextureCoords[0][i].x, mesh-&gt;mTextureCoords[0][i].y); &#125; else &#123; vertex.TextCoords = glm::vec2(0.0f, 0.0f); &#125; if(mesh-&gt;mTangents)&#123; vertex.Tangent = glm::vec3(mesh-&gt;mTangents[i].x, mesh-&gt;mTangents[i].y, mesh-&gt;mTangents[i].z); &#125; if(mesh-&gt;mBitangents)&#123; vertex.Bitangent = glm::vec3(mesh-&gt;mBitangents[i].x, mesh-&gt;mBitangents[i].y, mesh-&gt;mBitangents[i].z); &#125; vertices.push_back(vertex); &#125; //Indices for (unsigned int i = 0; i &lt; mesh-&gt;mNumFaces; ++i) &#123; aiFace face = mesh-&gt;mFaces[i]; for (unsigned int j = 0; j &lt; face.mNumIndices; ++j) &#123; indices.push_back(face.mIndices[j]); &#125; &#125; //Textures aiMaterial *material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex]; std::vector&lt;Texture&gt; diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, "texture_diffuse"); textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end()); std::vector&lt;Texture&gt; specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, "texture_specular"); textures.insert(textures.end(), specularMaps.begin(), specularMaps.end()); std::vector&lt;Texture&gt; normalMaps = loadMaterialTextures(material, aiTextureType_NORMALS ,"texture_normal"); textures.insert(textures.end(), normalMaps.begin(), normalMaps.end()); std::vector&lt;Texture&gt; heightMaps = loadMaterialTextures(material, aiTextureType_HEIGHT, "texture_height"); textures.insert(textures.end(), heightMaps.begin(), heightMaps.end()); return Mesh(vertices, indices, textures);&#125; &emsp;&emsp;除此之外还有从 scene 对象里读取材质以及从文件里读取贴图的两个方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162std::vector&lt;Texture&gt; Model::loadMaterialTextures(aiMaterial *mat, aiTextureType type, std::string typeName) &#123; std::vector&lt;Texture&gt; textures; for (unsigned int i = 0; i &lt; mat-&gt;GetTextureCount(type); i++) &#123; aiString str; mat-&gt;GetTexture(type, i, &amp;str); // check if texture was loaded before and if so, continue to next iteration: skip loading a new texture bool skip = false; for (auto &amp;j : textures_loaded) &#123; if (std::strcmp(j.path.data(), str.C_Str()) == 0) &#123; textures.push_back(j); skip = true; // a texture with the same filepath has already been loaded, continue to next one. (optimization) break; &#125; &#125; if (!skip) &#123; // if texture hasn't been loaded already, load it Texture texture; texture.id = TextureFromFile(str.C_Str(), this-&gt;directory); texture.type = typeName; texture.path = str.C_Str(); textures.push_back(texture); textures_loaded.push_back(texture); // store it as texture loaded for entire model, to ensure we won't unnecesery load duplicate textures. &#125; &#125; return textures;&#125;unsigned int TextureFromFile(const char *path, const std::string &amp;directory, bool gamma) &#123; std::string filename = std::string(path); filename = directory + '/' + filename; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(filename.c_str(), &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; "Texture failed to load at path: " &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】12-模型与Assimp库]]></title>
    <url>%2F2018%2F03%2F04%2F%E3%80%90OpenGL%E3%80%9112-%E6%A8%A1%E5%9E%8B%E4%B8%8EAssimp%E5%BA%93%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】Assimp 网格 模型 【英文版】Assimp Mesh Model 学习心得&emsp;&emsp;在之前我们一直使用正方体作为模型，现在终于可以接触别的了。在我们所玩的游戏，或者我们现实中所接触的东西，大都是不规则形状的，很难去简单的用几个三角形构成，这也是我们这一篇介绍的重点。 &emsp;&emsp;首先需要了解一下 Assimp ，以下是维基百科介绍（并没有找到中文的）： Open Asset Import LibraryFrom Wikipedia, the free encyclopedia Developer(s) Alexander GesslerThomas SchulzeKim Kulling, et al. Stable release 4.1.0 / December 11, 2017; 2 months ago Repository) https://github.com/assimp/assimp Operating system Cross-platform Type 3D model import library) License BSD Website www.assimp.org Open Asset Import Library (Assimp) is a cross-platform 3D model import library which aims to provide a common application programming interface (API) for different 3D asset file formats. Written in C++, it offers interfaces for both C) and C++. Bindings to other languages (e.g., BlitzMax, C#), Python)) are developed as part of the project or are available elsewhere.[1] Given the importance and the benefits of Assimp, a pure Java (/Kotlin) port is being developed here. The imported data is provided in a straightforward, hierarchical data structure. Configurable post processing steps (i.e., normal and tangent generation, various optimizations) augment the feature set.[2] Assimp currently supports 57 different file formats for reading, including COLLADA (.dae), 3DS, DirectX X, Wavefront OBJ and Blender 3D) (.blend).[3] As of Version 3.0 Assimp also provides export functionality for some file formats.[4] See also Free software portal OpenCTM MeshLab References http://assimp.sourceforge.net/main_doc.html&gt; http://assimp.sourceforge.net/main_features_pp.html&gt; http://assimp.sourceforge.net/main_features_formats.html&gt; http://assimp.sourceforge.net/main_features_export.html&gt; &emsp;&emsp;简单来说，这就是一个开源的模型加载库，一套通用的 SDK 。主要用于导入模型 （OBJ），以及将模型处理成我们 OpenGL 中所需要的数据。 &emsp;&emsp;Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至Assimp的通用数据结构中。当Assimp加载完模型之后，我们就能够从Assimp的数据结构中提取我们所需的所有数据了。由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。 &emsp;&emsp;当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个场景(Scene)对象，它会包含导入的模型/场景中的所有数据。Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。Assimp数据结构的（简化）模型如下： 和材质和网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。 场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。 一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。 一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见你好，三角形）。 最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。 &emsp;&emsp;所以，我们需要做的第一件事是将一个物体加载到Scene对象中，遍历节点，获取对应的Mesh对象（我们需要递归搜索每个节点的子节点），并处理每个Mesh对象来获取顶点数据、索引以及它的材质属性。最终的结果是一系列的网格数据，我们会将它们包含在一个Model对象中。 网格 &emsp;&emsp;当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。通常每个模型都由几个子模型/形状组合而成。组合模型的每个单独的形状就叫做一个网格(Mesh)。比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。一个网格是我们在OpenGL中绘制物体所需的最小单位（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。 &emsp;&emsp;在 mac os 下 ，Assimp 的安装比较简单，我们直接使用 brew install assimp 命令即可安装，安装好后可以在 /usr/local/lib 目录下可以找到 libassimp.dylib libassimp.x.dylib libassimp.x.x.x.dylib 三个不同版本的 lib 文件（xxx是版本数字，写者安装的时候是4.0.1）。 &emsp;&emsp;在 windows 下，在 assimp 下载地址 下载源代码，然后使用 CMake 构建对应的 VS 工程，生成 assimp 那个项目得到 .dll 或者 .lib 文件，之后将 include 文件夹和 .lib 文件移到对应的位置就可以了。我们之前配置 glwf 和 glew 时做过类似的事。所以这次简单说明下，按照之前的操作方法就可以了。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbits-in-Forest]]></title>
    <url>%2F2018%2F03%2F04%2FRabbits-in-Forest%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#781 Rabbits in Forest 题目描述&emsp;&emsp;In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. &emsp;&emsp;Return the minimum number of rabbits that could be in the forest. 123456789101112131415Examples:Input: answers = [1, 1, 2]Output: 5Explanation:The two rabbits that answered &quot;1&quot; could both be the same color, say red.The rabbit than answered &quot;2&quot; can&apos;t be red or the answers would be inconsistent.Say the rabbit that answered &quot;2&quot; was blue.Then there should be 2 other blue rabbits in the forest that didn&apos;t answer into the array.The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn&apos;t.Input: answers = [10, 10, 10]Output: 11Input: answers = []Output: 0 Note: answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999]. 解题思路&emsp;&emsp;这道题题目给定一个数组，数组里的每个数字代表着除了他自身之外还有多少个和他一样颜色的兔子，最终求森林里兔子的总量。 &emsp;&emsp;假定给定数组 [2] ，说明已经找到的有一个兔子，且这个兔子告诉我们除了他之外还有两只和他颜色一样的兔子，于是兔子总数为 3 。 &emsp;&emsp;假定给定数组[2，2]，说明已经找到有两只兔子，且这两只兔子告诉我们除了他本身之外还有两只颜色一样的，这两只兔子的回答一样说明这两只也是一样颜色的，所以没有找到的只有一只了。总数还是为3。 &emsp;&emsp;明白了计算方式，我们用 map 统计数组里每种颜色的兔子（回答的数字一样的为一种）的个数，最后用回答的数字加一（加上本身）减去统计的数字，就是没有统计到的这种颜色的兔子个数。 1234567891011121314class Solution &#123;public: int numRabbits(vector&lt;int&gt;&amp; answers) &#123; unordered_map&lt;int , int&gt; rabbitsNumber; for (auto answer : answers) rabbitsNumber[answer]++; int ret = answers.size(); for (auto &amp;answer : rabbitsNumber)&#123; while (answer.second &gt; answer.first + 1) answer.second -= answer.first + 1; ret += answer.first - answer.second + 1; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】FPS模拟-3]]></title>
    <url>%2F2018%2F03%2F03%2F%E3%80%90OpenGL%E3%80%91FPS%E6%A8%A1%E6%8B%9F-3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前两篇种我们简略的实现了基本地图的构造和摄像机的移动，这篇文章主要着重于摄像机的视角移动，和视角移动带来的摄像机移动的几个问题。 &emsp;&emsp;我们之前摄像机的移动是直接对cameraMat（即view矩阵）进行 translate 操作，是直接参照坐标轴实现的，即向前就是想z轴负方向移动，左就是x轴负方向，然而我们需要实现的是向前是向摄像机方向的正前方移动。所以需要修改。 &emsp;&emsp;我们假设的游戏角色是在xz平面上移动的，如果以摄像机前方作为正方向，如何保证当摄像机面向正上方时W键不会使得摄像机飞到天上…等等需要注意的问题。 &emsp;&emsp;在开始写代码之前，我们需要了解一个概念：欧拉角(Euler Angle) &emsp;&emsp;欧拉角(Euler Angle)是表示3D空间中可以表示任何旋转的三个值，由莱昂哈德·欧拉在18世纪提出。有三种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，下面的图片展示了它们的含义： &emsp;&emsp;俯仰角是描述我们如何往上和往下看的角，它在第一张图中表示。第二张图显示了偏航角，偏航角表示我们往左和往右看的大小。滚转角代表我们如何翻滚摄像机。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算3D空间中任何的旋转了。 &emsp;&emsp;在这次的代码中我们将进行类FPS摄像机视角的移动，即对 Pitch 和 Yaw 角的转化。我们需要将这两个角度转换成三维空间里具体的方向向量。 &emsp;&emsp;用一个给定的俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的3D向量。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们以最基本的情况开始： &emsp;&emsp;如果我们把斜边边长定义为1，我们就能知道邻边的长度是cos x/h=cos x/1=cos xcos⁡ x/h=cos⁡ x/1=cos⁡ x，它的对边是sin y/h=sin y/1=sin ysin⁡ y/h=sin⁡ y/1=sin⁡ y。这样我们获得了能够得到x和y方向的长度的公式，它们取决于所给的角度。我们使用它来计算方向向量的元素： &emsp;&emsp;这个三角形看起来和前面的三角形很像，所以如果我们想象自己在xz平面上，正望向y轴，我们可以基于第一个三角形计算长度/y方向的强度(我们往上或往下看多少) &emsp;&emsp;看看我们是否能够为偏航角找到需要的元素： &emsp;&emsp;就像俯仰角一样我们可以看到x元素取决于cos(偏航角)的值，z值同样取决于偏航角的正弦值。把这个加到前面的值中。 &emsp;&emsp;由上边的两个图可得，我们的方向向量的 X 轴坐标取决于 cos(yaw) 和 cos(pitch) ，Y 轴取决于 sin(pitch) ，Z轴取决于 cos(pitch) 和 sin(yaw) 。 &emsp;&emsp;此时我们将之前的代码修改，重构 View 矩阵： 123vec3 cameraPos(0.0f, 5.0f, 20.0f);vec3 cameraFront(0.0f, 0.0f, -20.0f);vec3 cameraUp(0.0f, 1.0f, 0.0f); &emsp;&emsp;定义摄像机坐标 cameraPos ，摄像机朝向 cameraFront 和看的方向 cameraUp 三个向量，对 cameraFront 修改以实现视角的旋转。 &emsp;&emsp;我们首先定义 pitch，yaw 两个变量： 1double pitch = 0.0, yaw = 0.0; &emsp;&emsp;pitch 为绕 X 轴旋转的角，即视角的上下旋转，应该由屏幕坐标系 Y 轴决定， yaw 为绕 Y 轴旋转的角，即视角左右旋转，由屏幕坐标系的 X 轴决定。我们将鼠标在 Y 轴的偏移量作为 pitch 增量， X 轴偏移量作为 yaw 增量。 12pitch += (preY - curPosY) * 0.3; //乘以0.3的原因是降低点旋转速度yaw += (curPosX - preX) * 0.3; &emsp;&emsp;得到了 pitch 和 yaw 值之后，我们便可以直接赋值了，由之前计算的 &emsp;&emsp;我们的方向向量的 X 轴坐标取决于 cos(yaw) 和 cos(pitch) ，Y 轴取决于 sin(pitch) ，Z轴取决于 cos(pitch) 和 sin(yaw) 。 12345cameraFront = normalize( vec3(cos(radians(pitch)) * cos(radians(yaw)), //x sin(radians(pitch)), //y cos(radians(pitch)) * sin(radians(yaw))) //z ); &emsp;&emsp;得到了摄像机方向之后，直接使用 lookAt 方法： 1mat4 View = lookAt(cameraPos, cameraFront + cameraPos, cameraUp); &emsp;&emsp;视角旋转搞定，以下是效果（点击图片进入播放页面）： &emsp;&emsp;视角的旋转成功了，但是带来的问题还没解决，即移动问题，我们需要让前后左右的位移与我们的面向有关而不是固定在坐标轴上。前后的处理比较简单，直接使用 cameraFront （摄像机方向）乘以速度就可以了。 123456789if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)&#123; cameraPos += speed * vec3(cameraFront.x , 0.0f , cameraFront.z);&#125;if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)&#123; cameraPos += -speed * vec3(cameraFront.x, 0.0f, cameraFront.z);&#125; &emsp;&emsp;请注意看，我们没有直接使用 cameraFront 这个向量，而是使用它的 x 值和 z 值重新构造了一个向量，这个又是为何呢？ &emsp;&emsp;在前边我们提出了当摄像机方向向上偏或者向下偏的时候如何处理使得我们的摄像机不会向上或者向下位移的问题，就是在这里解决的，我们忽略了摄像机的方向向量种的 Y 分量。 &emsp;&emsp;左右移动（A ，D）则是向摄像机方向与 Y 轴方向形成的面的法线两边移动，使用 glm::cross 方法求法线方向向量，然后乘以速度即可，同样忽略高度。 123456789if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)&#123; cameraPos += -speed * cross(vec3(cameraFront.x, 0.0f, cameraFront.z), cameraUp);&#125;if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)&#123; cameraPos += speed * cross(vec3(cameraFront.x, 0.0f, cameraFront.z), cameraUp);&#125; &emsp;&emsp;这时，我们基本已经可以实现自由移动了。不过还有一些细节问题。 &emsp;&emsp;首先是旋转，在进行 pitch 角旋转的时候，由于我们向上或者向下看不会看到背后（当 pitch &gt; 90 或者 pitch &lt; -90），所以需要对 pitch 的值进行限制。 1pitch = max(-89.0 , min(89.0, pitch)); //pitch 在-89到89范围内 &emsp;&emsp;还有是鼠标范围，我们将鼠标设置为在窗口循环出现，即可以无限的向一个方向转。 12345678//鼠标在窗口内循环if (curPosX &lt; 0 || curPosX &gt; 1024 || curPosY &lt; 0 || curPosY &gt; 768) &#123; if (curPosX &lt;= 0) curPosX = preX = 1023; if (curPosX &gt;= 1024) curPosX = preX = 1; if (curPosY &lt;= 0) curPosY = preY = 767; if (curPosY &gt;= 768) curPosY = preY = 1; glfwSetCursorPos(window, curPosX, curPosY); &#125; &emsp;&emsp;这样我们可以看到，当鼠标光标从窗口最右边消失后会从最左边再进来，我们依旧可以向右旋转视角。但是这样难免有些不美观，在 FPS 视角的游戏中也没有显示鼠标位置的，所以我们调用 windows api 隐藏鼠标。 12//隐藏鼠标显示ShowCursor(false); &emsp;&emsp;最终效果如下（点击图片进入Youtube查看视频）：]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array-Nesting]]></title>
    <url>%2F2018%2F03%2F03%2FArray-Nesting%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#565 Array Nesting 题目描述&emsp;&emsp;A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below. &emsp;&emsp;Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S. Example 1: 1234567Input: A = [5,4,0,3,1,6,2]Output: 6Explanation: A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.One of the longest S[K]:S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125; Note: N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1]. 解题思路&emsp;&emsp;题目中定义集合S[i]= {A[i], A[A[i]], A[A[A[i]]], … }，即以A[i]开头的满足A[i]，A[A[i]]…最终满足A[A[..A[i]]]=i的一个集合。求从S[0]到S[N-1]种集合大小最大的值。 &emsp;&emsp;刚开始我使用递归直接求从0到N-1每一个集合的大小进行比较，思路可行但是出现时间超限，于是定义了数组isVisted来判定当前值是否访问过，如果访问过说明从这里开始的集合已经被另一个集合包括了（即A[0]=1，那么S[1]一定是S[0]的子集）。 解体代码【.CPP】1234567891011121314151617181920class Solution &#123; int recv(int start , int current , vector&lt;int&gt;&amp; nums , vector&lt;bool&gt;&amp; isVisted)&#123; if(nums[current] == start) return 1; else &#123; isVisted[current] = true; return 1 + recv(start , nums[current] , nums , isVisted); &#125; &#125;public: int arrayNesting(vector&lt;int&gt;&amp; nums) &#123; int ret = 0; vector&lt;bool&gt; isVisted(nums.size() , false); for (int i = 0 ; i &lt; nums.size() ; ++i)&#123; if(!isVisted[i]) ret = max(ret , recv(nums[i] , nums[i] , nums , isVisted)); &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】FPS模拟-2]]></title>
    <url>%2F2018%2F03%2F02%2F%E3%80%90OpenGL%E3%80%91FPS%E6%A8%A1%E6%8B%9F-2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇中我们进行了地图的构造，而这一篇文章中我们将进行任务移动的处理，首先在FPS模拟中，我们所谓的人物其实就是摄像机，即摄像机位移。 &emsp;&emsp;图中可以看到，我们的视角是直视前方的，即与地面平行。在大部分FPS游戏中是以鼠标控制镜头方向，以键盘W，A，S，D控制人物位置，即摄像机位置。 &emsp;&emsp;这个比较简单，我们直接使用OpenGL的键盘操作，判断键位并进行摄像机的位移就可以了。glfwGetKey(window , GLFW_KEY_W) == GLFW_PRESS判断是否有W键按下，然后进行相应的摄像机像Z轴方向平移。 123if(glfwGetKey(window , GLFW_KEY_W) == GLFW_PRESS)&#123; View = View * glm::translate(glm::mat4(1.0f) , vec3(0.0f ,0.0f , 0.1f));&#125; &emsp;&emsp;其他同理： 123456789101112131415if(glfwGetKey(window , GLFW_KEY_W) == GLFW_PRESS)&#123; View = View * glm::translate(glm::mat4(1.0f) , vec3(0.0f ,0.0f , 0.1f));&#125;if(glfwGetKey(window , GLFW_KEY_S) == GLFW_PRESS)&#123; View = View * glm::translate(glm::mat4(1.0f) , vec3(0.0f ,0.0f , -0.1f));&#125;if(glfwGetKey(window , GLFW_KEY_A) == GLFW_PRESS)&#123; View = View * glm::translate(glm::mat4(1.0f) , vec3(0.1f ,0.0f , 0.0f));&#125;if(glfwGetKey(window , GLFW_KEY_D) == GLFW_PRESS)&#123; View = View * glm::translate(glm::mat4(1.0f) , vec3(-0.1f ,0.0f , 0.0f));&#125; &emsp;&emsp;前后左右的位移很简单，但是跳跃就比较麻烦了。跳跃是一个有着明确过程的动作，即跳上来和落下去这两个过程，不是简单将摄像机向上平移。所以当我们点击空格键（大多数FPS游戏中的跳跃键）之后应该进入一个跳跃的状态。而我们的跳跃动作显然不是一帧就能够解决的，所以我们需要将这个动作分散到多个帧去执行。 &emsp;&emsp;首先我们需要两个bool型变量，一个记录当前是否处于跳跃动作状态中，一个记录是否处于上升跳跃状态中（使用上升状态变量是因为我们需要看到明显的从上到下和从下到上的过程）。 &emsp;&emsp;当我们按下空格键时，jumpState置为1，这时候我们进入跳跃状态，判断jumpUp变量，如果为1则摄像机向上平移，当位移达到最高点时将jumpUp变量置0，此时摄像机向下平移。 12345678910111213141516171819202122232425262728293031bool jumpState = false , jumpUp = true;double currentHeight = 0.0f;do&#123; ... if(glfwGetKey(window , GLFW_KEY_SPACE) == GLFW_PRESS)&#123; if(!jumpState)&#123; jumpState = true; currentHeight = 0.01f; &#125; &#125; if(jumpState)&#123; if(currentHeight &lt;= 0.0f)&#123; jumpState = false; jumpUp = true; &#125; else &#123; if(currentHeight &gt;= 2.0f)&#123; jumpUp = false; &#125; if(jumpUp)&#123; currentHeight += 0.1f; View = View * glm::translate(glm::mat4(1.0f) , vec3(0.0f ,-0.1f , 0.0f)); &#125; else &#123; currentHeight -= 0.1f; View = View * glm::translate(glm::mat4(1.0f) , vec3(0.0f ,0.1f , 0.0f)); &#125; &#125; &#125; ...&#125;while(...) ... &emsp;&emsp;以下是最终效果（点击图片进入 Youtube 播放界面）：]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Custom-Sort-String]]></title>
    <url>%2F2018%2F03%2F02%2FCustom-Sort-String%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#791 Custom Sort String 题目描述&emsp;&emsp;S and T are strings composed of lowercase letters. In S, no letter occurs more than once. &emsp;&emsp;S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. &emsp;&emsp;Return any permutation of T (as a string) that satisfies this property. 12345678Example :Input: S = &quot;cba&quot;T = &quot;abcd&quot;Output: &quot;cbad&quot;Explanation: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs. Note: S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only. 解题思路&emsp;&emsp;题目要求对给定串T进行排序，排序规则为凡是在S中出现过的字母都按照S的顺序排序，未出现的随便。由此我们可以先将S保存下来，然后遍历T，如果在S中出现过则放在该在的位置，如果没有则直接添加到后边。 解题代码123456789101112131415161718class Solution &#123;public: string customSortString(string S, string T) &#123; string ret = S; unordered_map&lt;char , int&gt; um; for (auto c : S) um[c]++; for (auto c : T)&#123; auto tmp = find(ret.begin(),ret.end(),c); if (tmp == end(ret)) ret.push_back(c); else &#123; if(um[c] &lt; 1) ret.insert(tmp,c); else um[c]--; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】FPS模拟-1]]></title>
    <url>%2F2018%2F03%2F01%2F%E3%80%90OpenGL%E3%80%91FPS%E6%A8%A1%E6%8B%9F-1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在学习了OpenGL最初步的一些内容，包括三维图形，摄像机，鼠标键盘操作后，不由得有了拿这些东西做个小练习的想法。之后又是自然而然的想到了小时候就开始玩的FPS游戏，FPS（First Person Shooter第一人称射击游戏）是可以对之前学到的东西进行综合利用的练习项目。 &emsp;&emsp;在这个小练习中主要实现FPS视角，包括模型移动（摄像机移动），视野移动（摄像机旋转），地图模拟（几个大方块。。）。今天主要实现地图模拟。 &emsp;&emsp;在之前的学习项目中，主要以一个模型进行贴图等等的操作，而今天则需要实现的是一个CS地图的模拟（忘了叫什么名字了，就是四个大方块那个对枪的小地图）。 &emsp;&emsp;首先我们使用光照那一节的项目作为基础，将其拷贝过来，将旋转的方块模型和光照的模型分别做以下处理： 光源升高且固定，作为全地图光源 模型平铺展开（即对X和Z轴进行放大，且对Y轴进行缩小），作为地面 摄像机放在正前方，并且摄像机平视（即将摄像机目标位置的Y轴与摄像机坐标Y轴相等） 1234567 // Model matrix : an identity matrix (model will be at the origin) glm::mat4 floorModel = glm::mat4(1.0f) * glm::scale(glm::mat4(1.0f), vec3(1000.0f, 0.2f, 1000.0f));// x * 1000 z * 1000 y * 0.2 glm::mat4 lightModel = glm::mat4(1.0f) * glm::translate(glm::mat4(1.0f), vec3(0.0f, 100.0f, 0.0f)) * glm::scale(glm::mat4(1.0f), vec3(0.2f, 0.2f, 0.2f)); &emsp;&emsp;代码中我们将之前的模型矩阵更名为 floorModel ，并将其大小改为 X 1000 ，Y 0.2 ，Z * 1000 。以此作为地图，光源则将其向上平移100。 &emsp;&emsp;修改摄像机参数： 123456// Camera matrixglm::mat4 View = glm::lookAt( glm::vec3(0, 5, 40), glm::vec3(0, 5, 0), glm::vec3(0, 1, 0) // Head is up (set to 0,-1,0 to look upside-down)); &emsp;&emsp;效果如下： &emsp;&emsp;做完这些后，我们需要找出四个大方块，在此我们构建四个Model模型： 123456789101112131415glm::mat4 wall1 = glm::mat4(1.0f) * glm::translate(glm::mat4(1.0f), vec3(-15.0f, 0.0f, 15.0f)) * glm::scale(glm::mat4(1.0f), vec3(20.0f, 40.0f, 20.0f));glm::mat4 wall2 = glm::mat4(1.0f) * glm::translate(glm::mat4(1.0f), vec3(15.0f, 0.0f, 15.0f)) * glm::scale(glm::mat4(1.0f), vec3(20.0f, 40.0f, 20.0f));glm::mat4 wall3 = glm::mat4(1.0f) * glm::translate(glm::mat4(1.0f), vec3(-15.0f, 0.0f, -15.0f)) * glm::scale(glm::mat4(1.0f), vec3(20.0f, 40.0f, 20.0f));glm::mat4 wall4 = glm::mat4(1.0f) * glm::translate(glm::mat4(1.0f), vec3(15.0f, 0.0f, -15.0f)) * glm::scale(glm::mat4(1.0f), vec3(20.0f, 40.0f, 20.0f)); &emsp;&emsp;（其实可以用一个模型进行平移所得，我这里是直接复制的。主要为模拟效果，在之后学习了更多东西后会好好写一个FPS视角。）由代码就可以看出我们的四个模型大小相同，但是位置不一样，并且将其放在了我们的地面上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748glUseProgram(cudeProgram);glUniformMatrix4fv(cudeViewID, 1, GL_FALSE, &amp;View[0][0]);glUniformMatrix4fv(cudeModelID, 1, GL_FALSE, &amp;wall1[0][0]);glUniformMatrix4fv(cudeProjectionID, 1, GL_FALSE, &amp;Projection[0][0]);glUniform3f(glGetUniformLocation(cudeProgram, "viewPos"), 4.0f, 5.0f, 3.0f);glUniform3f(glGetUniformLocation(cudeProgram, "lightPos"), 0.0f, 10.0f, 0.0f);glUniform3f(glGetUniformLocation(cudeProgram, "objectColor"), 1.0f, 0.5f, 0.31f);glUniform3f(glGetUniformLocation(cudeProgram, "lightColor"), 1.0f, 1.0f, 1.0f);glBindVertexArray(cudeVAO);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);glUseProgram(cudeProgram);glUniformMatrix4fv(cudeViewID, 1, GL_FALSE, &amp;View[0][0]);glUniformMatrix4fv(cudeModelID, 1, GL_FALSE, &amp;wall2[0][0]);glUniformMatrix4fv(cudeProjectionID, 1, GL_FALSE, &amp;Projection[0][0]);glUniform3f(glGetUniformLocation(cudeProgram, "viewPos"), 4.0f, 5.0f, 3.0f);glUniform3f(glGetUniformLocation(cudeProgram, "lightPos"), 0.0f, 10.0f, 0.0f);glUniform3f(glGetUniformLocation(cudeProgram, "objectColor"), 1.0f, 0.5f, 0.31f);glUniform3f(glGetUniformLocation(cudeProgram, "lightColor"), 1.0f, 1.0f, 1.0f);glBindVertexArray(cudeVAO);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);glUseProgram(cudeProgram);glUniformMatrix4fv(cudeViewID, 1, GL_FALSE, &amp;View[0][0]);glUniformMatrix4fv(cudeModelID, 1, GL_FALSE, &amp;wall3[0][0]);glUniformMatrix4fv(cudeProjectionID, 1, GL_FALSE, &amp;Projection[0][0]);glUniform3f(glGetUniformLocation(cudeProgram, "viewPos"), 4.0f, 5.0f, 3.0f);glUniform3f(glGetUniformLocation(cudeProgram, "lightPos"), 0.0f, 10.0f, 0.0f);glUniform3f(glGetUniformLocation(cudeProgram, "objectColor"), 1.0f, 0.5f, 0.31f);glUniform3f(glGetUniformLocation(cudeProgram, "lightColor"), 1.0f, 1.0f, 1.0f);glBindVertexArray(cudeVAO);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);glUseProgram(cudeProgram);glUniformMatrix4fv(cudeViewID, 1, GL_FALSE, &amp;View[0][0]);glUniformMatrix4fv(cudeModelID, 1, GL_FALSE, &amp;wall4[0][0]);glUniformMatrix4fv(cudeProjectionID, 1, GL_FALSE, &amp;Projection[0][0]);glUniform3f(glGetUniformLocation(cudeProgram, "viewPos"), 4.0f, 5.0f, 3.0f);glUniform3f(glGetUniformLocation(cudeProgram, "lightPos"), 0.0f, 10.0f, 0.0f);glUniform3f(glGetUniformLocation(cudeProgram, "objectColor"), 1.0f, 0.5f, 0.31f);glUniform3f(glGetUniformLocation(cudeProgram, "lightColor"), 1.0f, 1.0f, 1.0f);glBindVertexArray(cudeVAO);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0); &emsp;&emsp;（不要在意这些相当于复制粘贴的代码）在这里我们将四个方块画了下来。 &emsp;&emsp;如此，我们大概的地图模型算是成功了。 &emsp;&emsp;下一篇中将实现人物的前后左右走动以及跳跃（摄像机的前后左右走动以及跳跃）。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rotated-Digits【好久没写代码了】]]></title>
    <url>%2F2018%2F03%2F01%2FRotated-Digits%E3%80%90%E5%A5%BD%E4%B9%85%E6%B2%A1%E5%86%99%E4%BB%A3%E7%A0%81%E4%BA%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#788 Rotated Digits 题目描述&emsp;&emsp;X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number. &emsp;&emsp;Now given a positive number N, how many numbers X from 1 to N are good? 123456Example:Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. Note: N will be in range [1, 10000]. 解题思路&emsp;&emsp;这道题要求找出从1到N中满足数字能够旋转180°且会变成另外一个有意义数字的数字的个数。 &emsp;&emsp;1. 能够旋转180° &emsp;&emsp;2. 旋转后与当前数字不相等 &emsp;&emsp;我们观察得知，要满足能够旋转180°，那么数字中每一位都满足为可以旋转为另一个数字，即1，2，5，6，8，9，0，要满足旋转后与当前数字不相等则需要满足至少有一位数字属于2，5，6，9中的一个。即满足存在某一位的数字属于2，5，6，9且不能出现3，4，7。 解题代码【.CPP】12345678910111213141516171819202122232425class Solution &#123; bool judge(int i) &#123; bool isHaving = false; bool isNotHaving = true; while (i &gt; 0) &#123; int j = i % 10; if(!isHaving &amp;&amp; (j == 2 || j == 5 || j == 6 || j == 9)) isHaving = true; if(isNotHaving &amp;&amp; (j == 3 || j == 4 || j == 7)) isNotHaving = false; i = i / 10; &#125; return isHaving &amp;&amp; isNotHaving; &#125;public: int rotatedDigits(int N) &#123; int ret = 0; for (int i = 2; i &lt;= N; ++i) &#123; ret += judge(i); &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】11-光照]]></title>
    <url>%2F2018%2F02%2F21%2F%E3%80%90OpenGL%E3%80%9111-%E5%85%89%E7%85%A7%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】基础光照 【英文版】Basic Lighting 学习心得&emsp;&emsp;终于是开始接触一些较为复杂的东西了，这篇主要是讲解光照实现的原理（漫反射光和镜面光）以及他们的计算方式。 &emsp;&emsp;首先，我们需要作出一个适合检测光照的模型，在此我实现了一个有着自转与公转的光源——正方体模型，最终效果如下： &emsp;&emsp;点此去Youtube观看 &emsp;&emsp;今天我们需要实现的是漫反射光，和镜面反射光。漫反射光是什么呢，首先我们需要介绍这几个概念，环境光，漫反射光，镜面反射光。 &emsp;&emsp;环境光，我们生活中很少有完全漆黑的时候，大部分情况下我们都可以模糊的看到物体，这个时候我们没有明确的光源，我们称之为环境光。在环境光下，我们只是能够勉强的看到物体，但并不是很清楚，例如： &emsp;&emsp;忽略掉那个没有产生作用的光源，我们可以模糊的看到一坨东西，但是并不能很清楚的看到颜色（因为我注释了光源生效的代码）。 &emsp;&emsp;当漫发射光生效后，我们已经可以清楚的看到物体，以及辨别他的颜色（请注意，不管我们能否看到，物体是存在颜色的）： &emsp;&emsp;那么漫反射到底是什么呢，当一束光照到一个物体上时，因为物体本身颜色决定了他能吸收某个色的光和反射某个的光，同时我们就可以看到他的颜色。而漫反射重要的地方在于判断一束光是否照射到一个物体上，在这里我们需要拿出初中物理的两个概念，入射角，法线。 &emsp;&emsp;途中P为法线，A为入射光线，A与P的夹角即是入射角。看到这里想必你已经大概猜出来了，我们用来判断是否光照射到上边的依据就是入射角。当入射角大于90°时，说明光线没有照射到这里。而根据入射角的角度，光的强度也是不一样的。 &emsp;&emsp;明白了原理，我们便可以用OpenGL中Shader提供好的方法来模拟漫反射来对物体进行着色。首先我们需要得到物体的法线，我们在给出正方体坐标的时候一并给出。 12345678910111213141516171819202122232425262728293031323334353637383940414243float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f&#125;; &emsp;&emsp;这个数组中，每六个值为一组，前三个存储坐标，后三个存储法线向量，可以看出由于我们的长方体有六个边，所以总共有六个不同的法线向量。 12345678910// normal attributeglVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void *) (3 * sizeof(float)));glEnableVertexAttribArray(1); &emsp;&emsp;将这些发现向量绑定到顶点数组里，然后可以在顶点着色器中操作， 12345678910...layout (location = 1) in vec3 aNormal;...out vec3 Normal;...void main()&#123; ... Normal = mat3(transpose(inverse(model))) * aNormal; ...&#125; &emsp;&emsp;可以看到，我们将顶点坐标中的法线向量读出来，然后进行通过一个 inverse（矩阵的逆） 操作和 transpose （矩阵的转置）操作得到的三级矩阵与其相乘并传值给片段着色器。而做这多余的操作也是有原因的： &emsp;&emsp;首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，位移不应该影响到法向量。因此，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3×3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4×4矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。 &emsp;&emsp;其次，如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，我们不能用这样的模型矩阵来变换法向量。下面的图展示了应用了不等比缩放的模型矩阵对法向量的影响： &emsp;&emsp;每当我们应用一个不等比缩放时（注意：等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。 &emsp;&emsp;修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵(Normal Matrix)，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。如果你想知道这个矩阵是如何计算出来的，建议去阅读这个文章。 &emsp;&emsp;法线矩阵被定义为「模型矩阵左上角的逆矩阵的转置矩阵」。真是拗口，如果你不明白这是什么意思，别担心，我们还没有讨论逆矩阵(Inverse Matrix)和转置矩阵(Transpose Matrix)。注意，大部分的资源都会将法线矩阵定义为应用到模型-观察矩阵(Model-view Matrix)上的操作，但是由于我们只在世界空间中进行操作（不是在观察空间），我们只使用模型矩阵。 &emsp;&emsp;在顶点着色器中，我们可以使用inverse和transpose函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意我们还要把被处理过的矩阵强制转换为3×3矩阵，来保证它失去了位移属性以及能够乘以vec3的法向量。 &emsp;&emsp;在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个法线矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果你进行了不等比缩放，使用法线矩阵去乘以法向量就是必不可少的了。 &emsp;&emsp;即使是对于着色器来说，逆矩阵也是一个开销比较大的运算，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。用作学习目这样做是可以的，但是对于一个对效率有要求的应用来说，在绘制之前你最好用CPU计算出法线矩阵，然后通过uniform把值传递给着色器（像模型矩阵一样）。 &emsp;&emsp;传给片段着色器之后，我们就获得了最后计算着色的法线，那么还需要计算入射向量，这个也比较简单，通过对片段位置和光源的位置相减就可以获得，而片段位置可以通过模型矩阵与定点坐标相乘获得： 123456789101112...layout(location=0) in vec3 aPos;...uniform mat4 model;out vec3 FragPos;...void main()&#123; .... FragPos = vec3(model * vec4(aPos, 1.0)); ...&#125; &emsp;&emsp;在顶点着色器里完成这些操作并传值给片段着色器，便可以获得入射向量。 &emsp;&emsp;最后，通过 dot 方法得到入射角，并使其不会产生负数（使用max，当dot得到负数时给他赋值0），如下： 1234vec3 norm = normalize(Normal); //单位化vec3 lightDir = normalize(lightPos - FragPos); //单位化float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = diff * lightColor &emsp;&emsp;当计算光照时我们通常不关心一个向量的模长或它的位置，我们只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个十分常见的错误。 &emsp;&emsp;最后我们将漫反射后计算的颜色加上环境光颜色（一般为光源颜色的几十分之一倍，看具体情况）赋值给片段着色器的输出值即可。 1FragColor = vec4((diffuse + 0.1) * lightColor),1.0f); &emsp;&emsp;处理完漫反射后我们可以看看镜面光照，和漫反射光照一样，镜面光照也是依据光的方向向量和物体的法向量来决定的，但是它也依赖于观察方向，例如玩家是从什么方向看着这个片段的。镜面光照是基于光的反射特性。如果我们想象物体表面像一面镜子一样，那么，无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化。你可以从下面的图片看到效果： &emsp;&emsp;我们通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。 &emsp;&emsp;观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。 &emsp;&emsp;我们使用摄像机坐标作为观察者坐标，在片段着色器中设立一个Uniform变量，并在OpenGL代码里将摄像机坐标传入进去 1uniform vec3 viewPos; &emsp;&emsp;定义一个镜面的反射强度，并用片段坐标减去观察点坐标得到我们的视线方向，通过 reflect 方法得到反射向量（传入参数为入射向量和法线向量，注意入射向量的方向是从光源到片段点） 123float specularStrength = 0.5;vec3 viewDir = normalize(viewPos - FragPos);vec3 reflectDir = reflect(FragPos-lightPos, norm); &emsp;&emsp;最后计算镜面分量，并将其与之前的漫反射光分量和环境光分量加起来乘光源颜色，就得到了最后要赋值的片段颜色： 12345float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);vec3 specular = specularStrength * spec * lightColor; vec3 result = (ambient + diffuse + specular) * objectColor; FragColor = vec4(result , 1.0); &emsp;&emsp;最终效果看Youtube]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】10-摄像机]]></title>
    <url>%2F2018%2F02%2F20%2F%E3%80%90OpenGL%E3%80%9110-%E6%91%84%E5%83%8F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】摄像机 【英文版】Camera 学习心得&emsp;&emsp;在开始这一篇之前，我们需要清楚OpenGL中的坐标系规则，OpenGL采用右手坐标系，即伸出右手，让大拇指指向右方，食指向上，剩下手指弯曲90度指向自己，这即是X，Y，Z三轴。 &emsp;&emsp;关于右手坐标系的具体情况可以参考：左右手坐标系 &emsp;&emsp;在我们之前的代码中，有这么一段： 12345glm::mat4 View = glm::lookAt( glm::vec3(0, 0, 5), glm::vec3(0, 0, 0), glm::vec3(0, 1, 0) ); &emsp;&emsp;在这段中我们调用了 glm::lookAt 方法，并给其传入了三个vec3作为参数，那么这个方法到底是怎么操作的呢，首先看看这个方法的介绍： 12345detail::tmat4x4&lt;T&gt; glm::gtc::matrix_transform::lookAt ( detail::tvec3&lt; T &gt; const &amp; eye, detail::tvec3&lt; T &gt; const &amp; center, detail::tvec3&lt; T &gt; const &amp; up ) Build a look at view matrix. &emsp;&emsp;这个方法用来构建一个view矩阵，而我们需要给出的三个vec3分别是摄像机的坐标，摄像机的目标坐标，以及一个Up向量，摄像机的位置坐标和摄像机的观察目标自然不用说，那么这个Up向量又是做什么的呢？ &emsp;&emsp;我们需要一个摄像机区域的 Right 向量表示摄像机空间里的X轴正方向，这个X轴正方向我们可以通过摄像机观察的方向（即摄像机-&gt;观察点的方向）与一个正向上的向量来进行叉乘来获得。 &emsp;&emsp;当我们提供了摄像机坐标，观察点坐标以及一个向上的向量之后， lookAt 方法将为我们创建一个看着给定的观察点的矩阵（glm省去了我们的计算）。 &emsp;&emsp;对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做格拉姆—施密特正交化(Gram-Schmidt Process)。使用这些摄像机向量我们就可以创建一个LookAt矩阵了，它在创建摄像机的时候非常有用。 &emsp;&emsp;现在我们已经大致清楚了摄像机的使用，那么之前我们使用Model进行平移旋转等变换，现在则使用View矩阵的修改实现正方体观察的变换。首先关于平移我们可以通过修改观察点实现，而旋转可以通过修改摄像机的坐标来实现。 &emsp;&emsp;请记住摄像机的变换和模型的变换是相反的，正如汽车向右走，那么坐在车里的我们可以看到路两旁的树在向左走。 1234567891011glm::mat4 Projection = glm::perspective(glm::radians(90.0f), 4.0f / 3.0f, 0.1f, 10.0f);// Camera matrixglm::mat4 View = glm::lookAt( glm::vec3(0,0,5), // Camera is at (0,0,5), in World Space glm::vec3(0,0,0), // and looks at the origin glm::vec3(0,1,0) // Head is up (set to 0,1,0 to look upside-down));// Model matrix : an identity matrix (model will be at the origin)glm::mat4 Model = glm::mat4(1.0f);// Our ModelViewProjection : multiplication of our 3 matricesglm::mat4 MVP = Projection * View * Model; // Remember, matrix multiplication is the other way around &emsp;&emsp;首先看看我们之前的M，V，P三个矩阵的定义（在纹理那篇文章时候的代码），现在我们通过修改 LookAt 中的观察点位置来模拟正方体的移动。 1234567891011121314151617181920float X = 0;int direct = 0;do&#123; if(X &gt; 5.0f || X &lt; -5.0f)&#123; direct = !direct; &#125; if(direct) X += 0.1f; else X -= 0.1f; ... glm::mat4 View = glm::lookAt( glm::vec3(0,0,5), glm::vec3(X,0,0), glm::vec3(0,1,0) ); ... &#125;while(...) &emsp;&emsp;由上边的代码可以看到，我们修改了 LookAt 方法的观察点参数，并让其在 5.0f 到 -5.0f 间交替，使得正方体在可见区域内来回移动。 MD不支持视频，我上传了Youtube，点这里看效果 &emsp;&emsp;接下来我们通过修改摄像机的位置使得摄像机绕着正方体运动，同时摄像机的观察点一直在圆心（0,0,0），这种情况下我们可以模拟看到正方体的转动（其实是摄像机在转，与移动同理）。 &emsp;&emsp;首先计算绕X轴旋转的Z轴坐标，绕Y轴旋转的话那么需要计算X和Z轴的值，我们使用 glfwGetTime() 获得一个变值，然后在X坐标上对其进行 Cos 计算，在Z坐标上对其进行 Sin 计算（绕Y轴旋转，Y轴不变）。 12345glm::mat4 View = glm::lookAt( glm::vec3(5 * cos(glfwGetTime()),0,5 * sin(glfwGetTime())), glm::vec3(0,0,0), glm::vec3(0,1,0) ); &emsp;&emsp;这样，我们可以看到一个以我们观察角度来看是顺时针旋转的正方体（其实是摄像机在逆时针旋转），如果对X 进行 Sin 计算而 Y 进行 Cos 计算的话那么更好相反。 MD不支持视频，我上传了Youtube，点这里看效果]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My-Calendar-III]]></title>
    <url>%2F2018%2F02%2F20%2FMy-Calendar-III%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#732 My Calendar III 题目描述&emsp;&emsp;Implement a MyCalendarThree class to store your events. A new event can always be added. &emsp;&emsp;Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. &emsp;&emsp;A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.) &emsp;&emsp;For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: 12MyCalendarThree cal = new MyCalendarThree();MyCalendarThree.book(start, end) Example 1: 12345678910111213MyCalendarThree();MyCalendarThree.book(10, 20); // returns 1MyCalendarThree.book(50, 60); // returns 1MyCalendarThree.book(10, 40); // returns 2MyCalendarThree.book(5, 15); // returns 3MyCalendarThree.book(5, 10); // returns 3MyCalendarThree.book(25, 55); // returns 3Explanation: The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.The remaining events cause the maximum K-booking to be only a 3-booking.Note that the last event locally causes a 2-booking, but the answer is still 3 becauseeg. [10, 20), [10, 40), and [5, 15) are still triple booked. Note: &emsp;&emsp;The number of calls to MyCalendarThree.book per test case will be at most 400. &emsp;&emsp;In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9]. 解题思路&emsp;&emsp;题目要求实现一个类，类的book方法每次传入一个事件的起始时间和结束时间，然后返回当前所存在的所有事件的最多相交次数，即i时间点上有N个事件发生，求max(N0,N1,N2….Ni)。 &emsp;&emsp;这个精妙的思路是参考网上的，我们构建一个map用来存储时间点和时间点对应的事件个数，每当遇到起始时间，则给起始时间的事件个数加1，给结束时间的事件个数减一，最终求和。 解题代码【.CPP】1234567891011121314151617181920212223class MyCalendarThree &#123;private: map&lt;int, int&gt; freq;public: MyCalendarThree() &#123;&#125; int book(int start, int end) &#123; ++freq[start]; --freq[end]; int cnt = 0, mx = 0; for (auto f : freq) &#123; cnt += f.second; mx = max(mx, cnt); &#125; return mx; &#125;&#125;;/** * Your MyCalendarThree object will be instantiated and called as such: * MyCalendarThree obj = new MyCalendarThree(); * int param_1 = obj.book(start,end); */]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】9-鼠标与键盘]]></title>
    <url>%2F2018%2F02%2F20%2F%E3%80%90OpenGL%E3%80%919-%E9%BC%A0%E6%A0%87%E4%B8%8E%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】第六课：键盘和鼠标 【英文版】Tutorial 6 : Keyboard and Mouse 学习笔记&emsp;&emsp;上一篇文章中我们使用了矩阵运算让正方体实现了平移旋转等操作，不过都是用我们设定好的值进行变换，这一篇中我们将实现使用鼠标API使得正方体在X，Y平面上随鼠标移动，并且使用W，A，S，D和Up，Down，Left，Right等键位控制关于X，Y轴的旋转。 &emsp;&emsp;首先贴出我们使用到的鼠标的API glfwGetCursorPos，glfwSetCursorPos，这两个API的作用通过名字便可以猜出来一个是Get光标位置，一个是Set光标位置，我们需要让正方体跟随鼠标移动，那么肯定需要调用Get方法。 &emsp;&emsp;首先看一下官方的API描述： 1234void glfwGetCursorPos ( GLFWwindow * window, double * xpos, double * ypos ) &emsp;&emsp;This function returns the position of the cursor, in screen coordinates, relative to the upper-left corner of the client area of the specified window. &emsp;&emsp;If the cursor is disabled (with GLFW_CURSOR_DISABLED) then the cursor position is unbounded and limited only by the minimum and maximum values of a double. &emsp;&emsp;The coordinate can be converted to their integer equivalents with the floor function. Casting directly to an integer type works for positive coordinates, but fails for negative ones. &emsp;&emsp;Any or all of the position arguments may be NULL. If an error occurs, all non-NULL position arguments will be set to zero. Parameters [in]windowThe desired window.[out]xposWhere to store the cursor x-coordinate, relative to the left edge of the client area, or NULL.[out]yposWhere to store the cursor y-coordinate, relative to the to top edge of the client area, or NULL. Errors Possible errors include GLFW_NOT_INITIALIZED and GLFW_PLATFORM_ERROR. Thread safety This function must only be called from the main thread. See also Cursor position glfwSetCursorPos &emsp;&emsp;我们使用glfwGetCursorPos可以获得光标的坐标，由于平移操作是相对于上一刻所对应的位置进行计算，所以我们需要保存上一刻的坐标和当前坐标，如下： 123456double preX = width / 2, preY = height / 2;double curX = preX, curY = preY;//do somethingglfwGetCursorPos(window, &amp;curX, &amp;curY);preX = curX;preY = curY; &emsp;&emsp;平移的X，Y参数也修改为 1Model = Model * glm::translate(glm::mat4(), glm::vec3(curX-preX, curY-preY, 0.0f)); &emsp;&emsp;点击运行，发现打开之后立方体消失了，怎么回事？ &emsp;&emsp;其实是因为打开的那一瞬间，我们的鼠标光标一般不会在显示的正中心，又因为一次性平移的幅度太大，所以超出了可显示区域。这种时候，我们需要用glfwSetCursorPos固定光标到最中心，并且修改glm::translate中的X，Y将其缩小到百分之一。如下： 12345678910double preX = width / 2, preY = height / 2;double curX = preX, curY = preY;glfwSetCursorPos(window , curX , curY);do &#123; glfwGetCursorPos(window, &amp;curX, &amp;curY); Model = Model * glm::translate(glm::mat4(), glm::vec3((curX-preX)/100, (curY-preY)/100, 0.0f)); preX = curX; preY = curY; ...&#125; while(...) &emsp;&emsp;Ok，现在启动之后动动鼠标，是不是正方体跟随鼠标移动而移动啦。 &emsp;&emsp;搞定了跟随鼠标平移，那么现在我们需要实现的是使用W，A，S，D或者Up，Down，Left，Right进行旋转。首先需要看一下我们读取键盘的方法glfwGetKey： 123int glfwGetKey ( GLFWwindow * window, int key ) &emsp;&emsp;This function returns the last state reported for the specified key to the specified window. The returned state is one of GLFW_PRESS or GLFW_RELEASE. The higher-level action GLFW_REPEAT is only reported to the key callback. &emsp;&emsp;If the GLFW_STICKY_KEYS input mode is enabled, this function returns GLFW_PRESS the first time you call it for a key that was pressed, even if that key has already been released. &emsp;&emsp;The key functions deal with physical keys, with key tokens named after their use on the standard US keyboard layout. If you want to input text, use the Unicode character callback instead. &emsp;&emsp;The modifier key bit masks are not key tokens and cannot be used with this function. Do not use this function to implement text input. Parameters [in]windowThe desired window.[in]keyThe desired keyboard key. GLFW_KEY_UNKNOWN is not a valid key for this function. Returns One of GLFW_PRESS or GLFW_RELEASE. Errors Possible errors include GLFW_NOT_INITIALIZED and GLFW_INVALID_ENUM. Thread safety This function must only be called from the main thread. See also Key input &emsp;&emsp;这个方法需要我们传一个Window参数和一个键盘标识符，返回是否按键，使用如下： 123if(glfwGetKey(window , GLFW_KEY_UP))&#123; //当按Up键的时候 ... &#125; &emsp;&emsp;现在我们需要按Up键的时候正方体绕X轴逆时针旋转，自然可以这样写： 123if(glfwGetKey(window , GLFW_KEY_UP))&#123; Model = Model * glm::rotate(glm::mat4() , glm::radians(15.0f), glm::vec3(-1.0f, 0.0f, 0.0f)); &#125; &emsp;&emsp;其他几个也类似： 123456789101112131415if(glfwGetKey(window , GLFW_KEY_UP) || glfwGetKey(window , GLFW_KEY_W))&#123; Model = Model * glm::rotate(glm::mat4() , glm::radians(15.0f), glm::vec3(-1.0f, 0.0f, 0.0f));&#125;if(glfwGetKey(window , GLFW_KEY_DOWN) || glfwGetKey(window , GLFW_KEY_S))&#123; Model = Model * glm::rotate(glm::mat4() , glm::radians(15.0f), glm::vec3(1.0f, 0.0f, 0.0f));&#125;if(glfwGetKey(window , GLFW_KEY_LEFT) || glfwGetKey(window , GLFW_KEY_A))&#123; Model = Model * glm::rotate(glm::mat4() , glm::radians(15.0f), glm::vec3(0.0f, -1.0f, 0.0f));&#125;if(glfwGetKey(window , GLFW_KEY_RIGHT) || glfwGetKey(window , GLFW_KEY_D))&#123; Model = Model * glm::rotate(glm::mat4() , glm::radians(15.0f), glm::vec3(0.0f, 1.0f, 0.0f));&#125; &emsp;&emsp;不会Markdown上传短视频，所以具体效果只能自己尝试运行了，如果有什么地方卡壳的话，可以看这里源代码。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】8-变换（试用矩阵运算实现平移，旋转，缩放）]]></title>
    <url>%2F2018%2F02%2F19%2F%E3%80%90OpenGL%E3%80%918-%E5%8F%98%E6%8D%A2%EF%BC%88%E8%AF%95%E7%94%A8%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%B9%B3%E7%A7%BB%EF%BC%8C%E6%97%8B%E8%BD%AC%EF%BC%8C%E7%BC%A9%E6%94%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】变换 【英文版】Transformations 学习目录 使用GLM数学库进行模型矩阵的平移 使用GLM数学库进行模型矩阵的缩放 使用GLM数学库进行模型矩阵的旋转 学习心得&emsp;&emsp;这篇文章中关于矩阵的计算（加减乘除等等）参考：矩阵运算 &emsp;平移&emsp;&emsp;首先看平移，在此我们使用上一篇文章中的项目作为基础来进行立方体的平移。我们的立方体如下： &emsp;&emsp;在此我们注意到之前代码中的MVP变量（Model,View,Projection），三个矩阵分别代表模型，视图，投影，而今天的操作平移是针对模型矩阵。首先修正我们摄像机的位置，将其改为在Z轴上方，即0,0,5位置 123456// Camera matrixglm::mat4 View = glm::lookAt( glm::vec3(0, 0, 5), //camera location glm::vec3(0, 0, 0), // and looks at the origin glm::vec3(0, -1, 0) // Head is up (set to 0,-1,0 to look upside-down)); &emsp;&emsp;其次修改投影矩阵，将视角放大一些（将glm::radians(45.0f)修改为glm::radians(90.0f)），即可见区域变大，这样我们在进行平移的时候可以平移更多距离不至于离开视线。 1glm::mat4 Projection = glm::perspective(glm::radians(90.0f), 4.0f / 3.0f, 0.1f, 100.0f); &emsp;&emsp;这时我们的视角将变成从Z轴往下看，之后的平移旋转操作将围绕X和Y轴进行，这是我们转换摄像机后的运行截图： &emsp;&emsp;由于我们摄像机位置的X，Y都是0，这时候我们看这个立方体的时候只能看到一个面，看起来像是一个平面正方形。 &emsp;&emsp;glm库中给我们提供了创建平移矩阵的方法 glm::translate，这个api的介绍为 Builds a translation 4 * 4 matrix created from a vector of 3 components. &emsp;&emsp;即使用一个vec3来创建平移矩阵（vec3自然是X , Y , Z三轴的值了），举个例子现在要向X轴正方向平移1，则使用glm::translate方法应该如下： 1glm::mat4 trans = glm::translate(glm::mat4(), glm::vec3(1.0f, 0.0f, 0.0f)); &emsp;&emsp;创建好平移矩阵，将其与Model相乘 1Model = Model * trans; &emsp;&emsp;之后再进行投影，视图，模型的矩阵相乘就可以了。我们将这一段放在我们的主循环里，但是编译运行后发现会直接看不到立方体了，这种情况是因为计算机处理的速度太快，在我们没看到的情况下已经平移出了摄像机可见区域。将vec3里的赋值改为0.001或者0.01即可。 &emsp;缩放&emsp;&emsp;缩放对我们来说也是很简单的，glm也提供了构造缩放矩阵的方法glm::scale Builds a scale 4 * 4 matrix created from 3 scalars. &emsp;&emsp;使用方法和平移差不多，三个参数即是X，Y，Z，当然我们要是放到主循环的话肯定要将数字设置的接近1一些，这样无论是放大还是缩小都能给我们看到的时间。 1Model = Model * glm::scale(glm::mat4() , glm::vec3(0.999f,0.999f,0.999f)); &emsp;旋转&emsp;&emsp;旋转矩阵的构建是比较麻烦的，但是glm已经提供给了我们可用的api，即glm::rotate Builds a rotation 4 * 4 matrix created from an axis vector and an angle expressed in degrees. &emsp;&emsp;由这句介绍可以看到，我们所需要给出的参数是X，Y，Z的坐标和角度，即绕着哪一个轴旋转，假如现在要绕着X轴旋转，即： 1Model = Model * glm::rotate(glm::mat4() , glm::radians(90.0f)/1000, glm::vec3(-1.0f, 0.0f, 0.0f)); &emsp;&emsp;这里我们使用了glm::radians，是一个转换函数，将角度转换为弧度，之所以给转换后的弧度值除以1000也是因为要让他旋转的慢一些，可以看得更清楚。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Letter-Case-Permutation]]></title>
    <url>%2F2018%2F02%2F19%2FLetter-Case-Permutation%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#784 Letter Case Permutation 题目描述&emsp;&emsp;Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. 123456789Examples:Input: S = &quot;a1b2&quot;Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]Input: S = &quot;3z4&quot;Output: [&quot;3z4&quot;, &quot;3Z4&quot;]Input: S = &quot;12345&quot;Output: [&quot;12345&quot;] Note: S will be a string with length at most 12. S will consist only of letters or digits. 解题思路&emsp;&emsp;这是一道Easy题，题目要求对给定字符串中所有的字母进行大小写转换，并且将通过转换得到的所有字符串都保留下来。 &emsp;&emsp;这种类似于排列的题毫无疑问直接用递归解，由于给定字符串包括数字与字母，所以我们递归的时候判断下当前字符是不是字母，是字母的话需要递归字母转换前和转换后的（就是说需要调用两次递归函数，转换前调用一次，转换后调用一次），不是的话直接调用递归函数就可以了。 解题代码【.CPP】123456789101112131415161718192021class Solution &#123; void push(string s, int idx, set&lt;string&gt; &amp;set) &#123; if (idx &gt;= s.size())return; push(s, idx + 1, set); if (isdigit(s[idx])) return; auto tmp = s; tmp[idx] += tmp[idx] &gt;= 'a' &amp;&amp; tmp[idx] &lt;= 'z' ? -32 : 32; set.insert(tmp); push(tmp, idx + 1, set); &#125;public: vector&lt;string&gt; letterCasePermutation(string S) &#123; set&lt;string&gt; tmp; tmp.insert(S); push(S, 0, tmp); vector&lt;string&gt; ret(0); for (auto t : tmp) ret.insert(ret.begin(),t); return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Daily-Temperatures]]></title>
    <url>%2F2018%2F02%2F19%2FDaily-Temperatures%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#739 Daily Temperatures 题目描述&emsp;&emsp;Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. &emsp;&emsp;For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0]. &emsp;&emsp;Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100]. 解题思路&emsp;&emsp;题目的意思是给定一个数组，数组中的每一个数字代表那一天的温度，然后让我们返回多少天后温度升温，即返回多少天后数字变大。 &emsp;&emsp;这道题采用栈实现，当前温度小于栈顶温度时，我们将当前温度的索引入栈，当他大于栈顶索引所指的温度时，则为栈顶索引处赋值为当前索引去栈顶索引。 解题代码【.CPP】12345678910111213141516class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int n = temperatures.size(); vector&lt;int&gt; res(n, 0); stack&lt;int&gt; st; for (int i = 0; i &lt; temperatures.size(); ++i) &#123; while (!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()]) &#123; auto t = st.top(); st.pop(); res[t] = i - t; &#125; st.push(i); &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shortest-Completing-Word]]></title>
    <url>%2F2018%2F02%2F16%2FShortest-Completing-Word%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#748 Shortest Completing Word 题目描述&emsp;&emsp;Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate. Such a word is said to complete the given string licensePlate &emsp;&emsp;Here, for letters we ignore case. For example, &quot;P&quot; on the licensePlate still matches &quot;p&quot; on the word. &emsp;&emsp;It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array. &emsp;&emsp;The license plate might have the same letter occurring multiple times. For example, given a licensePlate of &quot;PP&quot;, the word &quot;pair&quot; does not complete the licensePlate, but the word &quot;supper&quot; does. Example 1: 12345Input: licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]Output: &quot;steps&quot;Explanation: The smallest length word that contains the letters &quot;S&quot;, &quot;P&quot;, &quot;S&quot;, and &quot;T&quot;.Note that the answer is not &quot;step&quot;, because the letter &quot;s&quot; must occur in the word twice.Also note that we ignored case for the purposes of comparing whether a letter exists in the word. Example 2: 1234Input: licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]Output: &quot;pest&quot;Explanation: There are 3 smallest length words that contains the letters &quot;s&quot;.We return the one that occurred first. Note: licensePlate will be a string with length in range [1, 7]. licensePlate will contain digits, spaces, or letters (uppercase or lowercase). words will have a length in the range [10, 1000]. Every words[i] will consist of lowercase letters, and have length in range [1, 15]. 解题思路&emsp;&emsp;按照题意，在words里找出一个能匹配licensePlate且长度最短的单词（多个答案选第一个），匹配的过程用map即可实现，刚开始我想的是先对words进行排序，碰到匹配成功的就可以直接返回了，不过不知道为什么一直有问题（我明明没错啊！），就改成了用变量进行保存迭代实现。 解题代码【.CPP】1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool judge(string licensePlate, string word) &#123; unordered_map&lt;char, int&gt; um; for (auto c : word) &#123; c = tolower(c); if (c &lt;= 'z' &amp;&amp; c &gt;= 'a') &#123; if (um[c] &gt; 0) ++um[c]; else um[c] = 1; &#125; &#125; for (auto c : licensePlate) &#123; c = tolower(c); if (c &lt;= 'z' &amp;&amp; c &gt;= 'a') &#123; if (um[c] &gt; 0) --um[c]; else return false; &#125; &#125; return true; &#125; string shortestCompletingWord(string licensePlate, vector&lt;string&gt; words) &#123; string ret = ""; for (auto w : words) &#123; if (judge(licensePlate, w) &amp;&amp; (ret.empty() || w.size() &lt; ret.size())) ret = w; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toeplitz-Matrix]]></title>
    <url>%2F2018%2F02%2F15%2FToeplitz-Matrix%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#766 Toeplitz Matrix 题目描述A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Example 1: 12345678Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]Output: TrueExplanation:123451239512In the above grid, the diagonals are &quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;, and in each diagonal all elements are the same, so the answer is True. Example 2: 1234Input: matrix = [[1,2],[2,2]]Output: FalseExplanation:The diagonal &quot;[1, 2]&quot; has different elements. Note: matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. 解题思路&emsp;&emsp;题目要求判断一个N x M的矩阵是否满足在一个斜线（斜线是从左上到右下）上的数字都相同的条件，直接按照题目要求进行判断就是了。 解题代码【.CPP】123456789101112131415161718192021class Solution &#123; bool Judge(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int i, int j) &#123; for (int x = i, y = j; x &lt; matrix.size() &amp;&amp; y &lt; matrix[i].size(); ++x, ++y) &#123; if (matrix[x][y] != matrix[i][j]) return false; &#125; return true; &#125;public: bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix) &#123; if (matrix.empty()) return true; bool ret = true; for (int i = 0; i &lt; matrix.size(); ++i) &#123; if (!Judge(matrix, i, 0)) return false; &#125; for (int j = 1; j &lt; matrix[0].size(); ++j) &#123; if (!Judge(matrix, 0, j)) return false; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】7-纹理2]]></title>
    <url>%2F2018%2F02%2F14%2F%E3%80%90OpenGL%E3%80%917-%E7%BA%B9%E7%90%862%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】第五课：带纹理的立方体 【英文版】Tutorial 5 : A Textured Cube 学习目录 调整上一篇文章的代码，进行坐标的翻转使得正方体正确的显示 纹理的解析 学习笔记 调整上一篇文章的代码，进行坐标的翻转使得正方体正确的显示 &emsp;&emsp;在上一篇中将纹理通过UV坐标贴到了正方体上，我们运行之后是这样子的。 &emsp;&emsp;我们在使用压缩纹理时，将UV坐标里的V修改为1.0-V，进行坐标反转。即将 123456789101112131415161718192021222324252627282930313233343536373839// Two UV coordinatesfor each vertex. They were created with Blender. static const GLfloat g_uv_buffer_data[] = &#123; 0.000059f, 0.000004f, 0.000103f, 0.336048f, 0.335973f, 0.335903f, 1.000023f, 0.000013f, 0.667979f, 0.335851f, 0.999958f, 0.336064f, 0.667979f, 0.335851f, 0.336024f, 0.671877f, 0.667969f, 0.671889f, 1.000023f, 0.000013f, 0.668104f, 0.000013f, 0.667979f, 0.335851f, 0.000059f, 0.000004f, 0.335973f, 0.335903f, 0.336098f, 0.000071f, 0.667979f, 0.335851f, 0.335973f, 0.335903f, 0.336024f, 0.671877f, 1.000004f, 0.671847f, 0.999958f, 0.336064f, 0.667979f, 0.335851f, 0.668104f, 0.000013f, 0.335973f, 0.335903f, 0.667979f, 0.335851f, 0.335973f, 0.335903f, 0.668104f, 0.000013f, 0.336098f, 0.000071f, 0.000103f, 0.336048f, 0.000004f, 0.671870f, 0.336024f, 0.671877f, 0.000103f, 0.336048f, 0.336024f, 0.671877f, 0.335973f, 0.335903f, 0.667969f, 0.671889f, 1.000004f, 0.671847f, 0.667979f, 0.335851f &#125;; &emsp;&emsp;修改为 123456789101112131415161718192021222324252627282930313233343536373839// Two UV coordinatesfor each vertex. They were created with Blender.static const GLfloat g_uv_buffer_data[] = &#123; 0.000059f, 1.0f-0.000004f, 0.000103f, 1.0f-0.336048f, 0.335973f, 1.0f-0.335903f, 1.000023f, 1.0f-0.000013f, 0.667979f, 1.0f-0.335851f, 0.999958f, 1.0f-0.336064f, 0.667979f, 1.0f-0.335851f, 0.336024f, 1.0f-0.671877f, 0.667969f, 1.0f-0.671889f, 1.000023f, 1.0f-0.000013f, 0.668104f, 1.0f-0.000013f, 0.667979f, 1.0f-0.335851f, 0.000059f, 1.0f-0.000004f, 0.335973f, 1.0f-0.335903f, 0.336098f, 1.0f-0.000071f, 0.667979f, 1.0f-0.335851f, 0.335973f, 1.0f-0.335903f, 0.336024f, 1.0f-0.671877f, 1.000004f, 1.0f-0.671847f, 0.999958f, 1.0f-0.336064f, 0.667979f, 1.0f-0.335851f, 0.668104f, 1.0f-0.000013f, 0.335973f, 1.0f-0.335903f, 0.667979f, 1.0f-0.335851f, 0.335973f, 1.0f-0.335903f, 0.668104f, 1.0f-0.000013f, 0.336098f, 1.0f-0.000071f, 0.000103f, 1.0f-0.336048f, 0.000004f, 1.0f-0.671870f, 0.336024f, 1.0f-0.671877f, 0.000103f, 1.0f-0.336048f, 0.336024f, 1.0f-0.671877f, 0.335973f, 1.0f-0.335903f, 0.667969f, 1.0f-0.671889f, 1.000004f, 1.0f-0.671847f, 0.667979f, 1.0f-0.335851f&#125;; &emsp;&emsp;其实这两个就是互相相反的UV反转的结果，就是将V变成1.0-V而已。 纹理的解析 &emsp;&emsp;纹理本质上就是特殊的色彩贴图，我们在GLSL中对片段着色器的着色就是用的texture( myTextureSampler, UV ).rgb。相当于我们在一张贴图上取其中一片像素点，将其颜色覆盖到我们的模型上，比起纯色来说更加好看一些。 &emsp;&emsp;在这篇文章之前，没有太多了解关于模型（Model），视图（View），投影（Projection），下篇文章中会再学习一遍。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jewels-and-Stones]]></title>
    <url>%2F2018%2F02%2F14%2FJewels-and-Stones%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#771 Jewels and Stones 题目描述You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in Sis a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;. Example 1: 12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 Example 2: 12Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. 解题思路&emsp;&emsp;题目的意思就是说求J中的字符出现在S中的次数之和，直接两层循环都可以。 解题代码【.CPP】123456789101112class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; int ret = 0; for (auto j : J) &#123; for (auto s : S) &#123; ret += j == s; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redundant-Connection]]></title>
    <url>%2F2018%2F02%2F12%2FRedundant-Connection%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#684 Redundant Connection 题目描述In this problem, a tree is an undirected graph that is connected and has no cycles. The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v. Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v. Example 1: 123456Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given undirected graph will be like this: 1 / \2 - 3 Example 2: 123456Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]Output: [1,4]Explanation: The given undirected graph will be like this:5 - 1 - 2 | | 4 - 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Update (2017-09-26):We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directedgraph follow up please see Redundant Connection II). We apologize for any inconvenience caused. 解题思路&emsp;&emsp;并查集算法(Union-Find) &emsp;&emsp;这道题使用我上边给出的并查集算法可以很简单的解决，我们建立一个足以囊括题目所给连通图所有点的数组，并且将其所有值赋值为-1。在这里我们使用N[a]=b来表示a与b的直接连通关系，那么当N[a] = b &amp;&amp; N[b] = c时a与c也有间接的连通关系。 &emsp;&emsp;而这道题要求我们求出给定无向图的冗余边（即去掉此边后仍保持全连通），那么我们遍历给定的边集合，并以遍历到的边的两个点为起点查找其最远的连通点，如果最终边上两个点得到的最远的连通点相同说明这个边上的两个点在同一个连通分量上，即当前边是冗余边，将其返回。 解题代码【.CPP】12345678910111213141516public: vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;int&gt; root(2001, -1); for (auto edge : edges) &#123; int x = find(root, edge[0]), y = find(root, edge[1]); if (x == y) return edge; root[x] = y; &#125; return &#123;&#125;; &#125; int find(vector&lt;int&gt;&amp; root, int i) &#123; while (root[i] != -1) &#123; i = root[i]; &#125; return i; &#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为hexo博客系统添加基于github-issue的gitalk评论系统]]></title>
    <url>%2F2018%2F02%2F11%2F%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%B7%BB%E5%8A%A0%E5%9F%BA%E4%BA%8Egithub-issue%E7%9A%84gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;由于之前使用的gitment评论系统出现了问题，需要进行一些修改。然后修改的时候想了想，gitment好久没更新了，索性直接换掉用另一个gitalk算了。而gitalk的配置在网上倒是有一大把，但是都是基于NexT主题进行的修改，没有找到yilia主题对应的方案，只能自己折腾，幸好最后弄出来了。 1.创建 Github OAuth App&emsp;&emsp;这个和gitment倒是一样，因为这两个的本质都是利用github的issue来搭建评论系统，所以必须要github的授权，这里便是创建一个github授权的程序。 进入github主页创建一个仓库（这个仓库的issue用来存放评论，也可以直接使用自己博客的仓库） 创建一个Github OAuth app &emsp;&emsp;在设置界面的开发者设置里，点击new 名称和描述自然是随便填的，记得Homepage URL和Authorization callback URL则不能出错，必须填你博客的主页，比如我的是 https://blog.ksgin.com ，就都填这个，https 与 http也不能省略也不能填错。 成功后会获得Client ID和Client Secret两个值，留着等下要用 2.gitalk使用（这部分摘抄自gitalk github上的使用介绍，看不懂可以略过）InstallTwo ways. links 1234567&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;&lt;!-- or --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;&lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; npm install 1npm i --save gitalk 12import &apos;gitalk/dist/gitalk.css&apos;import Gitalk from &apos;gitalk&apos; UsageA Github Application is needed for authorization, if you don’t have one, Click here to register a new one. Note: You must specify the website domain url in the Authorization callback URL field. 1234567891011const gitalk = new Gitalk(&#123; clientID: &apos;Github Application Client ID&apos;, clientSecret: &apos;Github Application Client Secret&apos;, repo: &apos;Github repo&apos;, owner: &apos;Github repo owner&apos;, admin: [&apos;Github repo owner and collaborators, only these guys can initialize github issues&apos;], // facebook-like distraction free mode distractionFreeMode: false&#125;)gitalk.render(&apos;gitalk-container&apos;) Options clientID String Required. Github Application Client ID. clientSecret String Required. Github Application Client Secret. repo String Required. Github repository. owner String Required. Github repository owner. Can be personal user or organization. admin Array Required. Github repository owner and collaborators. (Users who having write access to this repository) id String Default: location.href. The unique id of the page. labels Array Default: [&#39;Gitalk&#39;]. Github issue labels. title String Default: document.title. Github issue title. body String Default: location.href + header.meta[description]. Github issue body. language String Default: navigator.language || navigator.userLanguage. Localization language key, en, zh-CN and zh-TW are currently available. perPage Number Default: 10. Pagination size, with maximum 100. distractionFreeMode Boolean Default: false. Facebook-like distraction free mode. pagerDirection String Default: ‘last’ Comment sorting direction, available values are last and first. createIssueManually Boolean Default: false. By default, Gitalk will create a corresponding github issue for your every single page automatically when the logined user is belong to the admin users. You can create it manually by setting this option to true. proxy String Default: https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token. Github oauth request reverse proxy for CORS. Why need this? flipMoveOptions Object Default: 123456&#123; staggerDelayBy: 150, appearAnimation: &apos;accordionVertical&apos;, enterAnimation: &apos;accordionVertical&apos;, leaveAnimation: &apos;accordionVertical&apos;,&#125; Comment list animation. Reference enableHotKey Boolean Default: true. Enable hot key (cmd|ctrl + enter) submit comment. 3.gitalk应用于hexo博客系统的yilia主题 首先我们在yalia目录下的_config.yml下加入如下几行 123456789# Gitalkgitalk: enable: true #用来做启用判断可以不用 clientID: 'xxxxxxxxxxxxxxxxx' #上面生成Client Id的往这里怼 clientSecret: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' #同上Client Secret repo: ksgin.github.io #仓库名称 owner: ksgin #github用户名 admin: ksgin distractionFreeMode: true 之后在yalia目录下找到 layout/_partial/post 目录，在里边新建一个文件，并输入以下内容 123456789101112131415&lt;div id=&apos;gitalk-container&apos;&gt;&lt;/div&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;&lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&lt;%=theme.gitalk.clientID%&gt;&apos;, clientSecret: &apos;&lt;%=theme.gitalk.clientSecret%&gt;&apos;, id: &quot;&lt;%=page.title%&gt;&quot;, repo: &apos;&lt;%=theme.gitalk.repo%&gt;&apos;, owner: &apos;&lt;%=theme.gitalk.owner%&gt;&apos;, admin: &apos;&lt;%=theme.gitalk.admin%&gt;&apos;, distractionFreeMode: &apos;&lt;%=theme.gitalk.distractionFreeMode%&gt;&apos;, &#125;) gitalk.render(&apos;gitalk-container&apos;)&lt;/script&gt; &emsp;&emsp;为文件命名为gitalk.ejs 然后找到yalia目录下的 layout/_partial/article.ejs 文件，在 123&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; // something&lt;% &#125; %&gt; &emsp;&emsp;这个框架中加入导入gitalke的代码变成以下的样子 123456789&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; //something &lt;%- partial(&apos;post/gitalk&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt;&lt;% &#125; %&gt; &emsp;&emsp;按照一般情况，在我们加入内容的框架内，应该有数个评论系统的导入代码，用if来进行判断使用，由于我们现在只使用gitalk，所以可以将其他的都删掉只留我们新加入的这一个（框架主题毕竟是为了通用，而我们是为了己用）。 4.修改成功&emsp;&emsp;有问题可以在下边留言。]]></content>
      <tags>
        <tag>blog</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flatten-Nested-List-Iterator]]></title>
    <url>%2F2018%2F02%2F09%2FFlatten-Nested-List-Iterator%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#341 Flatten Nested List Iterator 题目描述Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list — whose elements may also be integers or other lists. Example 1:Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2:Given the list [1,[4,[6]]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. 解题思路&emsp;&emsp;这种题目根据题目要求做就行了。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger &#123; * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * &#125;; */class NestedIterator &#123; vector&lt;int&gt; list; int idx = 0; void _init_(const vector&lt;NestedInteger&gt; &amp;nestedList)&#123; for (auto nest : nestedList) &#123; if(nest.isInteger()) list.push_back(nest.getInteger()); else _init_(nest.getList()); &#125; &#125;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; list = vector&lt;int&gt;(0); _init_(nestedList); &#125; int next() &#123; return list[idx++]; &#125; bool hasNext() &#123; return idx &lt; list.size(); &#125;&#125;;/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bulb-Switcher]]></title>
    <url>%2F2018%2F02%2F07%2FBulb-Switcher%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#319 Bulb Switcher 题目描述There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: 12345678Given n = 3. At first, the three bulbs are [off, off, off].After first round, the three bulbs are [on, on, on].After second round, the three bulbs are [on, off, on].After third round, the three bulbs are [on, off, off]. So you should return 1, because there is only one bulb is on. 解题思路&emsp;&emsp;题目意思是给定n个灯泡，初始处于关闭状态，然后从1到n遍历（假定为i），每隔 i个就改变灯泡的状态。即遍历1到n，然后对所有编号为i的倍数的灯泡进行状态改变，最后求出遍历完后处在亮（On）的灯泡有几个。 &emsp;&emsp;刚开始直接根据题意两层循环，结果超时，最后仔细考虑后发现当某个数的因子有奇数个时，它所代表的灯泡最终会处于亮的状态。而某个数的因子是奇数，则代表这个数是一个完全平方数，所以题目变成了求1-n中有多少个完全平方数。 解题代码【.CPP】12345678class Solution &#123;public: int bulbSwitch(int n) &#123; int res = 0; while (res * res &lt;= n) ++ res; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Delete-And-Earn]]></title>
    <url>%2F2018%2F02%2F04%2FDelete-And-Earn%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#740 Delete and Earn 题目描述Given an array nums of integers, you can perform operations on the array. In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1. You start with 0 points. Return the maximum number of points you can earn by applying such operations. Example 1: 12345Input: nums = [3, 4, 2]Output: 6Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted.Then, delete 2 to earn 2 points. 6 total points are earned. Example 2: 123456Input: nums = [2, 2, 3, 3, 3, 4]Output: 9Explanation: Delete 3 to earn 3 points, deleting both 2&apos;s and the 4.Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.9 total points are earned. Note: The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000]. 解题思路&emsp;&emsp;很经典的DP题。与此类似的有Best Time to Buy and Sell Stock with Transaction Fee。 &emsp;&emsp;由于delete一个数字的话，和它相差1的数字将不给得分（即如果删除3，则只能得到3的分，2与4的不能得到），所以我们使用两个变量来维护（）take 与 skip），一个用来保存删除当前数字后的分数（take），一个用来保存不删除当前数字（skip）（即删除与它相差1的数字）。 &emsp;&emsp;由于题目要求delete一个数字的话必须删除与相差1的数字，所以我们的take的计算式为： &emsp;&emsp;take = skip + nums.value * nums.count &emsp;&emsp;而skip则是取skip与更新前的take中的较大值（skip保存的是不删除当前的值的最大分数，即上一步中的take与skip较大值）。 &emsp;&emsp;skip = max(take , skip) 解题代码【.CPP】1234567891011121314class Solution &#123;public: int deleteAndEarn(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; sums(10001, 0); int take = 0, skip = 0; for (int num : nums) sums[num] += num; for (int i = 0; i &lt; 10001; ++i) &#123; int takei = skip + sums[i]; int skipi = max(skip, take); take = takei; skip = skipi; &#125; return max(skip, take); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyramid-Transition-Matrix]]></title>
    <url>%2F2018%2F02%2F04%2FPyramid-Transition-Matrix%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#756 Pyramid Transition Matrix 题目描述&emsp;&emsp;We are stacking blocks to form a pyramid. Each block has a color which is a one letter string, like &#39;Z&#39;. &emsp;&emsp;For every block of color C we place not in the bottom row, we are placing it on top of a left block of color A and right block of color B. We are allowed to place the block there only if (A, B, C) is an allowed triple. &emsp;&emsp;We start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed. Each allowed triple is represented as a string of length 3. &emsp;&emsp;Return true if we can build the pyramid all the way to the top, otherwise false. Example 1: 1234567891011Input: bottom = &quot;XYZ&quot;, allowed = [&quot;XYD&quot;, &quot;YZE&quot;, &quot;DEA&quot;, &quot;FFF&quot;]Output: trueExplanation:We can stack the pyramid like this: A / \ D E / \ / \X Y ZThis works because (&apos;X&apos;, &apos;Y&apos;, &apos;D&apos;), (&apos;Y&apos;, &apos;Z&apos;, &apos;E&apos;), and (&apos;D&apos;, &apos;E&apos;, &apos;A&apos;) are allowed triples. Example 2: 12345Input: bottom = &quot;XXYX&quot;, allowed = [&quot;XXX&quot;, &quot;XXY&quot;, &quot;XYX&quot;, &quot;XYY&quot;, &quot;YXZ&quot;]Output: falseExplanation:We can&apos;t stack the pyramid to the top.Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D. Note: bottom will be a string with length in range [2, 8]. allowed will have length in range [0, 200]. Letters in all strings will be chosen from the set {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;}. 解题思路&emsp;&emsp;DP 解题代码【.CPP】1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool pyramidTransition(string bottom, vector&lt;string&gt;&amp; allowed) &#123; int n = static_cast&lt;int&gt;(bottom.size()); unordered_map&lt;string, vector&lt;char&gt;&gt; mp; vector&lt;vector&lt;set&lt;char&gt;&gt;&gt; dp(n, vector&lt;set&lt;char&gt;&gt;(n)); for(string temp: allowed)&#123; mp[temp.substr(0,2)].push_back(temp[2]); &#125; for(int i = 0; i &lt; n ; ++i) &#123; dp[0][i].insert(bottom[i]); &#125; for(int i = 1; i &lt; n; ++i)&#123; for(int j = 0; j &lt; n-i; ++j)&#123; for(char a: dp[i-1][j])&#123; for(char b: dp[i-1][j+1])&#123; string s = ""; s = s+a+b; for(char c: mp[s])&#123; dp[i][j].insert(c); &#125; &#125; &#125; &#125; &#125; return !dp[n-1][0].empty(); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Burst-Balloons]]></title>
    <url>%2F2018%2F01%2F31%2FBurst-Balloons%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#312 Burst Balloons 题目描述Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and rightare adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 Example: Given [3, 1, 5, 8] Return 167 12 nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 解题思路&emsp;&emsp;题目是打气球，每打一个气球的得分是这个气球左右两边的数字以及这个气球的数字之积，如果左右两边没有数字就用1代替，最终需要得到可以得到的最大值。 &emsp;&emsp;求全局极值问题，首先考虑递归或者动态规划！ &emsp;&emsp;这道题使用动态规划，dp[i][j]存放的是nums[i]到nums[j]内可以打爆所有气球获得的最大值，最后我们返回dp[0][n]就可以了。 &emsp;&emsp;递推式dp[i][j] = max(dp[i][j], nums[i - 1]*nums[k]*nums[j + 1] + dp[i][k - 1] + dp[k + 1][j]) ( i ≤ k ≤ j ) 解题代码【.CPP】123456789101112131415161718class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); nums.insert(nums.begin(), 1); nums.push_back(1); vector&lt;vector&lt;int&gt; &gt; dp(nums.size(), vector&lt;int&gt;(nums.size() , 0)); for (int len = 1; len &lt;= n; ++len) &#123; for (int left = 1; left &lt;= n - len + 1; ++left) &#123; int right = left + len - 1; for (int k = left; k &lt;= right; ++k) &#123; dp[left][right] = max(dp[left][right], nums[left - 1] * nums[k] * nums[right + 1] + dp[left][k - 1] + dp[k + 1][right]); &#125; &#125; &#125; return dp[1][n]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sliding-Puzzle]]></title>
    <url>%2F2018%2F01%2F29%2FSliding-Puzzle%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#773 Sliding Puzzle 题目描述On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. Examples: 123Input: board = [[1,2,3],[4,0,5]]Output: 1Explanation: Swap the 0 and the 5 in one move. 123Input: board = [[1,2,3],[5,4,0]]Output: -1Explanation: No number of moves will make the board solved. 12345678910Input: board = [[4,1,2],[5,0,3]]Output: 5Explanation: 5 is the smallest number of moves that solves the board.An example path:After move 0: [[4,1,2],[5,0,3]]After move 1: [[4,1,2],[0,5,3]]After move 2: [[0,1,2],[4,5,3]]After move 3: [[1,0,2],[4,5,3]]After move 4: [[1,2,0],[4,5,3]]After move 5: [[1,2,3],[4,5,0]] 12Input: board = [[3,2,4],[1,5,0]]Output: 14 Note: board will be a 2 x 3 array as described above. board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5]. 解题思路&emsp;&emsp;Sliding puzzle是一种棋盘游戏，这道题将其数字化。题目要求是给我们一个2*3的矩阵，矩阵内有无序排列的0-5六个数字，每一步交换只允许交换与0毗连的数字和0，让我们找出要将给定矩阵还原成123450所需要的最少步数。 &emsp;&emsp;由于仅仅是2*3棋盘，所可能存在的序列很有限，所以我们可以从最终状态（即123450）来逆推出所有能到达最终状态的状态并且统计出其到达最终状态的最少步数。在这里我们使用递归，每一次递归反映为一个状态，这个状态经过题目要求的交换后可能会产生多个新的状态，这是递归内容，而每一次递归的时候所产生的状态以及到达这一状态所需要的步数我们会进行保存，如果递归时发现当前状态已存在且存储的那个最小步数比当前的小则结束这一个分支（即结束条件是当前状态所能产生的状态都已经存在且存储的步数小于或者等于当前步数）。 &emsp;&emsp;这样计算后我们会得到所有的可到达最终状态的状态以及到达最终状态的最少步数集合，只需要判断输入状态是否在集合里，在返回对应步数，不在返回-1（说明输入状态无法到达最终状态）。 解题代码【.CPP】1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; void helper(unordered_map&lt;string,int&gt;&amp; um , string state , int step)&#123; if(um.count(state) == 1) um[state] = min(step , um[state]); else um[state] = step; int idx = static_cast&lt;int&gt;(state.find_first_of('0')); if(idx &lt; 3)&#123; swap(state[idx] , state[idx+3]); if(!um.count(state) || um[state] &gt; step) helper(um , state , step+1); swap(state[idx] , state[idx+3]); &#125; if(idx &gt;= 3)&#123; swap(state[idx] , state[idx-3]); if(!um.count(state) || um[state] &gt; step) helper(um , state , step+1); swap(state[idx] , state[idx-3]); &#125; if(idx != 2 &amp;&amp; idx != 5)&#123; swap(state[idx] , state[idx+1]); if(!um.count(state) || um[state] &gt; step) helper(um , state , step+1); swap(state[idx] , state[idx+1]); &#125; if(idx != 0 &amp;&amp; idx != 3)&#123; swap(state[idx] , state[idx-1]); if(!um.count(state) || um[state] &gt; step) helper(um , state , step+1); swap(state[idx] , state[idx-1]); &#125; &#125;public: int slidingPuzzle(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; string start = ""; for (auto i : board)&#123; for (auto j : i) start.push_back(static_cast&lt;char&gt;(j + '0')); &#125; string end = "123450"; unordered_map&lt;string , int&gt; um; helper(um , end , 0); if(um.count(start) == 1) return um[start]; return -1; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert-Sorted-Array-to-Binary-Search-Tree]]></title>
    <url>%2F2018%2F01%2F28%2FConvert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#108 Convert Sorted Array to Binary Search Tree 题目描述&emsp;&emsp;Given an array where elements are sorted in ascending order, convert it to a height balanced BST. &emsp;&emsp;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 解题思路&emsp;&emsp;构造二叉树的题，我们用递归来实现（其实大部分关于二叉树的题都是无脑递归就可以了），给定数组的最中间值为根，左边子数组为左子树，右边子数组为右子树。 解题代码【.CPP】1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; void helper(vector&lt;int&gt; &amp;nums, int l, int r, TreeNode *node) &#123; if (l &lt; r) &#123; int mid = (l + r) / 2; node-&gt;val = nums[mid]; if(l &lt; mid)&#123; node-&gt;left = new TreeNode(0); helper(nums,l , mid , node-&gt;left); &#125; if(mid+1 &lt; r)&#123; node-&gt;right = new TreeNode(0); helper(nums,mid+1 , r , node-&gt;right); &#125; &#125; else &#123; node = nullptr; &#125; &#125;public: TreeNode *sortedArrayToBST(vector&lt;int&gt; &amp;nums) &#123; if(nums.empty()) return nullptr; TreeNode *root = new TreeNode(0); helper(nums , 0 , static_cast&lt;int&gt;(nums.size()), root); return root; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】6-纹理1]]></title>
    <url>%2F2018%2F01%2F26%2F%E3%80%90OpenGL%E3%80%916-%E7%BA%B9%E7%90%861%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】第五课：带纹理的立方体 【英文版】Tutorial 5 : A Textured Cube &emsp;&emsp;感觉自己学的好慢啊。 &emsp;&emsp;纹理（Texture），在计算机图形学中是把存储在内存里的位图包裹到3D渲染物体的表面。 纹理贴图给物体提供了丰富的细节，用简单的方式模拟出了复杂的外观。 一个图像（纹理）被贴(映射)到场景中的一个简单形体上，就像印花贴到一个平面上一样。 ​ &emsp;&emsp;在OpenGL中，纹理的初始化及使用与顶点缓冲，颜色缓冲基本相同（本身纹理就相当于特殊的颜色）。主要的方法也就那几个，加载glGenTextures， 绑定glBindTexture，配置glTexImage2D（在glTexImage2D函数中，GL_RGB表示颜色由三个分量构成，GL_BGR则说明了颜色在内存中的存储格式。实际上，BMP存储的并不是RGB，而是BGR，因此得把这个告诉OpenGL）。 &emsp;&emsp;在着色器中，使用Sampler2D来获知要加载哪一个纹理（同一个着色器中可以访问多个纹理）。顶点着色器中则是将UV坐标以UV数对的方式读取并传递给片段着色器。 关于UV坐标给模型贴纹理时，我们需要通过UV坐标来告诉OpenGL用哪块图像填充三角形。 每个顶点除了位置坐标外还有两个浮点数坐标：U和V。这两个坐标用于访问纹理，如下图所示： 注意观察纹理是怎样在三角形上扭曲的。 &emsp;&emsp;而读取UV数对的方式就如同我们读取颜色缓冲数组或者顶点缓冲数组一样，使用layout(location = 1) in vec2 vertexUV;，读取到之后使用texture方法获得纹理并将他的rgb赋值给color（纹理是一种特殊的color），使用方法color = texture( myTextureSampler, UV ).rgb;。 &emsp;&emsp;在最终的代码中，我们使用了过滤，下面是过滤和mipmap的介绍： 什么是过滤和mipmap？怎样使用？正如在上面截图中看到的，纹理质量不是很好。这是因为在loadBMP_custom函数中，有如下两行代码： 1234&gt; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);&gt; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);&gt;&gt; &gt; 这意味着在片段着色器中，texture()将直接提取位于(U,V)坐标的纹素（texel）。 有几种方法可以改善这一状况。 线性过滤（Linear filtering）若采用线性过滤。texture()会查看周围的纹素，然后根据UV坐标距离各纹素中心的距离来混合颜色。这就避免了前面看到的锯齿状边缘。 线性过滤可以显著改善纹理质量，应用的也很多。但若想获得更高质量的纹理，可以采用各向异性过滤，不过速度有些慢。 各向异性过滤（Anisotropic filtering）这种方法逼近了真正片断中的纹素区块。例如下图中稍稍旋转了的纹理，各向异性过滤将沿蓝色矩形框的主方向，作一定数量的采样（即所谓的”各向异性层级”），计算出其内的颜色。 Mipmaps线性过滤和各向异性过滤都存在一个共同的问题。那就是如果从远处观察纹理，只对4个纹素作混合显得不够。实际上，如果3D模型位于很远的地方，屏幕上只看得见一个片断（像素），那计算平均值得出最终颜色值时，图像所有的纹素都应该考虑在内。很显然，这种做法没有考虑性能问题。撇开两种过滤方法不谈，这里要介绍的是mipmap技术： 一开始，把图像缩小到原来的1/2，然后依次缩小，直到图像只有1x1大小（应该是图像所有纹素的平均值） 绘制模型时，根据纹素大小选择合适的mipmap。 可以选用nearest、linear、anisotropic等任意一种滤波方式来对mipmap采样。 要想效果更好，可以对两个mipmap采样然后混合，得出结果。 好在这个比较简单，OpenGL都帮我们做好了，只需一个简单的调用： 1234567&gt; // When MAGnifying the image (no bigger mipmap available), use LINEAR filtering&gt; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);&gt; // When MINifying the image, use a LINEAR blend of two mipmaps, each filtered LINEARLY too&gt; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);&gt; // Generate mipmaps, by the way.&gt; glGenerateMipmap(GL_TEXTURE_2D);&gt; &emsp;&emsp;在我们的代码中使用了自己写的bmp读取方法，实际上在OpenGL中提供了这个方法，调用如下 12345678910111213141516171819202122GLuint loadTGA_glfw(const char * imagepath)&#123; // Create one OpenGL texture GLuint textureID; glGenTextures(1, &amp;textureID); // "Bind" the newly created texture : all future texture functions will modify this texture glBindTexture(GL_TEXTURE_2D, textureID); // Read the file, call glTexImage2D with the right parameters glfwLoadTexture2D(imagepath, 0); // Nice trilinear filtering. glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glGenerateMipmap(GL_TEXTURE_2D); // Return the ID of the texture we just created return textureID;&#125; &emsp;&emsp;即glfwLoadTexture2D方法。 &emsp;&emsp;源代码]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Subsets]]></title>
    <url>%2F2018%2F01%2F26%2FSubsets%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#78 Subsets 题目描述Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路&emsp;&emsp;一道Medium题，但是题目很简单，就是输出给定集合的子集，解法也很简单，就是遍历填值。即我们主循环里遍历给定集合，子循环遍历结果集（二维集合），将其中的一维集合提取出来给他加上当前遍历的给定集合的值，然后再添加到结果集末尾。 解题代码【.CPP】12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret(0); ret.push_back(vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; auto se = ret.size(); for (auto j = 0; j &lt; se; ++j) &#123; auto tmp = ret[j]; tmp.push_back(nums[i]); ret.push_back(tmp); &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Max-Chunks-To-Make-Sorted]]></title>
    <url>%2F2018%2F01%2F23%2FMax-Chunks-To-Make-Sorted%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#769 Max Chunks To Make Sorted 题目描述Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of “chunks” (partitions), and individually sort each chunk. After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: 12345Input: arr = [4,3,2,1,0]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&apos;t sorted. Example 2: 12345Input: arr = [1,0,2,3,4]Output: 4Explanation:We can split into two chunks, such as [1, 0], [2, 3, 4].However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. Note: arr will have length in range [1, 10]. arr[i] will be a permutation of [0, 1, ..., arr.length - 1]. 解题思路&emsp;&emsp;这道题题意是将一个无序数组排列分割最大次使得每一次分割的子数组排序后再拼接起来使整个数组有序。 &emsp;&emsp;索引遍历数组，以索引为分割点，索引左部（包括本身）的最大值如果小于右部的最小值，说明这两个不在一个分组内，给res加一。 解题代码【.CPP】1234567891011121314151617181920class Solution &#123; int maxV(vector&lt;int&gt; num , int idx)&#123; int rs = num[0]; for (int i = 0; i &lt;= idx; ++i) &#123; rs = max(rs ,num[i]); &#125; return rs; &#125;public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) &#123; int size =static_cast&lt;int&gt;(arr.size()) , res = 1; int rmin = arr[size-1]; for (int i = size-2; i &gt;= 0; --i) &#123; int lmax = maxV(arr , i); if(lmax &lt; rmin) res++; if(arr[i] &lt; rmin) rmin = arr[i]; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee]]></title>
    <url>%2F2018%2F01%2F22%2FBest-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#714 Best Time to Buy and Sell Stock with Transaction Fee 题目描述Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 1234Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Note: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 解题思路&emsp;&emsp;sold保存第i天时卖出手里股票的利润最大值，hold保存第i天保留手里股票的利润最大值，sold计算方式为昨天保留在手里的利润加上今天卖出股票的利润减去服务费和昨天的利润中取较大值（即当今天卖出的利润小于或者等于服务费时不卖），hold计算方式为昨天卖出的总利润减去今天买进股票的利润和昨天不卖的利润中取较大值。 解题代码【.CPP】123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int sold = 0, hold = -prices[0]; for (int price : prices) &#123; int t = sold; sold = max(sold, hold + price - fee); hold = max(hold, t - price); &#125; return sold; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】5-彩色立方体]]></title>
    <url>%2F2018%2F01%2F21%2F%E3%80%90OpenGL%E3%80%915-%E5%BD%A9%E8%89%B2%E7%AB%8B%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"><![CDATA[参考教程【中文版】第四课：彩色立方体 【英文版】Tutorial 4 : A Colored Cube &emsp;&emsp;在之前的几篇笔记中，最后的结果仅仅只是画出来一个三角形，但是真实的计算机图形怎么可能是一个三角形可以概括的。在仅支持Draw Triangle的OpenGL里，我们将学着使用三角形去构造出复杂的图形等等。在这篇笔记中，主要学会使用12个三角形去构造一个正立方体。 &emsp;&emsp;我们都知道，正立方体有6个正方形面，每个面可以用两个三角形拼出来（事实上我们画立方体外部摄像视角的静态实体时是用不到那么多三角形的，因为有一部分属于摄像机盲区），总共需要12个三角形。在这里，我们给出12个三角形的顶点数据。 12345678910111213141516171819202122232425262728293031323334353637383940// Our vertices. Tree consecutive floats give a 3D vertex; Three consecutive vertices give a triangle.// A cube has 6 faces with 2 triangles each, so this makes 6*2=12 triangles, and 12*3 vertices static const GLfloat g_vertex_buffer_data[] = &#123; -1.0f,-1.0f,-1.0f, -1.0f,-1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f, -1.0f,-1.0f,-1.0f, -1.0f, 1.0f,-1.0f, 1.0f,-1.0f, 1.0f, -1.0f,-1.0f,-1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,-1.0f, 1.0f,-1.0f,-1.0f, -1.0f,-1.0f,-1.0f, -1.0f,-1.0f,-1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f,-1.0f, 1.0f,-1.0f, 1.0f, -1.0f,-1.0f, 1.0f, -1.0f,-1.0f,-1.0f, -1.0f, 1.0f, 1.0f, -1.0f,-1.0f, 1.0f, 1.0f,-1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,-1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,-1.0f, -1.0f, 1.0f,-1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f,-1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f,-1.0f, 1.0f &#125;; &emsp;&emsp;而具体的立方体画图过程，则是和画三角形差不多，给予每个三角形不同的颜色，就可以完成立方体的构造。 &emsp;&emsp;而在这里，我们需要引入一个新的概念观察视角（摄像机视角），在我所学习的教程的前一章，详细的介绍了这些概念以及矩阵的一些基本运算和矩阵运算在OpenGL中和GLSL的操作 第三课：矩阵 &emsp;&emsp;对于OpenGL中的Buffer缓冲，在之前的学习中也都学过，这里不再描述。唯一与之前不同的是我们这次画的是12个三角形，所以在glDrawArrays(GL_TRIANGLES, 0, 12*3);的时候需要将之前的3改为12*3。此时应该有如下效果：（黑色立方体） &emsp;&emsp;下一步则是需要对这一坨黑色的东西进行着色。在这里我们使用在OpenGL代码里定义顶点数组，然后使用顶点着色器程序进行读取，并传入到片段着色器中进行着色的方式。首先定义顶点数组。 123456789101112131415161718192021222324252627282930313233343536373839// One color for each vertex. They were generated randomly.static const GLfloat g_color_buffer_data[] = &#123; 0.583f, 0.771f, 0.014f, 0.609f, 0.115f, 0.436f, 0.327f, 0.483f, 0.844f, 0.822f, 0.569f, 0.201f, 0.435f, 0.602f, 0.223f, 0.310f, 0.747f, 0.185f, 0.597f, 0.770f, 0.761f, 0.559f, 0.436f, 0.730f, 0.359f, 0.583f, 0.152f, 0.483f, 0.596f, 0.789f, 0.559f, 0.861f, 0.639f, 0.195f, 0.548f, 0.859f, 0.014f, 0.184f, 0.576f, 0.771f, 0.328f, 0.970f, 0.406f, 0.615f, 0.116f, 0.676f, 0.977f, 0.133f, 0.971f, 0.572f, 0.833f, 0.140f, 0.616f, 0.489f, 0.997f, 0.513f, 0.064f, 0.945f, 0.719f, 0.592f, 0.543f, 0.021f, 0.978f, 0.279f, 0.317f, 0.505f, 0.167f, 0.620f, 0.077f, 0.347f, 0.857f, 0.137f, 0.055f, 0.953f, 0.042f, 0.714f, 0.505f, 0.345f, 0.783f, 0.290f, 0.734f, 0.722f, 0.645f, 0.174f, 0.302f, 0.455f, 0.848f, 0.225f, 0.587f, 0.040f, 0.517f, 0.713f, 0.338f, 0.053f, 0.959f, 0.120f, 0.393f, 0.621f, 0.362f, 0.673f, 0.211f, 0.457f, 0.820f, 0.883f, 0.371f, 0.982f, 0.099f, 0.879f&#125;; &emsp;&emsp;这个和顶点数组是一样的，具体数字都是随便写进去的，你愿意的话全是0.0f也可以（不过还是黑色）。然后缓冲的绑定也是和之前一样。 123456789101112GLuint colorbuffer;glGenBuffers(1, &amp;colorbuffer);glBindBuffer(GL_ARRAY_BUFFER, colorbuffer);glBufferData(GL_ARRAY_BUFFER, sizeof(g_color_buffer_data), g_color_buffer_data, GL_STATIC_DRAW);glVertexAttribPointer( 1, // attribute. No particular reason for 1, but must match the layout in the shader. 3, // size GL_FLOAT, // type GL_FALSE, // normalized? 0, // stride (void*)0 // array buffer offset ); &emsp;&emsp;这时候你应该可以看到这样一个结果： &emsp;&emsp;搞定！ &emsp;&emsp;Github地址]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min-Cost-Climbing-Stairs]]></title>
    <url>%2F2018%2F01%2F21%2FMin-Cost-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#746 Min Cost Climbing Stairs 题目描述On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: 123Input: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: 123Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. 解题思路&emsp;&emsp;这种全局最优解的题要么递归要么动态规划，这道题递归超时，动态规划可以直接解。 解题代码【.CPP】12345678910111213class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int size = static_cast&lt;int&gt;(cost.size()); vector&lt;int&gt; dp(size,0); dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; size; ++i) &#123; dp[i] = cost[i] + min(dp[i-1] , dp[i-2]); &#125; return min(dp[size-1],dp[size-2]); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Largest-Number-At-Least-Twice-of-Others]]></title>
    <url>%2F2018%2F01%2F20%2FLargest-Number-At-Least-Twice-of-Others%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#747 Largest Number At Least Twice of Others 题目描述In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: 1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. Example 2: 123Input: nums = [1, 2, 3, 4]Output: -1Explanation: 4 isn&apos;t at least as big as twice the value of 3, so we return -1. Note: nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99]. 解题思路&emsp;&emsp;题目要求是找出数组里满足是最大数且至少是其他数字的两倍的数字，返回其索引，如果没有就返回-1。我们通过一次遍历找出数组的最大值和次大值，然后判断最大值是不是次大值得两倍或者更多，是的话返回最大值索引，不是返回-1。 解题代码【.CPP】1234567891011121314151617class Solution &#123;public: int dominantIndex(vector&lt;int&gt;&amp; nums) &#123; int ldx = 0 , sdx = -1; for (int i = 1; i &lt; nums.size(); ++i) &#123; if(nums[i] &gt; nums[ldx])&#123; sdx = ldx; ldx = i; &#125; else &#123; if(sdx == -1 || nums[i] &gt; nums[sdx]) &#123; sdx = i; &#125; &#125; &#125; return nums[ldx] &gt;= nums[sdx] * 2 ? ldx : -1; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Employee-Free-Time]]></title>
    <url>%2F2018%2F01%2F19%2FEmployee-Free-Time%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#759 Employee Free Time 题目描述We are given a list schedule of employees, which represents the working time for each employee. Each employee has a list of non-overlapping Intervals, and these intervals are in sorted order. Return the list of finite intervals representing common, positive-length free time for all employees, also in sorted order. Example 1: 123456Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]Output: [[3,4]]Explanation:There are a total of three employees, and all commonfree time intervals would be [-inf, 1], [3, 4], [10, inf].We discard any intervals that contain inf as they aren&apos;t finite. Example 2: 12Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]Output: [[5,6],[7,9]] (Even though we are representing Intervals in the form [x, y], the objects inside are Intervals, not lists or arrays. For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and schedule[0][0][0] is not defined.) Also, we wouldn’t include intervals like [5, 5] in our answer, as they have zero length. Note: schedule and schedule[i] are lists with lengths in range [1, 50]. 0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8. 解题思路&emsp;&emsp;这道题是给你多个员工的工作时间表，需要得到所有员工的共同休息时间，每个员工的时间表包括一个或多个[Start Time : End Time]这种组合，即代表在Start Time -&gt; End Time这段时间是工作的。这道题可以先求出每个员工的休息时间，然后找出公共时间，也可以将所有的[Start Time : End Time]放到一个数组里，假想他们是一个员工的工作时间，这样问题变成了求一个员工的休息时间。 &emsp;&emsp;每个[Start Time : End Time]都是一个时间段，我们需要找出数组里所有时间段不包括的时间，即数组里如果有[3,4]和[5,6]两个时间段，则有[-inf,3],[4-5]和[6,inf]是除去他们之后的时间段，由于 We discard any intervals that contain inf as they aren’t finite. 所以只剩下[4,5]。而具体求法很简单，我们将所有的时间段根据开始时间从小到大排序，然后维持一个变量End作为当前时间段的结束时间。然后遍历我们刚才得到的时间段数组，如果其中时间段N的开始时间小于End，说明这个时间段N与我们当前的时间段是相交的，这时候我们更新End为当前End和N.End中较大的一个，如果N的开始时间大于End，说明这两个时间段不相交，那么[End , N.Start]就是我们要求的空闲时间段之一，此时更新End为N.End。 解题代码【.CPP】123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; employeeFreeTime(vector&lt;vector&lt;Interval&gt;&gt;&amp; schedule) &#123; vector&lt;Interval&gt; allInterval(0); for (auto em : schedule)&#123; for (auto e : em)&#123; allInterval.push_back(e); &#125; &#125; sort(allInterval.begin(),allInterval.end() , [](Interval a , Interval b) &#123; return a.start &lt; b.start; &#125;); vector&lt;Interval&gt; ret(0); if(allInterval.empty()) return ret; int end = allInterval[0].end; for (auto ins : allInterval)&#123; if(ins.start &lt;= end) end = max(end , ins.end); else &#123; ret.emplace_back(end,ins.start); end = ins.end; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prime-Number-of-Set-Bits-in-Binary-Representation]]></title>
    <url>%2F2018%2F01%2F18%2FPrime-Number-of-Set-Bits-in-Binary-Representation%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#762 Prime Number of Set Bits in Binary Representation 题目描述&emsp;&emsp;Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation. (Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits. Also, 1 is not a prime.) Example 1: 1234567Input: L = 6, R = 10Output: 4Explanation:6 -&gt; 110 (2 set bits, 2 is prime)7 -&gt; 111 (3 set bits, 3 is prime)9 -&gt; 1001 (2 set bits , 2 is prime)10-&gt;1010 (2 set bits , 2 is prime) Example 2: 123456789Input: L = 10, R = 15Output: 5Explanation:10 -&gt; 1010 (2 set bits, 2 is prime)11 -&gt; 1011 (3 set bits, 3 is prime)12 -&gt; 1100 (2 set bits, 2 is prime)13 -&gt; 1101 (3 set bits, 3 is prime)14 -&gt; 1110 (3 set bits, 3 is prime)15 -&gt; 1111 (4 set bits, 4 is not prime) Note: L, R will be integers L &lt;= R in the range [1, 10^6]. R - L will be at most 10000. 解题思路&emsp;&emsp;这道题是找出在一定范围内的符合他的二进制里有素数个1的数字，唯一需要考虑的是如何求出一个数字的二进制里有多少个1这个问题，直接看代码吧。 解题代码【.CPP】12345678910111213141516171819202122class Solution &#123; bool isPrimeNumberOfSetBitsInBinaryRepresentation(int n)&#123; int c = 0; while(n &gt; 0)&#123; if((n &amp; 1) == 1) c++; n = n &gt;&gt; 1; &#125; if(c &lt; 2) return false; for (int i = 2; i &lt; c; ++i) &#123; if(c % i == 0) return false; &#125; return true; &#125;public: int countPrimeSetBits(int L, int R) &#123; int ret = 0; for (int i = L; i &lt;= R; ++i) &#123; ret += isPrimeNumberOfSetBitsInBinaryRepresentation(i); &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Partition-Labels]]></title>
    <url>%2F2018%2F01%2F17%2FPartition-Labels%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#763 Partition Labels 题目描述&emsp;&emsp;A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts. Example 1: 123456Input: S = &quot;ababcbacadefegdehijhklij&quot;Output: [9,7,8]Explanation:The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.This is a partition so that each letter appears in at most one part.A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts. Note: S will have length in range [1, 500]. S will consist of lowercase letters (&#39;a&#39; to &#39;z&#39;) only. 解题思路&emsp;&emsp;这道题是求分割这个字符串使得每一组的字符不出现在其他组中，且分割次数最多。 &emsp;&emsp;我在网上看到有的使用DP，但是有一个比较好的思路（最后发现这个思路有很多人用了，和我的只有小部分不同）。就是说我们记录下每个字符第一次出现的位置和最后一次出现的位置（比如a第一次出现在0，第二次出现在10，那么0和10肯定在一组里边），将其按照第一次出现的顺序进行排序。这样我们将第一个字母的首尾位置作为一组，如果其他字符第一次出现的位置在这个组里，我们更新这一组的尾（更新为较大的一个）。如果其他字符第一次出现的位置不在这个组（就是说大于这个组的尾位置），说明他是新的一组，记下其尾位置作为下一组的位置，看代码吧。 解题代码【.CPP】1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; partitionLabels(string S) &#123; vector&lt;pair&lt;int,int&gt;&gt; cp(26 , pair&lt;int,int&gt;(S.size() + 1,S.size() + 1)); for (int i = 0; i &lt; S.size(); ++i) &#123; cp[S[i]-'a'].second = i + 1; &#125; for (int i = static_cast&lt;int&gt;(S.size() - 1); i &gt;= 0; --i) &#123; cp[S[i]-'a'].first = i + 1; &#125; sort(cp.begin() , cp.end()); vector&lt;int&gt; res(0); int start = 0; for (int i = 0; i &lt; cp.size(); ++i) &#123; if(cp[i].first == S.size() + 1 || cp[i].second == S.size() + 1)&#123; continue; &#125; if(res.empty()) res.push_back(cp[i].second); if(cp[i].first &lt; res[res.size()-1] + start)&#123; if(cp[i].second &gt; res[res.size()-1] + start) res[res.size()-1] = cp[i].second - start; &#125; if(cp[i].first &gt; res[res.size()-1] + start) &#123; start += res[res.size()-1]; res.push_back(cp[i].second - start); &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find-Smallest-Letter-Greater-Than-Target]]></title>
    <url>%2F2018%2F01%2F12%2FFind-Smallest-Letter-Greater-Than-Target%2F</url>
    <content type="text"><![CDATA[题目地址LeetCode#744 Find Smallest Letter Greater Than Target 题目描述&emsp;&emsp;Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. &emsp;&emsp;Letters also wrap around. For example, if the target is target = &#39;z&#39; and letters = [&#39;a&#39;, &#39;b&#39;], the answer is &#39;a&#39;. Examples: 1234567891011121314151617181920212223242526272829Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;a&quot;Output: &quot;c&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;c&quot;Output: &quot;f&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;Output: &quot;f&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;g&quot;Output: &quot;j&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;j&quot;Output: &quot;c&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;k&quot;Output: &quot;c&quot; Note: letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter. 解题思路&emsp;&emsp;题目给的数组是已经排好序的，所以我们连排序都不用，直接遍历一遍，找到比target大的就可以赋值并且终止循环直接输出了，由于题目中说明了 Letters also wrap around. For example, if the target is target = &#39;z&#39; and letters = [&#39;a&#39;, &#39;b&#39;], the answer is &#39;a&#39;。 &emsp;&emsp;就是说如果没有比他大的，我们返回第一个值就可以了。所以我们将res的初始值就设置为数组的第一个值，这样遍历一遍后无论是否找到，res都是正确的值。 解题代码【.CPP】12345678910111213class Solution &#123;public: char nextGreatestLetter(vector&lt;char&gt; &amp;letters, char target) &#123; char res = letters[0]; for (auto r : letters) &#123; if (r &gt; target) &#123; res = r; break; &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML图学习链接]]></title>
    <url>%2F2018%2F01%2F11%2FUML%E5%9B%BE%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[类图UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合） 包图包图（命名空间） 对象图UML 对象图 object diagram 构件图UML 构件图（组件图） 部署图UML建模之部署图（Deployment Diagram） 顺序图UML建模之时序图（Sequence Diagram） 活动图UML建模之活动图介绍（Activity Diagram） 状态图UML建模之状态图（Statechart Diagram） 协作图【UML 建模】UML入门 之 交互图 — 时序图 协作图详解]]></content>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML概念]]></title>
    <url>%2F2018%2F01%2F11%2FUML%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[UML概念 UML的动态模型图由活动图、顺序图、状态图和协作图组成。 UML的需求分析产生的用例模型描述了系统的功能模型。 部署图表示的是如何将具体软件制品分配到计算机节点上。 UML的五种静态模型图是类图、对象图、包图、组件图和部署图。 状态图是活动图的一个特例，状态图中的多数状态是活动状态。 构件（组件）是系统遵从一组接口且提供实现的一个物理部件，通常指开发和运行时的物理实现。 对象间的可见性是指一个对象能够“看到”或者引用另一个对象的能力。 领域模型是一组表示真实世界的概念类，在设计工作中广泛用来启发设计软件对象。 统一过程（UP）的四个阶段：初始阶段，细化阶段，构造阶段，提交阶段。 统一过程中的核心工作流有业务建模，需求分析，设计，实现，测试。 定义大多数的需求和范围的工作是在UP中的细化阶段完成的。 UP的各个阶段完成的内容： 初始阶段：编制简单愿景文档，业务案例，确定范围，粗略评估成败。 细化阶段：细化愿景文档，迭代的实现核心架构，解决高风险的问题，定义大多数的需求和范围，进一 步评估成本。 构造阶段：迭代的实现系统的其余部分，准备部署。 提交阶段：beta测试，部署。 领域模型是一组表示真实世界的概念类，不是软件部件的模型。 在协作图中通过消息编号表示出消息的时间顺序。 在画SSD图（系统顺序图）时，应该不对所涉及的系统的内部结构与功能进行描述。 UP的核心思想：短时间盒的迭代式开发，开发过程中不断进行调整，在早期的迭代中解决高风险和高价值的 主要问题，不断与用户衔接，及时得到反馈意见，早期进入实现和测试，不断进行质量检验，使用情况，仔细的管理需求，控制变更。 增量模型：对复杂的用例分多次迭代，一部分一部分的实现、将所有用例按其优先级分别安排在不同的迭代中实现。 领域建模的步骤：列出候选的概念类、画出领域模型图、必要时加入概念类间的关联、必要时加入概念类的属性。 UML体系包括三个部分：UML基本构造块，UML规则和UML公共机制，组成UML有三种基本的构造块是关系，事务和图。 UML的事物包括：结构事物，分组事物，注释事物和动作事物。 瀑布模型的缺点是缺乏灵活性，特别是无法解决软件需求不明确的或不准确的问题。 UML静态视图是类图，包图，对象图。 类通常可以分为实体类，控制类，边界类。 对反应型对象建模一般使用状态图。 顺序图由类角色，生命线，激活期和消息组成。 泳道技术是将一个活动图中的活动状态进行分组，每一组表示一个特定的类，人或部门，他们负责完成组内的活动。 事件表示对一个在时间和空间上占据一定位置的有意义的事情的规格说明（例：信号，调用事件，时间事务） 接口是一组用来描述类或者组件的一个服务的操作 包是用于把元素组织成组的通用机制。 正向工程是通过到实现语言的映射而把模型转换为代码的过程。 逆向工程是通过从特定实现语言的映射而把模型转换为代码的过程。 事件可以分为内部事件和外部事件，按下按钮盒打印机的中断时外部事件。 软件构件是可复用的，提供明确接口完成特定功能的程序代码块。 若将活动状态比作方法，那么动作状态即为方法体重的每一条语句。 一个对象和另一个对象之间通过消息来通信，消息通信在面向对象语言中即为方法调用。 瀑布模型的生存周期是计划，需求分析，设计，编码，测试，运行/维护。 UML中对象行为是通过交互来实现的，是对象间为完成某一目的而进行的一系列消息交换，消息序列可用两种类来表示，分别是顺序图和协作图。 用例用来描述系统在事件作出响应时采用的行动，用例事件是具有相关性的，在一个“订单输入子系统”中，创建新订单和更新订单都需要检查用户账号是否正确，那么用例“创建订单”，“更新订单”与用例“检查用户账号”之间是包含关系。 组件图用于对系统的静态实现视图建模，这种视图主要支持系统部件的配置管理，通常分为四种方式来完成，对源代码建模，对物理数据库建模，对可适应的系统建模。 UML提供一系列的图支持面向对象的分析与设计，其中 类图给出系统的静态设计视图 用例图对系统的行为进行组织和建模 序列图和协作图描述系统动态视图的交互图 序列图描述了以时间为顺序组织的对象之间的交互活动 协作图强调收发消息的对象组织结构 软件开发周期是指软件产品从考虑其概念开始，到该产品交付使用为止的整个时期，一般包括概念阶段，需求阶段，设计阶段，实现阶段，测试阶段，安装阶段及交付阶段。这些阶段可以有重复，执行时也可以自由迭代。]]></content>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Self-Dividing-Numbers]]></title>
    <url>%2F2018%2F01%2F11%2FSelf-Dividing-Numbers%2F</url>
    <content type="text"><![CDATA[题目地址 LeetCode#728 Self Dividing Numbers 题目描述&emsp;&emsp;A self-dividing number is a number that is divisible by every digit it contains. &emsp;&emsp;For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. &emsp;&emsp;Also, a self-dividing number is not allowed to contain the digit zero. &emsp;&emsp;Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible. Example 1: 123Input: left = 1, right = 22Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] Note: &emsp;&emsp;The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000. 解题思路&emsp;&emsp;Easy题，唯一需要考虑的就是如何判断一个数字是不是self-dividing number，题目上说的很清楚，能够整除他每一位上的数字的数字是self-dividing number，那就直接提出来计算就可以了，看代码吧。 解题代码【.CPP】123456789101112131415161718192021class Solution &#123; bool isSelfDividingNumber(int number)&#123; bool res = true; int tol = number; while (tol &gt; 0 &amp;&amp; res)&#123; int tmp = tol % 10; res = tmp &amp;&amp; (number % tmp == 0); tol = tol / 10; &#125; return res; &#125;public: vector&lt;int&gt; selfDividingNumbers(int left, int right) &#123; vector&lt;int&gt; res; for (int i = left; i &lt;= right; ++i) &#123; if(isSelfDividingNumber(i)) res.push_back(i); &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find-Anagram-Mappings]]></title>
    <url>%2F2018%2F01%2F10%2FFind-Anagram-Mappings%2F</url>
    <content type="text"><![CDATA[LeetCode#760 Find Anagram Mappings Given two lists Aand B, and B is an anagram of A. B is an anagram of A means B is made by randomizing the order of the elements in A. We want to find an index mapping P, from A to B. A mapping P[i] = j means the ith element in A appears in B at index j. These lists A and B may contain duplicates. If there are multiple answers, output any of them. For example, given 12A = [12, 28, 46, 32, 50]B = [50, 12, 32, 46, 28] We should return[1, 4, 3, 2, 0]as P[0] = 1 because the 0th element of A appears at B[1], and P[1] = 4 because the 1st element of A appears at B[4], and so on. Note: A, B have equal lengths in range [1, 100]. A[i], B[i] are integers in range [0, 10^5]. 解题思路&emsp;&emsp;起初我以为是找到第一个数组里的数字在第二个数组里的索引，考虑到These lists A and B may contain duplicates. 这句话，我还是用了一个数组保存这个值是否已经取过来保证结果集里不出现重复的索引。然而我想多了，这道题仅仅是让你二重循环一下。看代码吧 解题代码【.CPP】1234567891011121314class Solution &#123;public: vector&lt;int&gt; anagramMappings(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; vector&lt;int&gt; res(A.size()); for (int i = 0; i &lt; A.size(); ++i) &#123; for (int j = 0; j &lt; B.size(); ++j) &#123; if(B[j] == A[i])&#123; res[i] = j; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shopping-Offers]]></title>
    <url>%2F2018%2F01%2F09%2FShopping-Offers%2F</url>
    <content type="text"><![CDATA[LeetCode#638 Shopping Offers &emsp;&emsp;In LeetCode Store, there are some kinds of items to sell. Each item has a price. &emsp;&emsp;However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. &emsp;&emsp;You are given the each item’s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. &emsp;&emsp;Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer. &emsp;&emsp;You could use any of special offers as many times as you want. Example 1: 1234567Input: [2,5], [[3,0,5],[1,2,10]], [3,2]Output: 14Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. In special offer 1, you can pay $5 for 3A and 0BIn special offer 2, you can pay $10 for 1A and 2B. You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. Example 2: 1234567Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]Output: 11Explanation: The price of A is $2, and $3 for B, $4 for C. You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. You cannot add more items, though only $9 for 2A ,2B and 1C. Note: There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price. 解题思路&emsp;&emsp;这道题的题目意思是，给了我们商品单价，和一些优惠券（优惠券的格式是前N个数字代表第N个商品有几个，最后一个数字是总价钱），就是说给了我们单价和打包价格，然后还给了我们需要买的每个商品的个数。让我们找到一个最优解，即买到需要的商品花费的最少钱数。 &emsp;&emsp;这里我们首先以不使用优惠券所花费的钱数作为初始值，然后对所有优惠券做一个递归，最后更新结果（res）的值就可以了。看代码吧 解题代码【.CPP】123456789101112131415161718192021222324252627282930313233343536class Solution &#123; void recvShopping(vector&lt;int&gt;&amp; price, const vector&lt;vector&lt;int&gt;&gt; special , vector&lt;int&gt; needs , int cut , int&amp; res)&#123; for (int i = 0; i &lt; special.size(); ++i) &#123; bool isValid = true; for (int j = 0; j &lt; special[i].size() - 1; ++j) &#123; if(isValid &amp;&amp; special[i][j] &gt; needs[j]) isValid = false; &#125; if(isValid)&#123; vector&lt;int&gt; tmpNeeds = needs; int tmpCut = cut; for (int j = 0; j &lt; special[i].size()-1; ++j) &#123; needs[j] -= special[i][j]; &#125; cut += special[i][special[i].size()-1]; recvShopping(price, special , needs , cut , res); needs = tmpNeeds; cut = tmpCut; &#125; &#125; for (int i = 0; i &lt; needs.size(); ++i) &#123; cut += needs[i] * price[i]; &#125; res = min(res , cut); &#125;public: int shoppingOffers(vector&lt;int&gt;&amp; price, vector&lt;vector&lt;int&gt;&gt;&amp; special, vector&lt;int&gt;&amp; needs) &#123; int res = 0; for (int i = 0; i &lt; price.size(); ++i) &#123; res += price[i] * needs[i]; &#125; recvShopping(price , special , needs , 0 , res); return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest-Word-in-Dictionary-through-Deleting]]></title>
    <url>%2F2018%2F01%2F07%2FLongest-Word-in-Dictionary-through-Deleting%2F</url>
    <content type="text"><![CDATA[LeetCode#524 Longest Word in Dictionary through Deleting &emsp;&emsp;Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. Example 1: 12345Input:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]Output: &quot;apple&quot; Example 2: 12345Input:s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]Output: &quot;a&quot; Note: All the strings in the input will only contain lower-case letters. The size of the dictionary won’t exceed 1,000. The length of all the strings in the input won’t exceed 1,000. 解题思路&emsp;&emsp;先将字典按照字符串长度（如果长度一样就按照字母大小排序）排序，然后挨个遍历。直接看代码吧 解题代码【.CPP】123456789101112131415161718192021class Solution &#123;public: string findLongestWord(string s, vector&lt;string&gt; &amp;d) &#123; sort(d.begin(), d.end(), [](string a, string b) &#123; if (a.size() &gt; b.size()) return true; if (a.size() == b.size()) return a &lt; b; return false; &#125;); for (auto str : d) &#123; int idx = 0; for (auto ch : s)&#123; if(ch == str[idx]) idx++; if(idx == str.size()) return str; &#125; &#125; return ""; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse-String-II]]></title>
    <url>%2F2018%2F01%2F06%2FReverse-String-II%2F</url>
    <content type="text"><![CDATA[LeetCode#541 Reverse String II &emsp;&emsp;Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. Example: 12Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; Restrictions: The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000] 解题思路&emsp;&emsp;题目是给出一个字符串，再给出一个值k，让我们将k个数字为一组进行翻转。但是是将0-k，2k-3k，…。就是说将字符串K个数字分为一组，第一组翻转，第二组保持，第三组翻转，第四组保持这样。用一个循环就可以解决了，很简单的题。 解题代码【.CPP】1234567891011121314151617class Solution &#123;public: string reverseStr(string s, int k) &#123; int idx = 0 ; string::iterator it = s.begin(); while (idx &lt; s.size())&#123; if(idx + k &gt; s.size())&#123; reverse(it , it + s.size() - idx); &#125; else &#123; reverse(it , it+k); &#125; idx += 2*k; it += 2*k; &#125; return s; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Target-Sum]]></title>
    <url>%2F2018%2F01%2F05%2FTarget-Sum%2F</url>
    <content type="text"><![CDATA[LeetCode#494 Target Sum &emsp;&emsp;You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. &emsp;&emsp;Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: 1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 解题思路&emsp;&emsp;这道题是需要用数组里的所有数字经过+或者-的运算后得到所要求的数字。用一个DFS递归完所有可能性，满足情况的给结果加一就可以了。 解题代码【.CPP】12345678910111213141516class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt; &amp;nums, int S) &#123; int res = 0; findWays(nums, S, 0, res); return res; &#125; void findWays(vector&lt;int&gt;&amp; atoms, int target, int dep, int &amp;res) &#123; if (dep &gt;= atoms.size()) &#123; if(target == 0) ++res; return; &#125; findWays(atoms, target - atoms[dep], dep + 1, res); findWays(atoms, target + atoms[dep], dep + 1, res); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find-The-Duplicate-Number]]></title>
    <url>%2F2018%2F01%2F01%2FFind-The-Duplicate-Number%2F</url>
    <content type="text"><![CDATA[LeetCode#287 Find the Duplicate Number &emsp;&emsp;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. 解题思路&emsp;&emsp;这道题是可以用二分法进行查找的，即找到Mid，然后如果大于mid的数字的个数大于小于mid的数字的个数，就说明重复的数字出现在大于mid的部分。反之出现在小于mid的部分。如果相等，则输出Mid。 &emsp;&emsp;但是这里有一个很精妙的解法。我也是看别人的，假设数组中没有重复，那我们可以做到这么一点，就是将数组的下标和1到n每一个数一对一的映射起来。比如数组是213,则映射关系为0-&gt;2, 1-&gt;1, 2-&gt;3。假设这个一对一映射关系是一个函数f(n)，其中n是下标，f(n)是映射到的数。如果我们从下标为0出发，根据这个函数计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。实际上可以产生一个类似链表一样的序列。比如在这个例子中有两个下标的序列，0-&gt;2-&gt;3。 &emsp;&emsp;但如果有重复的话，这中间就会产生多对一的映射，比如数组2131,则映射关系为0-&gt;2, {1，3}-&gt;1, 2-&gt;3。这样，我们推演的序列就一定会有环路了，这里下标的序列是0-&gt;2-&gt;3-&gt;1-&gt;1-&gt;1-&gt;1-&gt;...，而环的起点就是重复的数。 &emsp;&emsp;所以该题实际上就是找环路起点的题，和Linked List Cycle II一样。我们先用快慢两个下标都从0开始，快下标每轮映射两次，慢下标每轮映射一次，直到两个下标再次相同。这时候保持慢下标位置不变，再用一个新的下标从0开始，这两个下标都继续每轮映射一次，当这两个下标相遇时，就是环的起点，也就是重复的数。对这个找环起点算法不懂的，请参考Floyd’s Algorithm。 解题代码【.CPP】123456789101112131415161718public class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow = 0; int fast = 0; // 找到快慢指针相遇的地方 do&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; while(slow != fast); int find = 0; // 用一个新指针从头开始，直到和慢指针相遇 while(find != slow)&#123; slow = nums[slow]; find = nums[find]; &#125; return find; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base7]]></title>
    <url>%2F2017%2F12%2F30%2FBase7%2F</url>
    <content type="text"><![CDATA[LeetCode#504 Base7 &emsp;&emsp;Given an integer, return its base 7 string representation. Example 1: 12Input: 100Output: "202" Example 2: 12Input: -7Output: "-10" Note: The input will be in range of [-1e7, 1e7]. 解题思路&emsp;&emsp;一道很简单的题，将十进制转换为7进制，只需要用输入数字不断除7，直到输入数字小于7为止，每次除的余数从低位到高位保存就是结果。直接看代码吧 解题代码【.CPP】123456789101112131415class Solution &#123;public: string convertToBase7(int num) &#123; bool isMinus = num &lt; 0; num = abs(num); string ret = ""; while (num &gt;= 7) &#123; ret = to_string(num % 7) + ret; num = num / 7; &#125; ret = to_string(num) + ret; if (isMinus) ret = "-" + ret; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Random-Pick-Index]]></title>
    <url>%2F2017%2F12%2F29%2FRandom-Pick-Index%2F</url>
    <content type="text"><![CDATA[LeetCode#398 Random Pick Index &emsp;&emsp;Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note:&emsp;&emsp;The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: 12345678int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); 解题思路&emsp;&emsp;本来想在构造方法里建表的，但是note里说了 Solution that uses too much extra space will not pass the judge. &emsp;&emsp;只好每个都算一遍了，Solution里把传进来的数组存到类的类成员里，然后在pick方法里遍历数组，并把target出现的位置索引都记下来，随机输出一个就OK了 解题代码【.CPP】123456789101112131415161718192021class Solution &#123; vector&lt;int&gt; _nums;public: Solution(vector&lt;int&gt; nums) &#123; _nums = move(nums); &#125; int pick(int target) &#123; vector&lt;int&gt; idxs(0); for (int i = 0; i &lt; _nums.size(); ++i) &#123; if(target == _nums[i]) idxs.push_back(i); &#125; return idxs[rand() % idxs.size()]; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int param_1 = obj.pick(target); */]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House-Robber-III]]></title>
    <url>%2F2017%2F12%2F28%2FHouse-Robber-III%2F</url>
    <content type="text"><![CDATA[LeetCode# House Robber III &emsp;&emsp;The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: 12345 3 / \2 3 \ \ 3 1 Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: 12345 3 / \ 4 5 / \ \ 1 3 1 Maximum amount of money the thief can rob = 4+5 = 9. 解题思路&emsp;&emsp;这个比较精妙的解法由网友edyyy提供，这里的helper函数返回当前结点为根结点的最大rob的钱数，里面的两个参数l和r表示分别从左子结点和右子结点开始rob，分别能获得的最大钱数。在递归函数里面，如果当前结点不存在，直接返回0。否则我们对左右子结点分别调用递归函数，得到l和r。另外还得到四个变量，ll和lr表示左子结点的左右子结点的最大rob钱数，rl和rr表示右子结点的最大rob钱数。那么我们最后返回的值其实是两部分的值比较，其中一部分的值是当前的结点值加上ll, lr, rl, 和rr这四个值，这不难理解，因为抢了当前的房屋，那么左右两个子结点就不能再抢了，但是再下一层的四个子结点都是可以抢的；另一部分是不抢当前房屋，而是抢其左右两个子结点，即l+r的值，返回两个部分的值中的较大值即可，参见代码如下： 解题代码【.CPP】123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int rob(TreeNode* root) &#123; int l = 0, r = 0; return helper(root, l, r); &#125;private: int helper(TreeNode* node, int&amp; l, int&amp; r) &#123; if (!node) return 0; int ll = 0, lr = 0, rl = 0, rr = 0; l = helper(node-&gt;left, ll, lr); r = helper(node-&gt;right, rl, rr); return max(node-&gt;val + ll + lr + rl + rr, l + r); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odd-Even-Linked-List]]></title>
    <url>%2F2017%2F12%2F26%2FOdd-Even-Linked-List%2F</url>
    <content type="text"><![CDATA[LeetCode#328 Odd Even Linked List &emsp;&emsp;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note:The relative order inside both the even and odd groups should remain as it was in the input.The first node is considered odd, the second node even and so on … 解题思路&emsp;&emsp;这道题的意思是把所有奇数位的数字移到所有偶数位数字前边（是索引奇数位偶数位的不是奇数数字偶数数字）。我们使用两个指针，一个指向当前奇数位，一个指向偶数，然后遍历链表，并将偶数指针的下一个元素移到奇数指针的后边就可以了。 解题思路【.CPP】12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123; void addNode(ListNode *a, ListNode *b) &#123; //把b的后边加到a后边 ListNode *tmp = b-&gt;next; b-&gt;next = tmp-&gt;next; tmp-&gt;next = a-&gt;next; a-&gt;next = tmp; &#125;public: ListNode *oddEvenList(ListNode *head) &#123; if(!head || !head-&gt;next || !head-&gt;next-&gt;next) return head; ListNode *odd = head; ListNode *even = head-&gt;next; while (odd &amp;&amp; even)&#123; if(even-&gt;next) addNode(odd , even); odd = odd-&gt;next; even = even-&gt;next; &#125; return head; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Student-Attendance-Record-I]]></title>
    <url>%2F2017%2F12%2F24%2FStudent-Attendance-Record-I%2F</url>
    <content type="text"><![CDATA[LeetCode#551 Student Attendance Record I &emsp;&emsp;You are given a string representing an attendance record for a student. The record only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present. A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). You need to return whether the student could be rewarded according to his attendance record. Example 1: 12Input: &quot;PPALLP&quot;Output: True Example 2: 12Input: &quot;PPALLL&quot;Output: False 解题思路&emsp;&emsp;Easy题，意思是给你一串字母A代表旷课，L代表迟到，P代表正常在场。如果旷课超过一次或者连续迟到超过两次就给挂掉。只需要一次遍历找出旷课次数和最大连续迟到次数，然后按情况返回就可以了。 解题代码【.CPP】12345678910111213141516class Solution &#123;public: bool checkRecord(string s) &#123; int aCount = 0 , lCount = 0 , maxLCount = 0; for(auto r : s)&#123; if(r == 'L') ++lCount; else &#123; if(lCount &gt; maxLCount) maxLCount = lCount; lCount = 0; if(r == 'A') ++aCount; &#125; if(aCount &gt; 1 || maxLCount &gt; 2) return false; &#125; return lCount &lt;= 2; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Delete-Operation-for-Two-Strings]]></title>
    <url>%2F2017%2F12%2F23%2FDelete-Operation-for-Two-Strings%2F</url>
    <content type="text"><![CDATA[LeetCode#583 Delete Operation for Two Strings &emsp;&emsp;Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example 1: 123Input: &quot;sea&quot;, &quot;eat&quot;Output: 2Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;. Note: The length of given words won’t exceed 500. Characters in given words can only be lower-case letters. 解题思路&emsp;&emsp;要求他删除最少的字符使得这两个字符串相等。我们可以找到这个字符串最大的相同串。然后用两个字符串长度减去相同串长度*2。 解题代码【.CPP】1234567891011121314151617class Solution &#123;public: int minDistance(string word1, string word2) &#123; int n1 = word1.size(), n2 = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n1 + 1, vector&lt;int&gt;(n2 + 1, 0)); for (int i = 1; i &lt;= n1; ++i) &#123; for (int j = 1; j &lt;= n2; ++j) &#123; if (word1[i - 1] == word2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return n1 + n2 - 2 * dp[n1][n2]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Missing-Number]]></title>
    <url>%2F2017%2F12%2F22%2FMissing-Number%2F</url>
    <content type="text"><![CDATA[LeetCode#268 Missing Number &emsp;&emsp;Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1 12Input: [3,0,1]Output: 2 Example 2 12Input: [9,6,4,2,3,5,7,0,1]Output: 8 Note:&emsp;&emsp;Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 解题思路&emsp;&emsp;emmmm，很没有意思的一道题。题目要求是找到从0-N的数组中缺失的那一个数字（这些数字乱序排列且唯一），我没有试排序的方法而是用另一种思路。我们将0-N加起来，再将数组中的元素加起来，两者相减之后就是缺少的那个元素。 解题代码【.CPP】123456789101112class Solution &#123;public: int missingNumber(vector&lt;int&gt; &amp;nums) &#123; int sum1 = 0, sum2 = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; sum1 += i; sum2 += nums[i]; &#125; sum1 += nums.size(); return sum1 - sum2; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum-Number-of-Arrows-to-Burst-Balloons]]></title>
    <url>%2F2017%2F12%2F21%2FMinimum-Number-of-Arrows-to-Burst-Balloons%2F</url>
    <content type="text"><![CDATA[LeetCode#452 Minimum Number of Arrows to Burst Balloons &emsp;&emsp;There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. &emsp;&emsp;An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example: 12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). 解题思路&emsp;&emsp;说实话这道题我刚开始没看懂，最后去求助Google才知道题目要做什么。这道题是要用最少的箭去射破所有的气球，而数组里每个元素就是气球的区间。就是说我们要找到最少的数字以满足所有的区间，拿题目上的例子。我们可以找到2-6中间的任意一个数字去满足{[2,8],[1,6]}这两个区间（因为他们有重合区），而用10-12中的任意一个数字求满足{[10,16] , [7,12]}两个区间。所以返回2。 &emsp;&emsp;要最小次数的减少箭的个数，首先我们将输入数组排序，然后从头开始遍历，在遍历过程中我们维护一个区间，就是当前的重合区间A1，当下一个气球与这个区间重合（假设重合区为A2），我们更新A1 = A2，直到下一个气球不与当前A1重合，这时候说明我们需要新的一枚箭，也就是结果++ret。 解题代码【.CPP】123456789101112131415161718192021class Solution &#123;public: int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; sort(points.begin(),points.end(), [](pair&lt;int , int&gt; a , pair&lt;int , int&gt; b) &#123; return a.first &gt; b.first ;&#125;); int ret = 0; int start = 1 , end = 0; for (auto point : points)&#123; if(point.second &lt; start || point.first &gt; end || start &gt; end)&#123; ret += 1; start = point.first; end = point.second; &#125; else &#123; start = max(start , point.first); end = min(end , point.second); &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reconstruct-Original-Digits-from-English]]></title>
    <url>%2F2017%2F12%2F19%2FReconstruct-Original-Digits-from-English%2F</url>
    <content type="text"><![CDATA[LeetCode#423 Reconstruct Original Digits from English &emsp;&emsp;Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note: Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as “abc” or “zerone” are not permitted. Input length is less than 50,000. Example 1: 123Input: &quot;owoztneoer&quot;Output: &quot;012&quot; Example 2: 123Input: &quot;fviefuro&quot;Output: &quot;45&quot; 解题思路&emsp;&emsp;刚开始看到题的时候想到了建立一个英文数字数组vector&lt;string&gt; numStrings {&quot;zero&quot; , &quot;one&quot; , ... , &quot;nine&quot;}，然后将输入的字符串按照字符与字符个数存入表中，再挨个按数字英文的方式取出来。思路是没错，不过忽略了顺序的问题。比如按照从0-9的顺序排列的话&quot;threetwoseven&quot;就会过不去，因为刚开始是满足one的全部字符的，但是在取出one后剩下的字符已经没法满足任何一个数了。当然回溯可以解决这个问题，不过还有另一个更有效的方法，就是更改数字顺序。让唯一存在（他后边的数字的英文不包含这个数字的所有字符），比如zero肯定是唯一的，因为’z’只有他一个有。找到一个不会产生歧义的顺序后，就可以了。在这里我找到的顺序是0 , 2 , 6 , 4 , 5 , 1 , 8 , 7 , 3 , 9，即&quot;zero&quot; , &quot;two&quot; , &quot;six&quot; , &quot;four&quot; , &quot;five&quot; , &quot;one&quot; , &quot;eight&quot; , &quot;seven&quot; , &quot;three&quot; , &quot;nine&quot;。 解题代码【.CPP】123456789101112131415161718192021222324252627282930313233class Solution &#123; bool constructOriginalDigits(unordered_map&lt;char , int&gt; &amp;table , string number)&#123; for (auto s : number)&#123; if(table[s] &gt; 0) continue; else return false; &#125; for (auto s : number) --table[s]; return true; &#125;public: string originalDigits(string s) &#123; vector&lt;string&gt; numberStrings&#123;"zero" , "two" , "six" , "four" , "five" , "one" , "eight" , "seven" , "three" , "nine"&#125;; vector&lt;int&gt; numers&#123;0 , 2 , 6 , 4 , 5 , 1 , 8 , 7 , 3 , 9&#125;; unordered_map&lt;char , int&gt; table; for (auto c : s)&#123; if(table[c] &gt;= 1) ++table[c]; else table[c] = 1; &#125; vector&lt;int&gt; res(0); string ret = ""; int idx = 0; while (idx &lt;= 9)&#123; if(constructOriginalDigits(table,numberStrings[idx])) res.push_back(numers[idx]); else ++idx; &#125; sort(res.begin() , res.end()); for (auto c : res) ret.push_back(static_cast&lt;char&gt;(c + '0')); return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Is-Subsequence]]></title>
    <url>%2F2017%2F12%2F18%2FIs-Subsequence%2F</url>
    <content type="text"><![CDATA[LeetCode#392 Is Subsequence &emsp;&emsp;Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and sis a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not). Example 1:s = &quot;abc&quot;, t = &quot;ahbgdc&quot; Return true. Example 2:s = &quot;axc&quot;, t = &quot;ahbgdc&quot; Return false. Follow up:If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? 解题思路&emsp;&emsp;这道题是一道Medium，但是却非常的简单，定义指向S和T的指针，当他们所对应的字符相等时，两个指针都自增1，当他们不相等的时候T的指针自增。最后判断S的指针是否走到了最后就可以了。 解题代码【.CPP】12345678910111213141516//runtime:72msclass Solution &#123;public: bool isSubsequence(string s, string t) &#123; int idxs = 0 , idxt = 0; while (idxs &lt; s.size() &amp;&amp; idxt &lt; t.size())&#123; if(s[idxs] == t[idxt])&#123; ++idxs; ++idxt; &#125; else &#123; ++idxt; &#125; &#125; return idxs == s.size(); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diameter-of-Binary-Tree]]></title>
    <url>%2F2017%2F12%2F17%2FDiameter-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[LeetCode#543 Diameter of Binary Tree &emsp;&emsp;Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 12345 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 解题思路&emsp;&emsp;这道题是求二叉树的直径，及最长两点间距离。其实就是求每个子树的左右深度相加再加一，找到其中的最大值就可以了，代码很简单。不过有两点需要注意 1. 不一定就是根节点的左右子树深度之和最高 使用一个递归函数进行计算的时候注意区分求深度和直径的关系，在我的代码中使用min保存直径，返回值是当前子树的深度。 解题代码【.CPP】 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; int minHeight(TreeNode* root , int&amp; min)&#123; if(!root) return 0; int left = minHeight(root-&gt;left , min); int right = minHeight(root-&gt;right , min); min = max(min , left+right+1); return max(left , right) + 1; &#125;public: int diameterOfBinaryTree(TreeNode* root) &#123; if(!root) return 0; int res = 0; minHeight(root,res); return res - 1; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-Keys-Keyboard]]></title>
    <url>%2F2017%2F12%2F16%2F2-Keys-Keyboard%2F</url>
    <content type="text"><![CDATA[LeetCode#650 2 Keys Keyboard Initially on a notepad only one character ‘A’ is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n ‘A’ on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n ‘A’. Example 1: 1234567Input: 3Output: 3Explanation:Intitally, we have one character &apos;A&apos;.In step 1, we use Copy All operation.In step 2, we use Paste operation to get &apos;AA&apos;.In step 3, we use Paste operation to get &apos;AAA&apos;. Note: The n will be in the range [1, 1000]. 解题思路&emsp;&emsp;这道题的目的是求在最少的操作次数下，可以从初始的一个’A’得到给定个数的’A’，操作有两种，一种是Copy All,另一种的Paste。首先分析下我们的操作，如果要求得到3个’A’，我们需要先Copy All一次，然后Paste两次。题目要求我们必须是Copy All而不能partial copy，也就是说我们最后一次Copy后剪贴板里的A的个数必须可以被N除尽（N%t==0 //t为最后一次剪贴板里’A’的数量），之后我们需要连续Paste N/t 次就可以满足N个’A’的要求。这样我们将题目要求分成了两部分，第一个是求t是多少，第二个是求最少经过多少次操作可以到达t个’A’的要求。这很明显，第二个递归就可以了。 解题代码【.CPP】123456789class Solution &#123;public: int minSteps(int n) &#123; if (n == 1) return 0; int dn = n / 2; while (n % dn != 0) --dn; return n / dn + minSteps(dn); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection-of-Two-Arrays]]></title>
    <url>%2F2017%2F12%2F15%2FIntersection-of-Two-Arrays%2F</url>
    <content type="text"><![CDATA[LeetCode#349 Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 解题思路&emsp;&emsp;没什么说的，直接遍历查找，找到就存值，直接看代码。 解题代码【.CPP】123456789101112class Solution &#123;public: std::vector&lt;int&gt; intersection(std::vector&lt;int&gt;&amp; nums1, std::vector&lt;int&gt;&amp; nums2) &#123; std::set&lt;int&gt; rset; for (auto it = nums1.begin() ; it != nums1.end() ; ++it)&#123; if(std::find(nums2.begin() , nums2.end() , *it) != std::end(nums2))&#123; rset.insert(*it); &#125; &#125; return std::vector&lt;int&gt;(rset.begin(),rset.end()); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection-of-Two-Arrays-II]]></title>
    <url>%2F2017%2F12%2F15%2FIntersection-of-Two-Arrays-II%2F</url>
    <content type="text"><![CDATA[LeetCode#350 Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1‘s size is small compared to nums2‘s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 解题思路&emsp;&emsp;之前有一道题也是求两个数组的交点Intersection of Two Arrays，不过那个题比较简单，只需要循环然后使用std::find查找就可以了。这个题需要有重复的，我们可以将第一个数组的值和出现的次数存到map里，然后遍历第二个数组，如果在map里出现过就存入结果集里，并且将出现次数减一。 解题代码【.CPP】123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int , int&gt; um; for (auto num : nums1)&#123; if(um.find(num) != um.end()) ++um[num]; else um[num] = 1; &#125; vector&lt;int&gt; ret(0); for (auto num: nums2) &#123; if(um[num] &gt; 0)&#123; ret.push_back(num); --um[num]; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】4-VAO与VBO]]></title>
    <url>%2F2017%2F12%2F14%2F%E3%80%90OpenGL%E3%80%914-VAO%E4%B8%8EVBO%2F</url>
    <content type="text"><![CDATA[VAO与VBO来历&emsp;&emsp;首先给出参考资料：VAO与VBO的前世今生 &emsp;&emsp;VAO（Vertex Arrays Object）：顶点数组对象 &emsp;&emsp;VBO（Vertex Buffer Object）：顶点缓冲对象 &emsp;&emsp;首先由其名称就可以知道，这两个是用来操作顶点的，我们的显示器就是一个大的网格，而我们所看到的界面便是顶点和顶点周围所对应的颜色组成的，在上篇文章中我们使用了两个着色器，顶点着色器与片段着色器，就是为了着色。 ![GLSL中VAO和VBO的使用](http://img.blog.csdn.net/20130731232253265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lsYW5ncXVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[GLSL中VAO和VBO的使用](http://blog.csdn.net/silangquan/article/details/9674371) &emsp;&emsp;看看我们画三角形的时候使用VAO和VBO的代码。 123456789101112131415161718192021222324252627282930/*顶点坐标*/ GLfloat vertices[] = &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f &#125;;GLuint VBO; GLuint VAO; glGenVertexArrays(1 , &amp;VAO); glGenBuffers(1, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glVertexAttribPointer( 0 , 3 , GL_FLOAT , GL_FALSE , 0 , (void*)0); glEnableVertexAttribArray(0); glBindBuffer(1,VBO);while (!glfwWindowShouldClose(window)) &#123; //do something glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES , 0 , 3); glBindVertexArray(0); //do something &#125;glDeleteVertexArrays(1,&amp;VAO); glDeleteBuffers(1,&amp;VBO); &emsp;&emsp;在这份代码中，我们使用了VAO,VBO，传输三角形顶点信息。 &emsp;&emsp;VAO/VBO实质是为了解决传输效率而做的优化手段。VBO是为了均衡数据的传输效率与灵活修改性；VAO的本质是储存绘制状态，简化绘制代码（VAO是状态对象，不存储顶点数组信息）。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary-Watch]]></title>
    <url>%2F2017%2F12%2F14%2FBinary-Watch%2F</url>
    <content type="text"><![CDATA[LeetCode#401 Binary Watch A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: 12Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] Note: The order of output does not matter. The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”. The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. 解题思路&emsp;&emsp;这道题其实就是在N个数字中取K个，我们在小时集合中取i个，然后在分钟集合里取剩下的k-i个，将符合题意的放入集合中返回就可以了。 解题代码【.CPP】123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;string&gt; readBinaryWatch(int num) &#123; vector&lt;string&gt; res; vector&lt;int&gt; hour&#123;8, 4, 2, 1&#125;, minute&#123;32, 16, 8, 4, 2, 1&#125;; for (int i = 0; i &lt;= num; ++i) &#123; vector&lt;int&gt; hours = generate(hour, i); vector&lt;int&gt; minutes = generate(minute, num - i); for (int h : hours) &#123; if (h &gt; 11) continue; for (int m : minutes) &#123; if (m &gt; 59) continue; res.push_back(to_string(h) + (m &lt; 10 ? ":0" : ":") + to_string(m)); &#125; &#125; &#125; return res; &#125; vector&lt;int&gt; generate(vector&lt;int&gt;&amp; nums, int cnt) &#123; vector&lt;int&gt; res; helper(nums, cnt, 0, 0, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, int cnt, int pos, int out, vector&lt;int&gt;&amp; res) &#123; if (cnt == 0) &#123; res.push_back(out); return; &#125; for (int i = pos; i &lt; nums.size(); ++i) &#123; helper(nums, cnt - 1, i + 1, out + nums[i], res); &#125; &#125;&#125;; &emsp;&emsp;当然这只是普通解法，还有一种解法是使用bitset集合（当然不是我想出来的） &emsp;&emsp;这种解法利用到了bitset这个类，可以将任意进制数转为二进制，而且又用到了count函数，用来统计1的个数。那么时针从0遍历到11，分针从0遍历到59，然后我们把时针的数组左移6位加上分针的数值，然后统计1的个数，即为亮灯的个数，我们遍历所有的情况，当其等于num的时候，存入结果res中，参见代码如下： 1234567891011121314class Solution &#123;public: vector&lt;string&gt; readBinaryWatch(int num) &#123; vector&lt;string&gt; res; for (int h = 0; h &lt; 12; ++h) &#123; for (int m = 0; m &lt; 60; ++m) &#123; if (bitset&lt;10&gt;((h &lt;&lt; 6) + m).count() == num) &#123; res.push_back(to_string(h) + (m &lt; 10 ? ":0" : ":") + to_string(m)); &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】3-这是一个三角形2]]></title>
    <url>%2F2017%2F12%2F13%2F%E3%80%90OpenGL%E3%80%913-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A22%2F</url>
    <content type="text"><![CDATA[Shader&emsp;&emsp;这篇文章我们将简单介绍一下Shader与对Shader编程，在此将讨论OpenGL的Shader语言GLSL。 &emsp;&emsp;首先推荐教程（毕竟我这里只是我自己学的经历，为防止错误的思想误导了别人，还是先摆出比较正确的教程再说） ​ 1. 着色器 ​ 2. GLSL &emsp;&emsp;着色器（英语：shader）应用于计算机图形学领域，指一组供计算机图形资源在执行渲染任务时使用的指令，用于计算图像的颜色或明暗。但近来，它也能用于处理一些特殊效果，或者视频后处理。通俗地说，着色器告诉电脑如何用特有的一种方法去绘制物体。 &emsp;&emsp;程序员将着色器应用于图形处理器（GPU）的可编程流水线，来实现三维应用程序。这样的图形处理器有别于传统的固定流水线处理器，为GPU编程带来更高的灵活性和适应性。以前固有的流水线只能进行一些几何变换和像素灰度计算。现在可编程流水线还能处理所有像素、顶点、纹理的位置、色调、饱和度、明度、对比度并实时地绘制图像。着色器还能产生如模糊、高光、有体积光源、失焦、卡通渲染、色调分离、畸变、凹凸贴图、边缘检测、运动检测等效果 Direct3D和OpenGL都使用了以下三种着色器： 顶点着色器处理每个顶点，将顶点的空间位置投影在屏幕上，即计算顶点的二维坐标。同时，它也负责顶点的深度缓冲（Z-Buffer）的计算。顶点着色器可以掌控顶点的位置、颜色和纹理坐标等属性，但无法生成新的顶点。顶点着色器的输出传递到流水线的下一步。如果有之后定义了几何着色器，则几何着色器会处理顶点着色器的输出数据，否则，光栅化器继续流水线任务。 几何着色器可以从多边形网格中增删顶点。它能够执行对CPU来说过于繁重的生成几何结构和增加模型细节的工作。Direct3D版本10增加了支持几何着色器的API, 成为Shader Model 4.0的组成部分。OpenGL只可通过它的一个插件来使用几何着色器，但极有可能在3.1版本中该功能将会归并。几何着色器的输出连接光栅化器的输入。 像素着色器(Direct3D)，常常又称为片断着色器(OpenGL)，处理来自光栅化器的数据。光栅化器已经将多边形填满并通过流水线传送至像素着色器，后者逐像素计算颜色。像素着色器常用来处理场景光照和与之相关的效果，如凸凹纹理映射和调色。名称片断着色器似乎更为准确，因为对于着色器的调用和屏幕上像素的显示并非一一对应。举个例子，对于一个像素，片断着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。 统一着色器模型将上述三种着色器统一起来，发布于OpenGL和Direct3D 10里面。 &emsp;&emsp;这一大堆来自于维基百科的介绍，我们可以从中得到一堆的名词，暂时需要记住的就【顶点着色器】和【片段着色器】，我们也将使用这两个着色器让我们的三角形显示出来。 &emsp;&emsp;首先介绍一些Shader的基本构造： 12345678910111213141516#version version_number //声明版本in type in_variable_name; //输入变量1in type in_variable_name; //输入变量2out type out_variable_name; //输出变量uniform type uniform_name; //uniform变量int main() //main方法&#123; // 处理输入并进行一些图形操作 ... // 输出处理过的结果到输出变量 out_variable_name = weird_stuff_we_processed;&#125; &emsp;&emsp;GLSL是一种类C语言，in , out , uniform都是他的关键字 ，type则是float , int等等的基本类型。在GLSL中有int,float,double,uint,bool这几种基本类型，还有高级一些的向量和矩阵(暂且不提)类型。 向量GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n代表分量的数量）： 类型 含义 vecn 包含n个float分量的默认向量 bvecn 包含n个bool分量的向量 ivecn 包含n个int分量的向量 uvecn 包含n个unsigned int分量的向量 dvecn 包含n个double分量的向量 &emsp;&emsp;当前我们的目标是给三角形着色，这需要用到顶点着色器和片段着色器。我们首先需要一个顶点着色器的代码: 1234567#version 330 core //声明版本layout(location = 0) in vec3 position; //position变量的属性位置值为0out vec4 vertexColor;void main()&#123; gl_Position = vec4(position.x,position.y,position.z,1.0); //为gl_Position赋值 vertexColor = vec4(0.5f, 0.0f, 0.0f, 1.0f); //为输出变量赋值&#125; &emsp;&emsp;还有一个片段着色器: 123456#version 330 corein vec4 vertexColor; //接收顶点着色器传来的值out vec4 fragmentColor; //定义片段着色器输出void main()&#123; fragmentColor = vertexColor; //为输出赋值&#125; &emsp;&emsp;我们可以将这两个着色器程序写入文件，然后从文件里读出来编译，也可以像我这样直接写成语句。 1234567891011121314151617GLchar const* vertexShaderSource = "#version 330 core\n" "layout(location = 0) in vec3 position;\n" "out vec4 vertexColor;\n" "void main()&#123;\n" " gl_Position = vec4(position.x,position.y,position.z,1.0);\n" " vertexColor = vec4(0.5f, 0.0f, 0.0f, 1.0f);\n" "&#125;\n";GLchar const* fragmentShaderSource = "#version 330 core\n" "in vec4 vertexColor;\n" "out vec4 fragmentColor;\n" "void main()&#123;\n" " fragmentColor = vertexColor;\n" "&#125;\n"; &emsp;&emsp;写好了着色器程序，接下来是要编译链接他 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//创建缓冲器GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);//获得缓冲器对象glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glShaderSource(fragmentShader , 1 , &amp;fragmentShaderSource , NULL);//编译缓冲器glCompileShader(vertexShader);glCompileShader(fragmentShader);//检查着色器GLint Result = GL_FALSE;GLint InfoLogLength;glGetShaderiv(vertexShader , GL_COMPILE_STATUS , &amp;Result);glGetShaderiv(vertexShader , GL_INFO_LOG_LENGTH , &amp;InfoLogLength);if(InfoLogLength &gt; 0)&#123; std::vector&lt;char&gt; ShaderErrorMessage(InfoLogLength+1); glGetShaderInfoLog(vertexShader, InfoLogLength, NULL, &amp;ShaderErrorMessage[0]); printf("%s\n", &amp;ShaderErrorMessage[0]);&#125; else &#123; printf("VertexShader complier successed\n");&#125;glGetShaderiv(fragmentShader , GL_COMPILE_STATUS , &amp;Result);glGetShaderiv(fragmentShader , GL_INFO_LOG_LENGTH , &amp;InfoLogLength);if(InfoLogLength &gt; 0)&#123; std::vector&lt;char&gt; ShaderErrorMessage(InfoLogLength+1); glGetShaderInfoLog(fragmentShader, InfoLogLength, NULL, &amp;ShaderErrorMessage[0]); printf("%s\n", &amp;ShaderErrorMessage[0]);&#125; else &#123; printf("FragmentShader complier successed\n");&#125;//连接程序GLuint program = glCreateProgram();glAttachShader(program , vertexShader);glAttachShader(program , fragmentShader);glLinkProgram(program);//glDetachShader(program , vertexShader);glDetachShader(program , fragmentShader);//检查programglGetProgramiv(program, GL_LINK_STATUS, &amp;Result);glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;InfoLogLength);if ( InfoLogLength &gt; 0 )&#123; std::vector&lt;char&gt; ProgramErrorMessage(InfoLogLength+1); glGetProgramInfoLog(program, InfoLogLength, NULL, &amp;ProgramErrorMessage[0]); printf("%s\n", &amp;ProgramErrorMessage[0]);&#125; else &#123; printf("Link successed!\n");&#125;//删除着色器glDeleteShader(vertexShader);glDeleteShader(fragmentShader); &emsp;&emsp;这里我们注意的是检查着色器那里，我们用了glGetShaderiv获得着色器编译信息GL_COMPILE_STATUS和 GL_INFO_LOG_LENGTH，当着色器出错，GL_INFO_LOG_LENGTH &gt; 0，就要查看着色器编译过程中的错误信息了，使用glGetShaderInfoLog获得。 &emsp;&emsp;这些执行完成后，我们的代码基本已经成了，在main的循环里使用这个已经链接着色器的program就可以了。 1glUseProgram(program); &emsp;&emsp;在最后修改的时候我的完整代码经过了一些更改，如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;iostream&gt;#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;vector&gt;#define GLFW_CONTEXT_VERSION 3#define WINDOW_WIDTH 800#define WINDOW_HEIGHT 600void InitGLFW()&#123; /*初始化GLFW*/ glfwInit(); glfwWindowHint(GLFW_SAMPLES , 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, GLFW_CONTEXT_VERSION); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, GLFW_CONTEXT_VERSION); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif&#125;GLuint getProgram() &#123; GLchar const* vertexShaderSource = "#version 330 core\n" "layout(location = 0) in vec3 position;\n" "void main()&#123;\n" " gl_Position = vec4(position.x,position.y,position.z,1.0);\n" "&#125;\n"; GLchar const* fragmentShaderSource = "#version 330 core\n" "out vec3 fragmentColor;\n" "uniform vec3 color;\n" "void main()&#123;\n" " fragmentColor = color;\n" "&#125;\n"; //创建缓冲器 GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); //获得缓冲器对象 glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glShaderSource(fragmentShader , 1 , &amp;fragmentShaderSource , NULL); //编译缓冲器 glCompileShader(vertexShader); glCompileShader(fragmentShader); //检查着色器 GLint Result = GL_FALSE; GLint InfoLogLength; glGetShaderiv(vertexShader , GL_COMPILE_STATUS , &amp;Result); glGetShaderiv(vertexShader , GL_INFO_LOG_LENGTH , &amp;InfoLogLength); if(InfoLogLength &gt; 0)&#123; std::vector&lt;char&gt; ShaderErrorMessage(InfoLogLength+1); glGetShaderInfoLog(vertexShader, InfoLogLength, NULL, &amp;ShaderErrorMessage[0]); printf("%s\n", &amp;ShaderErrorMessage[0]); &#125; else &#123; printf("VertexShader complier successed\n"); &#125; glGetShaderiv(fragmentShader , GL_COMPILE_STATUS , &amp;Result); glGetShaderiv(fragmentShader , GL_INFO_LOG_LENGTH , &amp;InfoLogLength); if(InfoLogLength &gt; 0)&#123; std::vector&lt;char&gt; ShaderErrorMessage(InfoLogLength+1); glGetShaderInfoLog(fragmentShader, InfoLogLength, NULL, &amp;ShaderErrorMessage[0]); printf("%s\n", &amp;ShaderErrorMessage[0]); &#125; else &#123; printf("FragmentShader complier successed\n"); &#125; //连接程序 GLuint program = glCreateProgram(); glAttachShader(program , vertexShader); glAttachShader(program , fragmentShader); glLinkProgram(program); // glDetachShader(program , vertexShader); glDetachShader(program , fragmentShader); //检查program glGetProgramiv(program, GL_LINK_STATUS, &amp;Result); glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;InfoLogLength); if ( InfoLogLength &gt; 0 )&#123; std::vector&lt;char&gt; ProgramErrorMessage(InfoLogLength+1); glGetProgramInfoLog(program, InfoLogLength, NULL, &amp;ProgramErrorMessage[0]); printf("%s\n", &amp;ProgramErrorMessage[0]); &#125; else &#123; printf("Link successed!\n"); &#125; //删除着色器 glDeleteShader(vertexShader); glDeleteShader(fragmentShader); return program;&#125;glm::vec3 getRGB()&#123; static int r = 0; static int g = 128; static int b = 255; static int dr = 1; static int dg = 1; static int db = 1; r += dr; g += dg; b += db; if (r &gt; 255 || r &lt; 0) dr = -dr; if (g &gt; 255 || g &lt; 0) dg = -dg; if (b &gt; 255 || b &lt; 0) db = -db; return glm::vec3(r , g , b);&#125;int main() &#123; InitGLFW(); /*创建一个窗口对象*/ GLFWwindow *window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, "Triangle", NULL, NULL); glfwMakeContextCurrent(window); if (!window) &#123; std::cout &lt;&lt; "faild create glfw window" &lt;&lt; std::endl; return -1; &#125; /*设置GLEW*/ glewExperimental = GL_TRUE; if (glewInit() != GLEW_OK) &#123; std::cout &lt;&lt; "faild to init glew" &lt;&lt; std::endl; return -2; &#125; glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); GLuint program = getProgram(); /*顶点坐标*/ GLfloat vertices[] = &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f &#125;; GLuint VBO; GLuint VAO; glGenVertexArrays(1 , &amp;VAO); glGenBuffers(1, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glVertexAttribPointer( 0 , 3 , GL_FLOAT , GL_FALSE , 0 , (void*)0); glEnableVertexAttribArray(0); glBindBuffer(1,VBO); glBindVertexArray(0); glDisableVertexAttribArray(0); while (!glfwWindowShouldClose(window)) &#123; glClearColor(0.0f , 0.3f , 0.2f , 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glm::vec3 v = getRGB(); int location = glGetUniformLocation(program , "color"); glUseProgram(program); glUniform3f(location , v.r / 255.0f , v.g / 255.0f , v.b / 255.0f); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES , 0 , 3); glBindVertexArray(0); glfwPollEvents(); glfwSwapBuffers(window); &#125; glDeleteVertexArrays(1,&amp;VAO); glDeleteBuffers(1,&amp;VBO); glDeleteProgram(program); glfwTerminate(); return 0;&#125; &emsp;&emsp;这个代码中使用了uniform变量 &emsp;&emsp;uniform变量是外部application程序传递给(vertex和fragment)shader的变量。因此它是application通过函数glUniform()函数赋值的 。在(vertex和fragment)shader程序内部，uniform变量就像是C语言里面的常量(const)，它不能被shader程序修改。也就是说shader只能用不能改uniform变量。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum-Product-of-Word-Lengths]]></title>
    <url>%2F2017%2F12%2F13%2FMaximum-Product-of-Word-Lengths%2F</url>
    <content type="text"><![CDATA[LeetCode#318 Maximum Product of Word Lengths Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Given [&quot;abcw&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;xtfn&quot;, &quot;abcdef&quot;]Return 16The two words can be &quot;abcw&quot;, &quot;xtfn&quot;. Example 2: Given [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;d&quot;, &quot;cd&quot;, &quot;bcd&quot;, &quot;abcd&quot;]Return 4The two words can be &quot;ab&quot;, &quot;cd&quot;. Example 3: Given [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;]Return 0No such pair of words. Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases. 解题思路&emsp;&emsp;嗯，又是一道骚操作题。我是卡在了最后大数据集的超时那里，苦思不得解，只能去参考网上大佬的做法，一看果然是骚操作。 &emsp;&emsp;首先分析下题，就是求数组中两个互不存在相同字母的字符串的长度之积，暴力的遍历判断其是否存在相同字符是根本不行的。还是来说说网上的骚操作吧。 &emsp;&emsp;由于题目上说明了只会出现小写的字母，也就是26个字母，而我们所用的int是32位的，所以可以用一个int来存储一个字符串的信息，就是用int的后26位来存储对应的字符是否出现，1为出现0为未出现。这样下来在判断是否有共同字符的时候只需要与一下就可以了。代码如下： 解题代码【.CPP】123456789101112131415161718class Solution &#123;public: int maxProduct(vector&lt;string&gt;&amp; words) &#123; int res = 0; vector&lt;int&gt; mask(words.size(), 0); for (int i = 0; i &lt; words.size(); ++i) &#123; for (char c : words[i]) &#123; mask[i] |= 1 &lt;&lt; (c - 'a'); &#125; for (int j = 0; j &lt; i; ++j) &#123; if (!(mask[i] &amp; mask[j])) &#123; res = max(res, int(words[i].size() * words[j].size())); &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】2-这是一个三角形1]]></title>
    <url>%2F2017%2F12%2F12%2F%E3%80%90OpenGL%E3%80%912-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A21%2F</url>
    <content type="text"><![CDATA[【OpenGL菜鸟历程】 &emsp;&emsp;上次的一堆代码就显示了个窗口，虽然感觉很麻烦但是还不足以让我放弃。继续继续，跟着教程上的下一篇文章，我开始接触了Shader，而这一次就是要用Shader画一个三角。 【代码O.O】 &emsp;&emsp;这次的项目起名为HelloTriangle，在画三角之前，我们自然是要先把窗口写出来。为了使得代码看起来更清晰，这次将代码封装成函数。 1234567891011121314151617//我们的glfw的初始化方法#define GLFW_CONTEXT_VERSION 3#define WINDOW_WIDTH 800#define WINDOW_HEIGHT 600void InitGLFW()&#123; /*初始化GLFW*/ glfwInit(); glfwWindowHint(GLFW_SAMPLES , 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, GLFW_CONTEXT_VERSION); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, GLFW_CONTEXT_VERSION); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif&#125; &emsp;&emsp;之后就是主函数 123456789101112131415161718192021222324252627282930313233int main() &#123; InitGLFW(); /*创建一个窗口对象*/ GLFWwindow *window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, "Triangle", NULL, NULL); glfwMakeContextCurrent(window); if (!window) &#123; std::cout &lt;&lt; "faild create glfw window" &lt;&lt; std::endl; return -1; &#125; /*设置GLEW*/ glewExperimental = GL_TRUE; if (glewInit() != GLEW_OK) &#123; std::cout &lt;&lt; "faild to init glew" &lt;&lt; std::endl; return -2; &#125; glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); while (!glfwWindowShouldClose(window)) &#123; glClearColor(0.0f , 0.3f , 0.2f , 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //do something glfwPollEvents(); glfwSwapBuffers(window); &#125; return 0; &emsp;&emsp;这样我们首先得到了一个简单的窗口，接下来才是重点。我们首先给出一个三角形的顶点坐标 123456/*顶点坐标*/ GLfloat vertices[] = &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f &#125;; &emsp;&emsp;这时，需要了解两个概念 VAO (Vertex Array Object)，VBO(Vertex Buffer Object)，不知道这两个东西的话可以看VAO与VBO的前世今生。 &emsp;&emsp;我们创建这两个对象并进行初始化绑定等操作。 1234567891011121314GLuint VBO;GLuint VAO;glGenVertexArrays(1 , &amp;VAO);glGenBuffers(1, &amp;VBO);glBindVertexArray(VAO);glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glVertexAttribPointer( 0 , 3 , GL_FLOAT , GL_FALSE , 0 , (void*)0);glEnableVertexAttribArray(0);glBindBuffer(1,VBO);glBindVertexArray(0);glDisableVertexAttribArray(0); &emsp;&emsp;请先不要追究这些方法的具体含义，我们将在未来一篇文章中解释并且对VAO，VBO进行详细的介绍和分析。现在我们写了这一大堆代码，然后呢？ 123glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES , 0 , 3);glBindVertexArray(0); &emsp;&emsp;我们在窗口的代码的循环里，加入这几行，将VAO进行绑定，然后画出来这个顶点数组，再解绑（绑定0就是解绑）。OK，现在代码应该已经好了，可是点击运行后，却没有按照我们的意愿出现一个三角形。 &emsp;&emsp;当然出现了，只是我们没有看到，因为他的颜色并没有和窗口的主色调分开，所以我们看不到而已。下一篇文章将会讲解另一个东西，Shader（着色器）。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum-Product-of-Three-Numbers]]></title>
    <url>%2F2017%2F12%2F12%2FMaximum-Product-of-Three-Numbers%2F</url>
    <content type="text"><![CDATA[LeetCode#628 Maximum Product of Three Numbers Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: 12Input: [1,2,3]Output: 6 Example 2: 12Input: [1,2,3,4]Output: 24 Note: The length of the given array will be in range [3,10^4] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer. 解题思路&emsp;&emsp;很麻瓜，刚开始看到这道题的时候，第一反应是排序然后直接乘倒数前三个，不过仔细看了题之后就放弃了，因为all elements are in the range [-1000, 1000]，及数组元素是可以为负的。暴力三重循环更是不可能，因为数据的数量是3到10^4个，三重循环肯定会超时，只能想想其他办法了。 &emsp;&emsp;这种题分析以分情况讨论为主，我们将数组分为以下几类： ​ &emsp;&emsp;1.全为正数，例如[1 , 2 , 3 , 4 , 5] ​ &emsp;&emsp;2.全为负数，例如[-5,-4,-3,-2,-1] ​ &emsp;&emsp;3.一半为负数，一半为正数 [-5,-4,-3,2,1] &emsp;&emsp;当数据全为正或者全为负的时候，最大乘积都是倒数前三个。而第三种情况又分为两种： ​ &emsp;&emsp;1.能够找到两个负数，使得这两个负数之积大于任意两个数之积 （排序后是前两个负数） ​ &emsp;&emsp;2.负数数量不足两个或者其积不够大 &emsp;&emsp;当发生第一种情况的时候，我们的选择是正数中最大的（排序后最后一个数字），和前两个负数。第二种情况则直接是可以跟全为正一样的处理方式。 &emsp;&emsp;这样归类下来，建立在已排序的基础上，我们就有两种乘的方式，一种是选前两个数字和最后一个数字，另一种是选倒数前三个数字。这样下来就很简单了 ，我们直接取这两种中比较大的值就可以了。代码很简单 解题代码【.CPP】12345678class Solution &#123;public: int maximumProduct(vector&lt;int&gt; &amp;nums) &#123; sort(nums.begin(), nums.end()); return max(nums[0] * nums[1] * nums[nums.size() - 1], nums[nums.size() - 1] * nums[nums.size() - 2] * nums[nums.size() - 3]); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OpenGL】1-竟然只是画了一个窗口]]></title>
    <url>%2F2017%2F12%2F11%2F%E3%80%90OpenGL%E3%80%911-%E7%AB%9F%E7%84%B6%E5%8F%AA%E6%98%AF%E7%94%BB%E4%BA%86%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[【OPENGL菜鸟历程】 &emsp;&emsp;O.O从第一次知道OPENGL这个名字到现在已经有三年了，但是还是第一次真正去学这个东西。虽然在之前也大概看过DX，对这种东西的复杂度略知一二，并且做好了去长期啃这个的打算。但是，还是难啊(:зゝ∠) &emsp;&emsp;我看的是LearnOpenGL这个教程，光是配置GLEW,GLFW就费了好久的功夫。唉，距离我的引擎梦，还差多久啊。 &emsp;&emsp;言归正传，本文中的代码可用性建立在你正确的配置了GLEW和GLFW的条件下，接下来有时间的话我会写一篇文章来说明如何在MAC OS下配置GLEW , GLFW，并使用Clion进行代码编写。 【CMakeList.txt文件】 123456789101112cmake_minimum_required(VERSION 3.8)project(EmptyWindow)set(CMAKE_CXX_STANDARD 11)set(CMAKE_EXE_LINKER_FLAGS "$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -framework OPENGL")set(SOURCE_FILES EmptyWindow.cpp)add_executable(EmptyWindow $&#123;SOURCE_FILES&#125;)target_link_libraries(EmptyWindow "/usr/local/lib/libglfw.dylib")target_link_libraries(EmptyWindow "/usr/local/lib/libGLEW.dylib") &emsp;&emsp;其中set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -framework OPENGL&quot;),target_link_libraries(EmptyWindow &quot;/usr/local/lib/libglfw.dylib&quot;)和target_link_libraries(EmptyWindow &quot;/usr/local/lib/libGLEW.dylib&quot;)是对openGL的配置。 &emsp;&emsp;根据这几项的属性名就可以大概猜出来是要配置什么，第一个是链接OPENGL框架，第二个是链接glfw动态链接库，第三个自然就是glew的动态链接库了。 【EmptyWindow.cpp】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#define GLEW_STATIC#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;void InitGlfw()&#123; /*初始化glfw*/ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR , 3); //设置最大版本 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR , 3); //设置最小版本 glfwWindowHint(GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE); //设置core-profile glfwWindowHint(GLFW_RESIZABLE , false); //设置不可改变大小#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE);#endif&#125;void DisPlayColor()&#123; static int r = 0; static int g = 128; static int b = 255; static int dr = 1; static int dg = 1; static int db = 1; glClearColor(r / 255.0f , g / 255.0f , b / 255.0f , 1.0f); r += dr; g += dg; b += db; if (r &gt; 255 || r &lt; 0) dr = -dr; if (g &gt; 255 || g &lt; 0) dg = -dg; if (b &gt; 255 || b &lt; 0) db = -db; glClear(GL_COLOR_BUFFER_BIT);&#125;void key_callback(GLFWwindow* window , int key , int scancode , int action , int mode)&#123; if(key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)&#123; glfwSetWindowShouldClose(window , GL_TRUE); &#125;&#125;int main()&#123; InitGlfw(); //创建一个窗口 GLFWwindow *window = glfwCreateWindow(800 , 600 , "Empty Window" , NULL , NULL); //设置窗口环境 glfwMakeContextCurrent(window); if(window == NULL)&#123; std::cout &lt;&lt; "Faild to create glfw window" &lt;&lt; std::endl; glfwTerminate(); &#125; //设置glew glewExperimental = GL_TRUE; if(glewInit() != GLEW_OK) &#123; std::cout &lt;&lt; "Faild to init glew" &lt;&lt; std::endl; return -1; &#125; //设置位置 glViewport(100 , 100 , 800 , 600); glfwSetKeyCallback(window , key_callback); while (!glfwWindowShouldClose(window))&#123; glfwPollEvents(); DisPlayColor(); glfwSwapBuffers(window); &#125; return 0;&#125; &emsp;&emsp;这是我的文件代码，最后的输出是一个根据时间动态变色的窗口，看起来还是很酷炫的。如果不实现这些花样仅仅是输出一个窗口的话，则可以去掉DisPlayColor这个函数，并且将main方法里的while循环中的方法调用移除就可以了。 &emsp;&emsp;之所以使用while，是因为程序顺序执行，到了return 0退出，但是我们不想看见一个一闪而过的窗口，所以用一个while循环来让它持续显示。这个循环的循环条件!glfwWindowShouldClose(window)顾名思义，是当窗口不应该退出的时候就继续循环。可是什么时候应该退出呢？这个时候就需要我们的事件处理了，这个以后再提。 &emsp;&emsp;当然，输出这样一个黑窗口确实有点丑，虽然刚开始学并不为了美观，但是强迫症还是想看的舒服一些，所以在循环里边添加这么两行代码。 12glClearColor(0 , 110 , 110 , 0.2f); //参数为 red , green , blue 最后一个参数暂时不管glClear(GL_COLOR_BUFFER_BIT); &emsp;&emsp;这样，一个窗口就写好啦。]]></content>
      <tags>
        <tag>Computer graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kth-Smallest-Element-in-a-Sorted-Matrix]]></title>
    <url>%2F2017%2F12%2F11%2FKth-Smallest-Element-in-a-Sorted-Matrix%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;LeetCode#378 Kth Smallest Element in a Sorted Matrix &emsp;&emsp;Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. &emsp;&emsp;Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. Note: You may assume k is always valid, 1 ≤ k ≤ n2. 解题思路&emsp;&emsp;这是一道Medium题，但是却简单的有点不像话。题目要求是求一个每一行有序矩阵的第Kth数据，及求它第N大的数据。本来可能是需要使用数组存储每一行的当前指针balabala一大堆，但是其实只需要将所有值放到一个一维数组里边再对一维数组排序就可以直接取值了。 解题代码（.CPP）12345678910111213class Solution &#123;public: int kthSmallest(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; std::vector&lt;int&gt; mat(0); for (auto vec : matrix)&#123; for (auto vrs : vec)&#123; mat.push_back(vrs); &#125; &#125; std::sort(mat.begin() , mat.end()); return mat[k-1]; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Different-Ways-to-Add-Parentheses]]></title>
    <url>%2F2017%2F12%2F10%2FDifferent-Ways-to-Add-Parentheses%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;LeetCode#241 Different Ways to Add Parentheses &emsp;&emsp;Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1 Input: &quot;2-1-1&quot;. 12((2-1)-1) = 0(2-(1-1)) = 2 Output: [0, 2] Example 2 Input: &quot;2*3-4*5&quot; 12345(2*(3-(4*5))) = -34((2*3)-(4*5)) = -14((2*(3-4))*5) = -10(2*((3-4)*5)) = -10(((2*3)-4)*5) = 10 Output: [-34, -14, -10, -10, 10] 解题思路​ 这道题题目描述是给一个计算表达式例如 2+3*5+6 , 要求在不同的位置添加括号使得其计算顺序不一样而最终获得不同的值。 ​ 很明显这种题一看就是使用递归，当我们得到一个表达式，将其从不同的位置分隔开（例如将2+3*5+6分割成(2+3)*(5+6)，之后递归这两个子表达式，得到这两个子表达式所能求出的值的集合，再将其进行交叉计算。） 解题代码(.cpp)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Runtime : 3msclass Solution &#123;private: vector&lt;string&gt; analyseInput(string input) &#123; vector&lt;string&gt; ret(0); string tmp=""; for (int i = 0; i &lt; input.size(); ++i) &#123; if(input[i] &lt;= '9' &amp;&amp; input[i] &gt;= '0')&#123; tmp.push_back(input[i]); &#125; else &#123; ret.push_back(tmp); tmp = ""; tmp.push_back(input[i]); ret.push_back(tmp); tmp = ""; &#125; &#125; ret.push_back(tmp); return ret; &#125; vector&lt;int&gt; recvCompute(vector&lt;string&gt; vp , int left , int right)&#123; if(right == left) return vector&lt;int&gt;&#123;atoi(vp[left].c_str())&#125;; if(right == left + 2) &#123; return vector&lt;int&gt;&#123;compute(atoi(vp[left].c_str()) , vp[left+1] , atoi(vp[left+2].c_str()))&#125;; &#125; vector&lt;int&gt; res; for (int i = left; i &lt; right; i += 2) &#123; vector&lt;int&gt; lres = recvCompute(vp , left , i); vector&lt;int&gt; rres = recvCompute(vp , i + 2 , right); for (auto l : lres)&#123; for(auto r : rres)&#123; res.push_back(compute(l , vp[i+1] , r)); &#125; &#125; &#125; return res; &#125; int compute(int af , string op , int bf)&#123; switch (op[0])&#123; case '+': return af + bf; case '-': return af - bf; case '*': return af * bf; default:break; &#125; return 0; &#125;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;string&gt; cp = analyseInput(input); vector&lt;int&gt; res = recvCompute(cp , 0 , static_cast&lt;int&gt;(cp.size() - 1)); sort(res.begin() , res.end()); return res; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp篇-伍]]></title>
    <url>%2F2017%2F05%2F06%2FCSharp%E7%AF%87-%E4%BC%8D%2F</url>
    <content type="text"><![CDATA[.NET Core Web Api 快速入手 —— C#篇 [ 伍 ]本篇内容C# 数据库使用 &emsp;&emsp;C#使用数据库的方式大体上有两种，ado 和 ef 模型，在我们的项目中使用了传统的 ado ，所以对于 ef 模型暂且不提。 &emsp;&emsp;ado.net提供了丰富的数据库操作，这些操作可以分为三个步骤： 第一，使用SqlConnection对象连接数据库； 第二，建立SqlCommand对象，负责SQL语句的执行和存储过程的调用； 第三，对SQL或存储过程执行后返回的“结果”进行操作。 &emsp;&emsp;对返回“结果”的操作可以分为两类： 一是用SqlDataReader直接一行一行的读取数据集； 二是DataSet联合SqlDataAdapter来操作数据库。 &emsp;&emsp;两者比较： &emsp;&emsp;SqlDataReader时刻与远程数据库服务器保持连接，将远程的数据通过“流”的形式单向传输给客户端，它是“只读”的。由于是直接访问数据库，所以效率较高，但使用起来不方便。 &emsp;&emsp;DataSet一次性从数据源获取数据到本地，并在本地建立一个微型数据库（包含表、行、列、规则、表之间的关系等），期间可以断开与服务器的连接，使用SqlDataAdapter对象操作“本地微型数据库”，结束后通过SqlDataAdapter一次性更新到远程数据库服务器。这种方式使用起来更方，便简单。但性能较第一种稍微差一点。 &emsp;&emsp;ado图 连接字符串的写法 1string connectString = "Data Source=.;Initial Catalog=Student;Integrated Security=True"; System.Data.SqlClient.SqlConnection;类 &emsp;&emsp;其返回数据库连接对象，参数字符串。实例化“连接对象”，并打开连接 12SqlConnection con = new SqlConnection(connectString);con.Open(); &emsp;&emsp;在使用完成后要关闭对象。(我们项目中使用using语句来包裹这个对象，在using语句块结束后会释放里边所有的对象，所以没有手动关闭，一般还是养成关闭的习惯比较好) SqlCommand对象 命名空间：System.Data.SqlClient.SqlCommand;SqlCommand对象用于执行数据库操作，操作方式有三种： SQL语句:command.CommandType = CommandType.Text; 存储过程:command.CommandType=CommandType.StoredProcedure; 整张表:command.CommandType = CommandType.TableDirect; 实例化一个SqlCommand对象 1234&gt;SqlCommand command = new SqlCommand();&gt;command.Connection = con; // 绑定SqlConnection对象或直接从SqlConnection创建&gt;SqlCommand command = con.CreateCommand();&gt; 12345678910111213141516171819&gt;常用方法：&gt;+ command.ExecuteNonQuery(): 返回受影响函数，如增、删、改操作；&gt;+ command.ExecuteScalar()：执行查询，返回首行首列的结果； &gt;+ command.ExecuteReader()：返回一个数据流（SqlDataReader对象）。&gt;常用操作:&gt;① 执行SQL&gt;```csharpSqlCommand cmd = conn.CreateCommand(); //创建SqlCommand对象cmd.CommandType = CommandType.Text;cmd.CommandText = &quot;select * from products = @ID&quot;; //sql语句cmd.Parameters.Add(&quot;@ID&quot;, SqlDbType.Int);cmd.Parameters[&quot;@ID&quot;].Value = 1; //给参数sql语句的参数赋值 ② 调用存储过程 1234&gt;SqlCommand cmd = conn.CreateCommand(); &gt;cmd.CommandType = System.Data.CommandType.StoredProcedure;&gt;cmd.CommandText = "存储过程名";&gt; 1234567&gt;③ 整张表&gt;```csharpSqlCommand cmd = conn.CreateCommand(); cmd.CommandType = System.Data.CommandType.TableDirect;cmd.CommandText = &quot;表名&quot; SqlDataReader对象 &emsp;&emsp;命名空间：System.Data.SqlClient.SqlDataReader; &emsp;&emsp;SqlDataReader对象提供只读单向数据的功能，单向：只能依次读取下一条数据；只读：DataReader中的数据是只读的，不能修改；相对地DataSet中的数据可以任意读取和修改. &emsp;&emsp;它有一个很重要的方法，是Read()，返回值是个布尔值，作用是前进到下一条数据，一条条的返回数据，当布尔值为真时执行，为假时跳出。如 123456789SqlCommand command = new SqlCommand();command.Connection = con;command.CommandType = CommandType.Text;command.CommandText = "Select * from Users";SqlDataReader reader = command.ExecuteReader(); //执行SQL，返回一个“流”while (reader.Read())&#123; Console.Write(reader["username"]);// 打印出每个用户的用户名&#125; DataSet对象[未使用] 关闭资源 &emsp;&emsp;资源使用完毕后应及时关闭连接和释放，具体方法如下： 12345myDataSet.Dispose(); // 释放DataSet对象myDataAdapter.Dispose(); // 释放SqlDataAdapter对象myDataReader.Dispose(); // 释放SqlDataReader对象con.Close(); // 关闭数据库连接con.Dispose(); // 释放数据库连接对象]]></content>
      <tags>
        <tag>.net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp篇-肆]]></title>
    <url>%2F2017%2F05%2F05%2FCSharp%E7%AF%87-%E8%82%86%2F</url>
    <content type="text"><![CDATA[.NET Core Web Api 快速入手 —— C#篇 [ 肆 ]本篇内容using关键字Attribute using关键字 using一般有着以下几种用法： using System。&emsp;&emsp;这个是最常用的，就是using+命名空间，这样就可以直接使用命名空间中的类型，而免去了使用详细的命名空间 using别名。&emsp;&emsp;using + 别名 = 包括详细命名空间信息的具体的类型。例如我们用以下语句引入System.IO.Compression命名空间：using Zip=System.IO.Compression;这时我们就可以用Zip表示System.IO.Compression命名空间，使用Zip.GZipStream就是使用System.IO.Compression.GZipStream。给程序书写带来方便。 using语句，定义一个范围，在范围结束时处理对象。&emsp;&emsp;当在某个代码段中使用了类的实例，而希望无论因为什么原因，只要离开了这个代码段就自动调用这个类实例的Dispose。要达到这样的目的，用try…catch来捕捉异常也是可以的，但用using也很方便。&emsp;&emsp;在我们的项目代码中，大量使用了using语句来处理与数据库有关的操作，这样好处是能及时关闭数据库连接对象。&emsp;&emsp;例如: 123456789101112131415161718192021222324252627282930313233343536using (var con = new SqlConnection(Server.SqlConString)) &#123; con.Open(); var sqlCom = new SqlCommand("sp_login", con) &#123; CommandType = CommandType.StoredProcedure &#125;; sqlCom.Parameters.Add(new SqlParameter &#123; ParameterName = "@account", Direction = ParameterDirection.Input, SqlDbType = SqlDbType.NVarChar, Size = 15, Value = account &#125;); sqlCom.Parameters.Add(new SqlParameter &#123; ParameterName = "@password", Direction = ParameterDirection.Input, SqlDbType = SqlDbType.NVarChar, Size = 15, Value = password &#125;); sqlCom.Parameters.Add(new SqlParameter &#123; ParameterName = "@return", Direction = ParameterDirection.ReturnValue, SqlDbType = SqlDbType.Int &#125;); sqlCom.ExecuteNonQuery(); return sqlCom.Parameters["@return"].Value; &#125; &emsp;&emsp;以上代码中，便是使用了using(/* new object */){/*do something*/}来包裹代码。 Attribute 特性 &emsp;&emsp;特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。&emsp;&emsp;特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：预定义特性和自定义特性。 预定义特性（Attribute） .Net 框架提供了三种预定义特性： AttributeUsage:&emsp;&emsp;预定义特性 AttributeUsage 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。规定该特性的语法如下： Conditional:&emsp;&emsp;这个预定义特性标记了一个条件方法，其执行依赖于它顶的预处理标识符。 Obsolete:&emsp;&emsp;这个预定义特性标记了不应被使用的程序实体。 MSDN具体介绍 创建自定义特性（Attribute）[ 不使用 ] .Net 框架允许创建自定义特性，用于存储声明性的信息，且可在运行时被检索。该信息根据设计标准和应用程序需要，可与任何目标元素相关。 &emsp;&emsp;创建并使用自定义特性包含四个步骤： 声明自定义特性 构建自定义特性 在目标程序元素上应用自定义特性 通过反射访问特性 最后一个步骤包含编写一个简单的程序来读取元数据以便查找各种符号。元数据是用于描述其他数据的数据和信息。该程序应使用反射来在运行时访问特性。 MSDN具体介绍]]></content>
      <tags>
        <tag>.net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp篇-叁]]></title>
    <url>%2F2017%2F05%2F03%2FCSharp%E7%AF%87-%E5%8F%81%2F</url>
    <content type="text"><![CDATA[.NET Core Web Api 快速入手 —— C#篇 [ 叁 ]本篇内容静态方法与静态字段命名空间 静态方法与静态字段 &emsp;&emsp;在GitHub上我的TTMS WebApi项目中， Servers文件夹中是具体的数据库操作。所有的方法都使用static静态方法。在Server.cs文件中使用了static存储全局的数据库连接字符串。 静态方法 &emsp;&emsp;静态方法可以被重载但不能被重写，因为它们属于类，不属于类的任何实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt;/// 登陆/// &lt;/summary&gt;/// &lt;returns&gt;登陆结果&lt;/returns&gt;/// &lt;param name="account"&gt;账号&lt;/param&gt;/// &lt;param name="password"&gt;密码&lt;/param&gt;public static object Login(string account, string password)&#123; using (var con = new SqlConnection(Server.SqlConString)) &#123; con.Open(); var sqlCom = new SqlCommand("sp_login", con) &#123; CommandType = CommandType.StoredProcedure &#125;; sqlCom.Parameters.Add(new SqlParameter &#123; ParameterName = "@account", Direction = ParameterDirection.Input, SqlDbType = SqlDbType.NVarChar, Size = 15, Value = account &#125;); sqlCom.Parameters.Add(new SqlParameter &#123; ParameterName = "@password", Direction = ParameterDirection.Input, SqlDbType = SqlDbType.NVarChar, Size = 15, Value = password &#125;); sqlCom.Parameters.Add(new SqlParameter &#123; ParameterName = "@return", Direction = ParameterDirection.ReturnValue, SqlDbType = SqlDbType.Int &#125;); sqlCom.ExecuteNonQuery(); return sqlCom.Parameters["@return"].Value; &#125;&#125; &emsp;&emsp;这便是一个具体的静态方法操作数据库。我们暂时无需关注方法内部的代码，仅仅将方法声明提出来，如下 1234public static object Login(string account , string password)&#123;&#125; &emsp;&emsp;public是访问修饰符，object是返回类型，而其中的static便是声明这是一个静态方法。这个方法不需要其类创建实例便可以使用类名+方法名的方法来调用。比如: 1var result = User.Login(account , password); 静态字段 &emsp;&emsp;静态字段有两个常见的用法：一是记录已实例化对象的个数，二是存储必须在所有实例之间共享的值。 &emsp;&emsp;在我们的项目中，使用静态字段来存储数据库连接字符串 &emsp;&emsp;静态字段的声明: 12 public class Server{ /// &lt;summary&gt; /// 连接字符串 /// &lt;/summary&gt; public static string SqlConString = &quot;&quot;; } 1234567&amp;emsp;&amp;emsp;在Server类中，创建了一个静态字段SqlConString，并将其初始化为&quot;&quot;; &amp;emsp;&amp;emsp;静态字段的使用就直接是类名+字段名，如下: ```csharp//创建一个数据库连接实例，参数是数据库连接字符串var con = new SqlConnection(Server.SqlConString); &emsp;&emsp;在上边的代码中，使用了Server.SqlConString获取这个字段并且作为参数传递给了SqlConnection类的构造方法。 &emsp;&emsp;当然，静态字段也可以作为左值。 123 //读取连接字符串 //Servers是命名空间 [ 见下 ]Servers.Server.SqlConString = Configuration.GetConnectionString("DefaultConnection"); &emsp;&emsp;如上，为Server.SqlConString赋值。 命名空间 [ 仅仅了解 ] &emsp;&emsp;命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。 &emsp;&emsp;命名空间定义: 12345//TTMSnamespace TTMS&#123; //class&#125; &emsp;&emsp;调用: 123//命名空间直接前缀来调用Servers.Server.SqlConString = " "; //somethingServers.Server.Log(); 1234//使用using引入using Servers;Server.SqlConString = " "; //somethingServer.Log();]]></content>
      <tags>
        <tag>.net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp篇-贰]]></title>
    <url>%2F2017%2F05%2F02%2FCSharp%E7%AF%87-%E8%B4%B0%2F</url>
    <content type="text"><![CDATA[.NET Core Web Api 快速入手 —— C#篇 [ 贰 ]本篇内容类基础 类 &emsp;&emsp;“类”是一种构造，通过使用该构造，您可以将其他类型的变量、方法和事件组合在一起，从而创建自己的自定义类型。 类就像一个蓝图， 它定义类型的数据和行为。 如果类没有声明为静态类，客户端代码就可以创建赋给变量的“对象”或“实例”，从而使用该类。 在对变量的所有引用都超出范围之前，该变量始终保持在内存中。 所有引用都超出范围时，CLR 将标记该变量以供垃圾回收。 如果类声明为静态类，则内存中只存在一个副本，并且客户端代码只能通过该类自身而不是“实例变量”访问该类。 有关更多信息，请参见静态类和静态类成员。 C#类的声明 1234public class ClassName&#123; //Fields, properties, methods and events go here...&#125; C# Struct [ 未使用 ， 仅介绍 ] &emsp;&emsp;结构是使用 struct 关键字定义的，例如： 1234public struct PostalAddress&#123; // Fields, properties, methods and events go here...&#125; &emsp;&emsp;结构与类共享大多数相同的语法，但结构比类受到的限制更多： 在结构声明中，除非字段被声明为 const 或 static，否则无法初始化。 结构不能声明默认构造函数（没有参数的构造函数）或析构函数。 结构在赋值时进行复制。 将结构赋值给新变量时，将复制所有数据，并且对新副本所做的任何修改不会更改原始副本的数据。 在使用值类型的集合（如 Dictionary）时，请务必记住这一点。 结构是值类型，而类是引用类型。 与类不同，结构的实例化可以不使用 new 运算符。 结构可以声明带参数的构造函数。 一个结构不能从另一个结构或类继承，而且不能作为一个类的基。 所有结构都直接继承自 System.ValueType，后者继承自 System.Object。 结构可以实现接口。 结构可用作可以为 null 的类型，因而可向其赋 null 值。 C#类的成员 字段 : 字段是在类范围声明的变量。 字段可以是内置数值类型或其他类的实例。 例如，日历类可能具有一个包含当前日期的字段。 常量 : 常量是在编译时设置其值并且不能更改其值的字段或属性。 属性 : 属性是类中可以像类中的字段一样访问的方法。 属性可以为类字段提供保护，以避免字段在对象不知道的情况下被更改。 方法 : 方法定义类可以执行的操作。 方法可以接受提供输入数据的参数，并且可以通过参数返回输出数据。 方法还可以不使用参数而直接返回值。 事件 : 事件向其他对象提供有关发生的事情（如单击按钮或成功完成某个方法）的通知。 事件是使用委托定义和触发的。 运算符 : 重载运算符被视为类成员。 在重载运算符时，在类中将该运算符定义为公共静态方法。 预定义运算符（+、*、&lt; 等）不考虑作为成员。 索引器 : 使用索引器可以用类似于数组的方式为对象建立索引。 构造函数 : 构造函数是在第一次创建对象时调用的方法。 它们通常用于初始化对象的数据。暂时不用 析构函数 : C# 中极少使用析构函数。 析构函数是当对象即将从内存中移除时由运行时执行引擎调用的方法。 它们通常用来确保任何必须释放的资源都得到适当的处理。暂时不用 嵌套类型 : 嵌套类型是在其他类型中声明的类型， 通常用于描述仅由包含它们的类型所使用的对象。暂时不用 &emsp;&emsp;对这些内容，在使用的时候将会一一讲解。本篇文章只是大概的介绍C#类的概念。（其实和其他面向对象语言差不了多少） C#类的访问修饰符 public : 同一程序集中的任何其他代码或引用该程序集的其他程序集都可以访问该类型或成员。同java private : 只有同一类或结构中的代码可以访问该类型或成员。|同java protected : 只有同一类或结构或者此类的派生类中的代码才可以访问的类型或成员。 同java internal : 同一程序集中的任何代码都可以访问该类型或成员，但其他程序集中的代码不可以 protected internal : 由其声明的程序集或另一个程序集派生的类中任何代码都可访问的类型或成员。 从另一个程序集进行访问必须在类声明中发生，该类声明派生自其中声明受保护的内部元素的类，并且必须通过派生的类类型的实例发生 | 暂时不用 &emsp;&emsp;对public , private , protected ，使用方法和意义都等同于java , 所以只详细说明 internal &emsp;&emsp;被 internal 修饰的东西只能在本程序集（当前项目）内被使用. &emsp;&emsp;对于一些大型的项目，通常由很多个DLL文件组成，引用了这些DLL，就能访问DLL里面的类和类里面的方法。及当使用internal修饰后，引用这个DLL的项目是不能访问被修饰的类或者方法的。当然在我们的项目里暂时用不上。 C#类的对象和集合初始值设定项 &emsp;&emsp;使用对象初始值设定项，你可以在创建对象时向对象的任何可访问字段或属性分配值，而无需调用后跟赋值语句行的构造函数。 利用对象初始值设定项语法，你可为构造函数指定参数或忽略参数（以及括号语法）。 以下示例演示如何使用具有命名类型 Cat 的对象初始值设定项以及如何调用默认构造函数。 请注意，自动实现的属性在 Cat 类中的用法。 12345678class Cat&#123; // Auto-implemented properties. public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125;&#125;Cat cat = new Cat &#123; Age = 10, Name = "Fluffy" &#125;; &emsp;&emsp;具有匿名类型的对象初始值设定项 12//创造一个匿名对象new Ca &#123;Name = "yangfan" , Age = "19"&#125; &emsp;&emsp;web api可以使用匿名对象对查询，操作结果进行返回，所以这个很重要 &emsp;&emsp;对一门面向对象语言来说，类是最重要的概念，对于类的内容将在后边几篇中慢慢分析。]]></content>
      <tags>
        <tag>.net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp篇-壹]]></title>
    <url>%2F2017%2F05%2F01%2FCSharp%E7%AF%87-%E5%A3%B9%2F</url>
    <content type="text"><![CDATA[.NET Core Web Api 快速入手 —— C#篇 [ 壹 ]本篇内容数据类型var关键字数组，循环，输入与输出 c#数据类型 &emsp;&emsp;在 C# 中，变量分为以下几种类型： 值类型（Value types）,引用类型（Reference types）,指针类型（Pointer types） &emsp;&emsp;值类型变量可以直接分配给一个值。它们是从类 System.ValueType 中派生的。 &emsp;&emsp;值类型直接包含数据。比如 int、char、float，它们分别存储数字、字母、浮点数。当您声明一个 int 类型时，系统分配内存来存储值。 &emsp;&emsp;引用类型及不包含存储在变量中的实际数据，但它们包含对变量的引用。它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。 &emsp;&emsp;指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。[ 不做具体讲解 ] &emsp;&emsp;数据类型无需熟背，在长久的使用中自然会了解。目前只需要知道C#中存在这些类型就可以了 c#var关键字 &emsp;&emsp;var关键字是伴随这.NET 3.5以后，伴随着匿名函数、LINQ而来,由编译器帮我们推断具体的类型。总体来说，当一个变量是局部变量(不包括类级别的变量)，并且在声明的时候初始化，是使用var关键字的前提。 &emsp;&emsp;比如在声明并且初始化局部变量的时候可使用var 12var a = 10;var b = "123"; &emsp;&emsp;在foreach循环中使用 1234for(var it : mList)&#123; //do somethong&#125; &emsp;&emsp;var关键字可以大幅度减少代码冗余量，弱化数据类型的概念。配合foreach语句 ， linq语句 ， lambda表达式使用有很好的效果。具体用或者不用看个人喜好。总之我是很喜欢这个特性的。 c#循环，数组，输入，输出 循环 while 循环 1234while(condition)&#123; statement(s);&#125; for 循环 1234for ( init; condition; increment )&#123; statement(s);&#125; do-while 12345do&#123; statement(s);&#125;while(condition) foreach 循环 &emsp;&emsp;c#中支持几乎所有的数组，容器进行foreach循环，并且我个人极力倡导如此使用，具体之后再讲 123456int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;foreach (var element in fibarray)&#123; System.Console.WriteLine(element);&#125;System.Console.WriteLine(); 数组 &emsp;&emsp;c#语言支持普通数组（如下），也支持容器，平时建议使用容器。 12//定义并且初始化int一维数组int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;; 输出输入 控制台输出 &emsp;&emsp;C# 控制台程序一般使用 .NET Framework Console 类提供的输入/输出服务。 1Console.WriteLine("Hello World!"); &emsp;&emsp;语句使用 WriteLine 方法。它在命令行窗口中显示其字符串参数并换行。其他 Console 方法用于不同的输入和输出操作。Console 类是 System 命名空间的成员。如果程序开头没有包含using System; 语句，则必须指定System 类，如下所示： 1System.Console.WriteLine("Hello World!"); &emsp;&emsp;WriteLine 方法十分有用，在编写控制台应用程序时会经常用到它。 &emsp;&emsp;WriteLine 可显示字符串： 1Console.WriteLine("Hello World!"); &emsp;&emsp;WriteLine 也可显示数字： 12int x = 42; Console.WriteLine(x); &emsp;&emsp;如果需要显示若干个项，则用 {0} 表示第一项，{1} 表示第二项，依此类推，如下所示： 123int year = 2008; string str = "今年是"; Console.WriteLine(" &#123;0&#125; &#123;1&#125;年.", str, year); &emsp;&emsp;输出应如下: 1今年是2008年. &emsp;&emsp;Console.WriteLine()方法是将要输出的字符串与换行控制字符一起出,当次语句执行完毕时,光标会移到目前输出字符串的下一行. &emsp;&emsp;至于Console.Write()方法,光标会停在输出字符串的最后一个字符后,不会移动到下一行，其余的用法与Console.WriteLine()一样。 控制台输入 &emsp;&emsp;在C#控制台程序中提供了两种方法让用户输入所需数据，它们是有Console类提供的静态方法。static int Read() 和 static string ReadLine()。 &emsp;&emsp;要读取单个字符，则使用Read()方法，它等待用户输入一个键，然后返回结果。字符作为int类型的值返回，所以要显示字符就必须转换为char类型。 &emsp;&emsp;要读取一串字符，则使用ReadLine()方法。该方法一直读取字符，直到用户按下ENTER键，然后将它们返回到string 类型的对象中。 1234567891011121314151617181920212223242526using System;//Console.Read() 示例class KbIn &#123; public static void Main() &#123; char ch; Console.Write("Press a key followed by ENTER: "); // 读取一个字符 ch = (char) Console.Read(); Console.WriteLine("Your key is: " + ch); &#125;&#125;using System;//Console.ReadLine() 示例class ReadString &#123; public static void Main() &#123; string str; Console.WriteLine("Enter some characters."); str = Console.ReadLine(); Console.WriteLine("You entered: " + str); &#125;&#125;]]></content>
      <tags>
        <tag>.net</tag>
      </tags>
  </entry>
</search>
