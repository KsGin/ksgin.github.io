---
title: CSharp篇-贰
date: 2017-05-02 18:46:40
tags: .net
---

# .NET Core Web Api 快速入手 —— C#篇 [ 贰 ]

### 本篇内容
*类基础*<br>

1. 类

>&emsp;&emsp;“类”是一种构造，通过使用该构造，您可以将其他类型的变量、方法和事件组合在一起，从而创建自己的自定义类型。 类就像一个蓝图， 它定义类型的数据和行为。 如果类没有声明为静态类，客户端代码就可以创建赋给变量的“对象”或“实例”，从而使用该类。 在对变量的所有引用都超出范围之前，该变量始终保持在内存中。 所有引用都超出范围时，CLR 将标记该变量以供垃圾回收。 如果类声明为静态类，则内存中只存在一个副本，并且客户端代码只能通过该类自身而不是“实例变量”访问该类。 有关更多信息，请参见静态类和静态类成员。

* C#类的声明

    ```CSharp
    public class ClassName
    {
        //Fields, properties, methods and events go here...
    }
    ```

* C# Struct [ 未使用 ， 仅介绍 ]

    <!--more-->

    &emsp;&emsp;结构是使用 struct 关键字定义的，例如：

    ```CSharp
    public struct PostalAddress
    {
        // Fields, properties, methods and events go here...
    }
    ```

    >&emsp;&emsp;结构与类共享大多数相同的语法，但结构比类受到的限制更多：
    >* 在结构声明中，除非字段被声明为 const 或 static，否则无法初始化。
    >* 结构不能声明默认构造函数（没有参数的构造函数）或析构函数。
    >* 结构在赋值时进行复制。 将结构赋值给新变量时，将复制所有数据，并且对新副本所做的任何修改不会更改原始副本的数据。 在使用值类型的集合（如 Dictionary<string, myStruct>）时，请务必记住这一点。
    >* ***结构是值类型，而类是引用类型。***
    >* 与类不同，结构的实例化可以不使用 new 运算符。
    >* 结构可以声明带参数的构造函数。
    >* 一个结构不能从另一个结构或类继承，而且不能作为一个类的基。 所有结构都直接继承自 System.ValueType，后者继承自 System.Object。
    >* 结构可以实现接口。
    >* 结构可用作可以为 null 的类型，因而可向其赋 null 值。

* C#类的成员

    * ***字段*** : 字段是在类范围声明的变量。 字段可以是内置数值类型或其他类的实例。 例如，日历类可能具有一个包含当前日期的字段。 
    * ***常量*** : 常量是在编译时设置其值并且不能更改其值的字段或属性。
    * ***属性*** : 属性是类中可以像类中的字段一样访问的方法。 属性可以为类字段提供保护，以避免字段在对象不知道的情况下被更改。
    * ***方法*** : 方法定义类可以执行的操作。 方法可以接受提供输入数据的参数，并且可以通过参数返回输出数据。 方法还可以不使用参数而直接返回值。
    * ***事件*** : 事件向其他对象提供有关发生的事情（如单击按钮或成功完成某个方法）的通知。 事件是使用委托定义和触发的。
    * ***运算符*** : 重载运算符被视为类成员。 在重载运算符时，在类中将该运算符定义为公共静态方法。 预定义运算符（+、*、< 等）不考虑作为成员。
    * ***索引器*** : 使用索引器可以用类似于数组的方式为对象建立索引。
    * ***构造函数*** : 构造函数是在第一次创建对象时调用的方法。 它们通常用于初始化对象的数据。暂时不用
    * ***析构函数*** : C# 中极少使用析构函数。 析构函数是当对象即将从内存中移除时由运行时执行引擎调用的方法。 它们通常用来确保任何必须释放的资源都得到适当的处理。暂时不用
    * ***嵌套类型*** : 嵌套类型是在其他类型中声明的类型， 通常用于描述仅由包含它们的类型所使用的对象。暂时不用

    &emsp;&emsp;对这些内容，在使用的时候将会一一讲解。本篇文章只是大概的介绍C#类的概念。（其实和其他面向对象语言差不了多少）

* C#类的访问修饰符

    * ***public*** : 同一程序集中的任何其他代码或引用该程序集的其他程序集都可以访问该类型或成员。同java
    * ***private*** : 只有同一类或结构中的代码可以访问该类型或成员。|同java
    * ***protected*** : 只有同一类或结构或者此类的派生类中的代码才可以访问的类型或成员。 同java
    * ***internal*** : 同一程序集中的任何代码都可以访问该类型或成员，但其他程序集中的代码不可以
    * ***protected internal*** : 由其声明的程序集或另一个程序集派生的类中任何代码都可访问的类型或成员。 从另一个程序集进行访问必须在类声明中发生，该类声明派生自其中声明受保护的内部元素的类，并且必须通过派生的类类型的实例发生 | 暂时不用

    &emsp;&emsp;对public , private , protected ，使用方法和意义都等同于java , 所以只详细说明 internal

    >&emsp;&emsp;被 internal 修饰的东西只能在本程序集（当前项目）内被使用.

    &emsp;&emsp;对于一些大型的项目，通常由很多个DLL文件组成，引用了这些DLL，就能访问DLL里面的类和类里面的方法。及当使用internal修饰后，引用这个DLL的项目是不能访问被修饰的类或者方法的。当然在我们的项目里暂时用不上。

* C#类的对象和集合初始值设定项

    >&emsp;&emsp;使用对象初始值设定项，你可以在创建对象时向对象的任何可访问字段或属性分配值，而无需调用后跟赋值语句行的构造函数。 利用对象初始值设定项语法，你可为构造函数指定参数或忽略参数（以及括号语法）。 以下示例演示如何使用具有命名类型 Cat 的对象初始值设定项以及如何调用默认构造函数。 请注意，自动实现的属性在 Cat 类中的用法。

    ```CSharp
    class Cat
    {
        // Auto-implemented properties.
        public int Age { get; set; }
        public string Name { get; set; }
    }

    Cat cat = new Cat { Age = 10, Name = "Fluffy" };
    ```

    &emsp;&emsp;具有匿名类型的对象初始值设定项

    ```CSharp
    //创造一个匿名对象
    new Ca {Name = "yangfan" , Age = "19"}
    ```
    &emsp;&emsp;***web api可以使用匿名对象对查询，操作结果进行返回，所以这个很重要***

    &emsp;&emsp;对一门面向对象语言来说，类是最重要的概念，对于类的内容将在后边几篇中慢慢分析。
