---
title: 【DX11地形篇】15-基于距离的法线贴图
date: 2018-05-15 13:36:19
tags:
	- Terrain
	- GameDev
	- DirectX
	- Computer graphics
---

#### 参考教程

[Tutorial 14: Distance Normal Mapping](http://www.rastertek.com/dx11ter14.html)

#### 学习记录

&emsp;&emsp;本篇文章中我们介绍基于观察点（摄像机）距离不同进行不同法线贴图的技术，本篇代码基于上一篇，仅有少量改动，无新增类。

<!--more-->

&emsp;&emsp;对于我们所渲染的大场景而言，近处我们需要更多的细节，而远处则可以稍微小一些，太多细节的反射对于我们而言没什么意义。

&emsp;&emsp;首先我们需要修改 `Terrain.vs` 和 `Terrain.ps` ，我们的每个顶点将携带两个纹理坐标，并且使用不同的纹理，如下：

```c++
////////////////////////////////////////////////////////////////////////////////
// Filename: terrain.vs
////////////////////////////////////////////////////////////////////////////////


/////////////
// GLOBALS //
/////////////
cbuffer MatrixBuffer
{
	matrix worldMatrix;
	matrix viewMatrix;
	matrix projectionMatrix;
};


//////////////
// TYPEDEFS //
//////////////
struct VertexInputType
{
    float4 position : POSITION;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;
	float3 tangent : TANGENT;
    float3 binormal : BINORMAL;
	float3 color : COLOR;
	float2 tex2 : TEXCOORD1;
};

struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;
	float3 tangent : TANGENT;
    float3 binormal : BINORMAL;
	float4 color : COLOR;
	float2 tex2 : TEXCOORD1;
    float4 depthPosition : TEXCOORD2;
};


////////////////////////////////////////////////////////////////////////////////
// Vertex Shader
////////////////////////////////////////////////////////////////////////////////
PixelInputType TerrainVertexShader(VertexInputType input)
{
    PixelInputType output;
    

	// Change the position vector to be 4 units for proper matrix calculations.
    input.position.w = 1.0f;

	// Calculate the position of the vertex against the world, view, and projection matrices.
    output.position = mul(input.position, worldMatrix);
    output.position = mul(output.position, viewMatrix);
    output.position = mul(output.position, projectionMatrix);
    
	// Store the texture coordinates for the pixel shader.
    output.tex = input.tex;
    
	// Calculate the normal vector against the world matrix only.
    output.normal = mul(input.normal, (float3x3)worldMatrix);
	
    // Normalize the normal vector.
    output.normal = normalize(output.normal);

	// Calculate the tangent vector against the world matrix only and then normalize the final value.
    output.tangent = mul(input.tangent, (float3x3)worldMatrix);
    output.tangent = normalize(output.tangent);

    // Calculate the binormal vector against the world matrix only and then normalize the final value.
    output.binormal = mul(input.binormal, (float3x3)worldMatrix);
    output.binormal = normalize(output.binormal);

	output.color = float4(input.color , 1.0f);

	// Store the position value in a second input value for depth value calculations.
    output.depthPosition = output.position;

    return output;
}

////////////////////////////////////////////////////////////////////////////////
// Filename: terrain.ps
////////////////////////////////////////////////////////////////////////////////


/////////////
// GLOBALS //
/////////////
Texture2D diffuseTexture1 : register(t0);
Texture2D normalTexture1 : register(t1);
Texture2D normalTexture2 : register(t2);
Texture2D normalTexture3 : register(t3);

SamplerState SampleType : register(s0);

//////////////////////
// CONSTANT BUFFERS //
//////////////////////
cbuffer LightBuffer
{
    float4 diffuseColor;
    float3 lightDirection;
    float padding;
};


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;
	float3 tangent : TANGENT;
    float3 binormal : BINORMAL;
	float4 color : COLOR;
	float2 tex2 : TEXCOORD1;
    float4 depthPosition : TEXCOORD2;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 TerrainPixelShader(PixelInputType input) : SV_TARGET
{
    float slope;
    float3 lightDir;
    float4 textureColor1;
    float4 textureColor2;
    float4 bumpMap;
    float3 bumpNormal;
    float lightIntensity;
    float4 material1;
    float4 material2;
    float blendAmount;
    float4 color;
	float depthValue;


    // Calculate the slope of this point.
    slope = 1.0f - input.normal.y;
	 
	// Get the depth value of the pixel by dividing the Z pixel depth by the homogeneous W coordinate.
    depthValue = input.depthPosition.z / input.depthPosition.w;

    // Invert the light direction for calculations.
    lightDir = -lightDirection;
	
    // Setup the first material.
    textureColor1 = diffuseTexture1.Sample(SampleType, input.tex);

	 // Select the normal map for the first material based on the distance.
    if(depthValue > 0.998f)
    {
        bumpMap = normalTexture3.Sample(SampleType, input.tex2);
    }
    else
    {
        bumpMap = normalTexture1.Sample(SampleType, input.tex);
    }

    bumpMap = (bumpMap * 2.0f) - 1.0f;
    bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal);
    bumpNormal = normalize(bumpNormal);
    lightIntensity = saturate(dot(bumpNormal, lightDir));
    material1 = saturate(textureColor1 * lightIntensity);
	
    // Setup the second material.
    textureColor2 = float4(1.0f, 1.0f, 1.0f, 1.0f);  // Snow color.
    bumpMap = normalTexture2.Sample(SampleType, input.tex);
    bumpMap = (bumpMap * 2.0f) - 1.0f;
    bumpNormal = (bumpMap.x * input.tangent) + (bumpMap.y * input.binormal) + (bumpMap.z * input.normal);
    bumpNormal = normalize(bumpNormal);
    lightIntensity = saturate(dot(bumpNormal, lightDir));
    material2 = saturate(textureColor2 * lightIntensity);

    // Determine which material to use based on slope.
    if(slope < 0.2)
    {
        blendAmount = slope / 0.2f;
        color = lerp(material2, material1, blendAmount);
    }
    if(slope >= 0.2) 
    {
        color = material1;
    }

    return color;

}
```

&emsp;&emsp;之后，我们需要修改我们的 `TerrainClass` ，为其新增第二个纹理坐标的初始化：

```c++
bool TerrainClass::BuildTerrainModel() {
	int i, j, index, index1, index2, index3, index4;
	float quadsCovered, incrementSize, tu2Left, tu2Right, tv2Bottom, tv2Top;

	// Calculate the number of vertices in the 3D terrain model.
	m_vertexCount = (m_terrainHeight - 1) * (m_terrainWidth - 1) * 6;

	// Create the 3D terrain model array.
	m_terrainModel = new ModelType[m_vertexCount];
	if(!m_terrainModel)
	{
		return false;
	}

	// Setup the increment size for the second set of textures.
	// This is a fixed 33x33 vertex array per cell so there will be 32 rows of quads in a cell.
	quadsCovered = 32.0f;
	incrementSize = 1.0f / quadsCovered;

	// Initialize the texture increments.
	tu2Left = 0.0f;
	tu2Right = incrementSize;
	tv2Top = 0.0f;
	tv2Bottom = incrementSize;


	// Initialize the index into the height map array.
	index = 0;

	// Load the 3D terrain model with the height map terrain data.
	// We will be creating 2 triangles for each of the four points in a quad.
	for(j=0; j<(m_terrainHeight-1); j++)
	{
		for(i=0; i<(m_terrainWidth-1); i++)
		{
			// Get the indexes to the four points of the quad.
			index1 = (m_terrainWidth * j) + i;          // Upper left.
			index2 = (m_terrainWidth * j) + (i+1);      // Upper right.
			index3 = (m_terrainWidth * (j+1)) + i;      // Bottom left.
			index4 = (m_terrainWidth * (j+1)) + (i+1);  // Bottom right.

			// Now create two triangles for that quad.
			// Triangle 1 - Upper left.
			m_terrainModel[index].x = m_heightMap[index1].x;
			m_terrainModel[index].y = m_heightMap[index1].y;
			m_terrainModel[index].z = m_heightMap[index1].z;
			m_terrainModel[index].tu = 0.0f;
			m_terrainModel[index].tv = 0.0f;
			m_terrainModel[index].nx = m_heightMap[index1].nx;
			m_terrainModel[index].ny = m_heightMap[index1].ny;
			m_terrainModel[index].nz = m_heightMap[index1].nz;
			m_terrainModel[index].r = m_heightMap[index1].r;
			m_terrainModel[index].g = m_heightMap[index1].g;
			m_terrainModel[index].b = m_heightMap[index1].b;
			m_terrainModel[index].tu2 = tu2Left;
			m_terrainModel[index].tv2 = tv2Top;
			index++;

			// Triangle 1 - Upper right.
			m_terrainModel[index].x = m_heightMap[index2].x;
			m_terrainModel[index].y = m_heightMap[index2].y;
			m_terrainModel[index].z = m_heightMap[index2].z;
			m_terrainModel[index].tu = 1.0f;
			m_terrainModel[index].tv = 0.0f;
			m_terrainModel[index].nx = m_heightMap[index2].nx;
			m_terrainModel[index].ny = m_heightMap[index2].ny;
			m_terrainModel[index].nz = m_heightMap[index2].nz;
			m_terrainModel[index].r = m_heightMap[index2].r;
			m_terrainModel[index].g = m_heightMap[index2].g;
			m_terrainModel[index].b = m_heightMap[index2].b;
			m_terrainModel[index].tu2 = tu2Right;
			m_terrainModel[index].tv2 = tv2Top;

			index++;

			// Triangle 1 - Bottom left.
			m_terrainModel[index].x = m_heightMap[index3].x;
			m_terrainModel[index].y = m_heightMap[index3].y;
			m_terrainModel[index].z = m_heightMap[index3].z;
			m_terrainModel[index].tu = 0.0f;
			m_terrainModel[index].tv = 1.0f;
			m_terrainModel[index].nx = m_heightMap[index3].nx;
			m_terrainModel[index].ny = m_heightMap[index3].ny;
			m_terrainModel[index].nz = m_heightMap[index3].nz;
			m_terrainModel[index].r = m_heightMap[index3].r;
			m_terrainModel[index].g = m_heightMap[index3].g;
			m_terrainModel[index].b = m_heightMap[index3].b;
			m_terrainModel[index].tu2 = tu2Left;
			m_terrainModel[index].tv2 = tv2Bottom;

			index++;

			// Triangle 2 - Bottom left.
			m_terrainModel[index].x = m_heightMap[index3].x;
			m_terrainModel[index].y = m_heightMap[index3].y;
			m_terrainModel[index].z = m_heightMap[index3].z;
			m_terrainModel[index].tu = 0.0f;
			m_terrainModel[index].tv = 1.0f;
			m_terrainModel[index].nx = m_heightMap[index3].nx;
			m_terrainModel[index].ny = m_heightMap[index3].ny;
			m_terrainModel[index].nz = m_heightMap[index3].nz;
			m_terrainModel[index].r = m_heightMap[index3].r;
			m_terrainModel[index].g = m_heightMap[index3].g;
			m_terrainModel[index].b = m_heightMap[index3].b;
			m_terrainModel[index].tu2 = tu2Left;
			m_terrainModel[index].tv2 = tv2Bottom;

			index++;

			// Triangle 2 - Upper right.
			m_terrainModel[index].x = m_heightMap[index2].x;
			m_terrainModel[index].y = m_heightMap[index2].y;
			m_terrainModel[index].z = m_heightMap[index2].z;
			m_terrainModel[index].tu = 1.0f;
			m_terrainModel[index].tv = 0.0f;
			m_terrainModel[index].nx = m_heightMap[index2].nx;
			m_terrainModel[index].ny = m_heightMap[index2].ny;
			m_terrainModel[index].nz = m_heightMap[index2].nz;
			m_terrainModel[index].r = m_heightMap[index2].r;
			m_terrainModel[index].g = m_heightMap[index2].g;
			m_terrainModel[index].b = m_heightMap[index2].b;
			m_terrainModel[index].tu2 = tu2Right;
			m_terrainModel[index].tv2 = tv2Top;

			index++;

			// Triangle 2 - Bottom right.
			m_terrainModel[index].x = m_heightMap[index4].x;
			m_terrainModel[index].y = m_heightMap[index4].y;
			m_terrainModel[index].z = m_heightMap[index4].z;
			m_terrainModel[index].tu = 1.0f;
			m_terrainModel[index].tv = 1.0f;
			m_terrainModel[index].nx = m_heightMap[index4].nx;
			m_terrainModel[index].ny = m_heightMap[index4].ny;
			m_terrainModel[index].nz = m_heightMap[index4].nz;
			m_terrainModel[index].r = m_heightMap[index4].r;
			m_terrainModel[index].g = m_heightMap[index4].g;
			m_terrainModel[index].b = m_heightMap[index4].b;
			m_terrainModel[index].tu2 = tu2Right;
			m_terrainModel[index].tv2 = tv2Bottom;

			index++;

			// Increment the second tu texture coords.
			tu2Left += incrementSize;
			tu2Right += incrementSize;

			// Reset the second tu texture coordinate increments.
			if(tu2Right > 1.0f)
			{
				tu2Left = 0.0f;
				tu2Right = incrementSize;
			}

		}

		// Increment the second tv texture coords.
		tv2Top += incrementSize;
		tv2Bottom += incrementSize;

		// Reset the second tu texture coordinate increments.
		if(tv2Bottom > 1.0f)
		{
			tv2Top = 0.0f;
			tv2Bottom = incrementSize;
		}
	}

	return true;

}
```

&emsp;&emsp;最后，修改 `TerrainCellClass` 以支持新的顶线属性，以及 `TerrainShaderClass` 支持新的顶点属性以及多一张纹理输入。

&emsp;&emsp;最终效果：

![1](https://image.ibb.co/nOkGqd/image.png)

&emsp;&emsp;源代码：[**DX11TerrainTutorial-DistanceNormalMapping**](https://github.com/KsGin/DX11TerrainTutorial/tree/master/DX11TerrainTutorial-DistanceNormalMapping)